---
ms.openlocfilehash: ff31585520c9090ad92893a930327112743c8e77
ms.sourcegitcommit: 892af9016b3317a8fae12d195014dc38ba51cf16
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/01/2019
ms.locfileid: "71704000"
---
# <a name="basic-concepts"></a><span data-ttu-id="4d5ad-101">Conceitos básicos</span><span class="sxs-lookup"><span data-stu-id="4d5ad-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="4d5ad-102">Inicialização do aplicativo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-102">Application Startup</span></span>

<span data-ttu-id="4d5ad-103">Um assembly que tem um ***ponto de entrada*** é chamado de ***aplicativo***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="4d5ad-104">Quando um aplicativo é executado, um novo ***domínio de aplicativo*** é criado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="4d5ad-105">Várias instanciações diferentes de um aplicativo podem existir no mesmo computador ao mesmo tempo, e cada uma tem seu próprio domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="4d5ad-106">Um domínio de aplicativo habilita o isolamento de aplicativos agindo como um contêiner para o estado do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="4d5ad-107">Um domínio de aplicativo atua como um contêiner e limite para os tipos definidos no aplicativo e as bibliotecas de classes que ele usa.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="4d5ad-108">Os tipos carregados em um domínio de aplicativo são diferentes do mesmo tipo carregado em outro domínio de aplicativo, e as instâncias de objetos não são diretamente compartilhadas entre domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="4d5ad-109">Por exemplo, cada domínio de aplicativo tem sua própria cópia de variáveis estáticas para esses tipos, e um construtor estático para um tipo é executado no máximo uma vez por domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="4d5ad-110">As implementações são gratuitas para fornecer políticas ou mecanismos específicos de implementação para a criação e destruição de domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="4d5ad-111">A ***inicialização do aplicativo*** ocorre quando o ambiente de execução chama um método designado, que é chamado de ponto de entrada do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="4d5ad-112">Esse método de ponto de entrada sempre é denominado `Main` e pode ter uma das seguintes assinaturas:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="4d5ad-113">Como mostrado, o ponto de entrada pode opcionalmente retornar um valor `int`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="4d5ad-114">Esse valor de retorno é usado na terminação do aplicativo ([terminação do aplicativo](basic-concepts.md#application-termination)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="4d5ad-115">O ponto de entrada pode, opcionalmente, ter um parâmetro formal.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="4d5ad-116">O parâmetro pode ter qualquer nome, mas o tipo do parâmetro deve ser `string[]`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="4d5ad-117">Se o parâmetro formal estiver presente, o ambiente de execução criará e passará um argumento `string[]` contendo os argumentos de linha de comando que foram especificados quando o aplicativo foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="4d5ad-118">O argumento `string[]` nunca é nulo, mas pode ter um comprimento zero se nenhum argumento de linha de comando foi especificado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="4d5ad-119">Como C# o dá suporte à sobrecarga de método, uma classe ou struct pode conter várias definições de algum método, desde que cada uma tenha uma assinatura diferente.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="4d5ad-120">No entanto, em um único programa, nenhuma classe ou estrutura pode conter mais de um método chamado `Main` cuja definição o qualifica para ser usado como um ponto de entrada do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="4d5ad-121">Outras versões sobrecarregadas do `Main` são permitidas, no entanto, desde que tenham mais de um parâmetro, ou seu único parâmetro seja diferente do tipo `string[]`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="4d5ad-122">Um aplicativo pode ser composto por várias classes ou structs.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="4d5ad-123">É possível que mais de uma dessas classes ou structs contenham um método chamado `Main` cuja definição a qualifica para ser usada como um ponto de entrada de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="4d5ad-124">Nesses casos, um mecanismo externo (como uma opção de compilador de linha de comando) deve ser usado para selecionar um desses métodos `Main` como o ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="4d5ad-125">No C#, cada método deve ser definido como um membro de uma classe ou estrutura.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="4d5ad-126">Normalmente, a acessibilidade declarada (a[acessibilidade declarada](basic-concepts.md#declared-accessibility)) de um método é determinada pelos modificadores de acesso ([modificadores de acesso](classes.md#access-modifiers)) especificados em sua declaração e, da mesma forma, a acessibilidade declarada de um tipo é determinada pelo modificadores de acesso especificados em sua declaração.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="4d5ad-127">Para que um determinado método de um determinado tipo seja chamado, o tipo e o membro devem estar acessíveis.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="4d5ad-128">No entanto, o ponto de entrada do aplicativo é um caso especial.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="4d5ad-129">Especificamente, o ambiente de execução pode acessar o ponto de entrada do aplicativo independentemente de sua acessibilidade declarada e independentemente da acessibilidade declarada de suas declarações de tipo delimitador.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="4d5ad-130">O método de ponto de entrada de aplicativo pode não estar em uma declaração de classe genérica.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="4d5ad-131">Em todos os outros aspectos, os métodos de ponto de entrada se comportam como aqueles que não são pontos de entrada.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="4d5ad-132">Encerramento do aplicativo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-132">Application termination</span></span>

<span data-ttu-id="4d5ad-133">A ***terminação de aplicativo*** retorna o controle para o ambiente de execução.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="4d5ad-134">Se o tipo de retorno do método de ***ponto de entrada*** do aplicativo for `int`, o valor retornado servirá como o ***código de status de encerramento***do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="4d5ad-135">A finalidade desse código é permitir a comunicação de êxito ou falha no ambiente de execução.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="4d5ad-136">Se o tipo de retorno do método de ponto de entrada for `void`, atingir a chave direita (`}`) que encerra esse método, ou executar uma instrução `return` que não tenha nenhuma expressão, resultará em um código de status de encerramento de `0`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="4d5ad-137">Antes do encerramento de um aplicativo, os destruidores para todos os seus objetos que ainda não foram coletados pelo lixo são chamados, a menos que essa limpeza tenha sido suprimida (por uma chamada para o método de biblioteca `GC.SuppressFinalize`, por exemplo).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="4d5ad-138">Declarations</span><span class="sxs-lookup"><span data-stu-id="4d5ad-138">Declarations</span></span>

<span data-ttu-id="4d5ad-139">As declarações em C# um programa definem os elementos constituintes do programa.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="4d5ad-140">C#os programas são organizados usando Namespaces ([namespaces](namespaces.md)), que podem conter declarações de tipo e declarações de namespace aninhadas.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="4d5ad-141">Declarações de tipo ([declarações de tipo](namespaces.md#type-declarations)) são usadas para definir classes ([classes](classes.md)), estruturas[(structs](structs.md)), interfaces ([interfaces](interfaces.md)), enumerações ([enums](enums.md)) e delegados ([delegados](delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="4d5ad-142">Os tipos de membros permitidos em uma declaração de tipo dependem da forma da declaração de tipo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="4d5ad-143">Por exemplo, declarações de classe podem conter declarações para constantes ([constantes](classes.md#constants)), campos ([campos](classes.md#fields)), métodos ([métodos](classes.md#methods)), Propriedades ([Propriedades](classes.md#properties)), eventos ([eventos](classes.md#events)), indexadores ([indexadores](classes.md#indexers)), operadores ([operadores](classes.md#operators)), construtores de instância ([construtores de instância](classes.md#instance-constructors)), construtores estáticos ([construtores estáticos](classes.md#static-constructors)), destruidores ([destruidores](classes.md#destructors)) e tipos aninhados ([tipos aninhados](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="4d5ad-144">Uma declaração define um nome no ***espaço de declaração*** ao qual a declaração pertence.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="4d5ad-145">Exceto para Membros sobrecarregados ([assinaturas e sobrecarga](basic-concepts.md#signatures-and-overloading)), é um erro de tempo de compilação ter duas ou mais declarações que apresentam Membros com o mesmo nome em um espaço de declaração.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="4d5ad-146">Nunca é possível que um espaço de declaração contenha diferentes tipos de membros com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="4d5ad-147">Por exemplo, um espaço de declaração nunca pode conter um campo e um método com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="4d5ad-148">Há vários tipos diferentes de espaços de declaração, conforme descrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="4d5ad-149">Em todos os arquivos de origem de um programa, *namespace_member_declaration*s sem *namespace_declaration* delimitadores são membros de um único espaço de declaração combinado chamado de ***espaço de declaração global***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="4d5ad-150">Em todos os arquivos de origem de um programa, *namespace_member_declaration*s em *namespace_declaration*s que têm o mesmo nome de namespace totalmente qualificado são membros de um único espaço de declaração combinado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="4d5ad-151">Cada declaração de classe, struct ou interface cria um novo espaço de declaração.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="4d5ad-152">Os nomes são introduzidos nesse espaço de declaração por meio de *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s ou *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="4d5ad-153">Exceto para declarações de construtor de instância sobrecarregadas e declarações de Construtor estáticos, uma classe ou struct não pode conter uma declaração de membro com o mesmo nome que a classe ou struct.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="4d5ad-154">Uma classe, estrutura ou interface permite a declaração de métodos e indexadores sobrecarregados.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="4d5ad-155">Além disso, uma classe ou struct permite a declaração de operadores e construtores de instância sobrecarregados.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="4d5ad-156">Por exemplo, uma classe, struct ou interface pode conter várias declarações de método com o mesmo nome, desde que essas declarações de método difiram em sua assinatura ([assinaturas e sobrecarga](basic-concepts.md#signatures-and-overloading)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="4d5ad-157">Observe que as classes base não contribuem para o espaço de declaração de uma classe, e as interfaces base não contribuem para o espaço de declaração de uma interface.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="4d5ad-158">Assim, uma classe ou interface derivada tem permissão para declarar um membro com o mesmo nome de um membro herdado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="4d5ad-159">Esse membro é dito para ***ocultar*** o membro herdado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="4d5ad-160">Cada declaração de delegado cria um novo espaço de declaração.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="4d5ad-161">Os nomes são introduzidos nesse espaço de declaração por meio de parâmetros formais (*fixed_parameter*s e *parameter_array*s) e *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="4d5ad-162">Cada declaração de enumeração cria um novo espaço de declaração.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="4d5ad-163">Os nomes são introduzidos nesse espaço de declaração por meio de *enum_member_declarations*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="4d5ad-164">Cada declaração de método, declaração de indexador, declaração de operador, declaração de construtor de instância e função anônima cria um novo espaço de declaração chamado de ***espaço de declaração de variável local***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="4d5ad-165">Os nomes são introduzidos nesse espaço de declaração por meio de parâmetros formais (*fixed_parameter*s e *parameter_array*s) e *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="4d5ad-166">O corpo do membro da função ou da função anônima, se houver, será considerado aninhado dentro do espaço de declaração da variável local.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="4d5ad-167">É um erro para um espaço de declaração de variável local e um espaço de declaração de variável local aninhada para conter elementos com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="4d5ad-168">Portanto, dentro de um espaço de declaração aninhada não é possível declarar uma variável local ou constante com o mesmo nome de uma variável local ou constante em um espaço de declaração de delimitador.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="4d5ad-169">É possível que dois espaços de declaração contenham elementos com o mesmo nome, desde que nenhum espaço de declaração contenha o outro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="4d5ad-170">Cada *bloco* ou *switch_block* , bem como uma instrução *for*, *foreach* e *using* , cria um espaço de declaração de variável local para variáveis locais e constantes locais.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="4d5ad-171">Os nomes são introduzidos nesse espaço de declaração por meio de *local_variable_declaration*s e *local_constant_declaration*s.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="4d5ad-172">Observe que os blocos que ocorrem como ou dentro do corpo de um membro de função ou função anônima são aninhados dentro do espaço de declaração de variável local declarado por essas funções para seus parâmetros.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="4d5ad-173">Portanto, é um erro ter, por exemplo, um método com uma variável local e um parâmetro de mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="4d5ad-174">Cada *bloco* ou *switch_block* cria um espaço de declaração separado para rótulos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="4d5ad-175">Os nomes são introduzidos nesse espaço de declaração por meio de *labeled_statement*s e os nomes são referenciados por meio de *goto_statement*s.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="4d5ad-176">O ***espaço de declaração de rótulo*** de um bloco inclui todos os blocos aninhados.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="4d5ad-177">Portanto, em um bloco aninhado não é possível declarar um rótulo com o mesmo nome de um rótulo em um bloco delimitador.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="4d5ad-178">Em geral, a ordem textual na qual os nomes são declarados não é significado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="4d5ad-179">Em particular, a ordem textual não é significativa para a declaração e o uso de namespaces, constantes, métodos, propriedades, eventos, indexadores, operadores, construtores de instância, destruidores, construtores estáticos e tipos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="4d5ad-180">A ordem de declaração é significativa das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="4d5ad-181">A ordem de declaração para declarações de campo e declarações de variáveis locais determina a ordem na qual seus inicializadores (se houver) são executados.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="4d5ad-182">As variáveis locais devem ser definidas antes de serem usadas ([escopos](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="4d5ad-183">A ordem de declaração para declarações de membro de enumeração ([membros de enum](enums.md#enum-members)) é significativa quando os valores de *constant_expression* são omitidos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="4d5ad-184">O espaço de declaração de um namespace é "Open finalizado" e duas declarações de namespace com o mesmo nome totalmente qualificado contribuem para o mesmo espaço de declaração.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="4d5ad-185">Por exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="4d5ad-186">As duas declarações de namespace acima contribuem para o mesmo espaço de declaração, neste caso, declarando duas classes com os nomes totalmente qualificados `Megacorp.Data.Customer` e `Megacorp.Data.Order`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="4d5ad-187">Como as duas declarações contribuem para o mesmo espaço de declaração, ela causaria um erro de tempo de compilação se cada uma continha uma declaração de uma classe com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="4d5ad-188">Conforme especificado acima, o espaço de declaração de um bloco inclui todos os blocos aninhados.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="4d5ad-189">Portanto, no exemplo a seguir, os métodos `F` e `G` resultam em um erro de tempo de compilação porque o nome `i` é declarado no bloco externo e não pode ser declarado novamente no bloco interno.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="4d5ad-190">No entanto, os métodos `H` e `I` são válidos, pois os dois `i` são declarados em blocos não aninhados separados.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="4d5ad-191">Membros</span><span class="sxs-lookup"><span data-stu-id="4d5ad-191">Members</span></span>

<span data-ttu-id="4d5ad-192">Namespaces e tipos têm ***Membros***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="4d5ad-193">Os membros de uma entidade estão geralmente disponíveis por meio do uso de um nome qualificado que começa com uma referência à entidade, seguida por um token "`.`", seguido pelo nome do membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="4d5ad-194">Os membros de um tipo são declarados na declaração de tipo ou ***herdados*** da classe base do tipo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="4d5ad-195">Quando um tipo é herdado de uma classe base, todos os membros da classe base, exceto construtores de instância, destruidores e construtores estáticos, se tornam membros do tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="4d5ad-196">A acessibilidade declarada de um membro de classe base não controla se o membro é herdado — a herança se estende a qualquer membro que não seja um construtor de instância, construtor estático ou destruidor.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="4d5ad-197">No entanto, um membro herdado pode não estar acessível em um tipo derivado, devido à sua acessibilidade declarada ([acessibilidade declarada](basic-concepts.md#declared-accessibility)) ou porque está ocultada por uma declaração no próprio tipo ([ocultando por herança](basic-concepts.md#hiding-through-inheritance)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="4d5ad-198">Membros do namespace</span><span class="sxs-lookup"><span data-stu-id="4d5ad-198">Namespace members</span></span>

<span data-ttu-id="4d5ad-199">Namespaces e tipos que não têm namespace delimitador são membros do ***namespace global***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="4d5ad-200">Isso corresponde diretamente aos nomes declarados no espaço de declaração global.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="4d5ad-201">Namespaces e tipos declarados em um namespace são membros desse namespace.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="4d5ad-202">Isso corresponde diretamente aos nomes declarados no espaço de declaração do namespace.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="4d5ad-203">Namespaces não têm nenhuma restrição de acesso.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="4d5ad-204">Não é possível declarar namespaces privados, protegidos ou internos, e os nomes de namespace são sempre acessíveis publicamente.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="4d5ad-205">Membros de struct</span><span class="sxs-lookup"><span data-stu-id="4d5ad-205">Struct members</span></span>

<span data-ttu-id="4d5ad-206">Os membros de uma struct são os membros declarados na struct e os membros herdados da classe base direta da struct `System.ValueType` e a classe base indireta `object`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="4d5ad-207">Os membros de um tipo simples correspondem diretamente aos membros do tipo struct com o alias do tipo simples:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="4d5ad-208">Os membros de `sbyte` são os membros da struct `System.SByte`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="4d5ad-209">Os membros de `byte` são os membros da struct `System.Byte`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="4d5ad-210">Os membros de `short` são os membros da struct `System.Int16`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="4d5ad-211">Os membros de `ushort` são os membros da struct `System.UInt16`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="4d5ad-212">Os membros de `int` são os membros da struct `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="4d5ad-213">Os membros de `uint` são os membros da struct `System.UInt32`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="4d5ad-214">Os membros de `long` são os membros da struct `System.Int64`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="4d5ad-215">Os membros de `ulong` são os membros da struct `System.UInt64`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="4d5ad-216">Os membros de `char` são os membros da struct `System.Char`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="4d5ad-217">Os membros de `float` são os membros da struct `System.Single`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="4d5ad-218">Os membros de `double` são os membros da struct `System.Double`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="4d5ad-219">Os membros de `decimal` são os membros da struct `System.Decimal`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="4d5ad-220">Os membros de `bool` são os membros da struct `System.Boolean`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="4d5ad-221">Membros de enumeração</span><span class="sxs-lookup"><span data-stu-id="4d5ad-221">Enumeration members</span></span>

<span data-ttu-id="4d5ad-222">Os membros de uma enumeração são as constantes declaradas na enumeração e os membros herdados da classe base direta da enumeração `System.Enum` e as classes base indiretas `System.ValueType` e `object`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="4d5ad-223">Membros de classe</span><span class="sxs-lookup"><span data-stu-id="4d5ad-223">Class members</span></span>

<span data-ttu-id="4d5ad-224">Os membros de uma classe são os membros declarados na classe e os membros herdados da classe base (exceto para a classe `object` que não tem nenhuma classe base).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="4d5ad-225">Os membros herdados da classe base incluem as constantes, os campos, os métodos, as propriedades, os eventos, os indexadores, os operadores e os tipos da classe base, mas não os construtores de instância, destruidores e construtores estáticos da classe base.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="4d5ad-226">Os membros da classe base são herdados sem considerar sua acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="4d5ad-227">Uma declaração de classe pode conter declarações de constantes, campos, métodos, propriedades, eventos, indexadores, operadores, construtores de instância, destruidores, construtores e tipos estáticos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="4d5ad-228">Os membros de `object` e `string` correspondem diretamente aos membros dos tipos de classe aos quais eles se alias:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="4d5ad-229">Os membros de `object` são os membros da classe `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="4d5ad-230">Os membros de `string` são os membros da classe `System.String`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="4d5ad-231">Membros da interface</span><span class="sxs-lookup"><span data-stu-id="4d5ad-231">Interface members</span></span>

<span data-ttu-id="4d5ad-232">Os membros de uma interface são os membros declarados na interface e em todas as interfaces base da interface.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="4d5ad-233">Os membros na classe `object` não são, estritamente falando, membros de qualquer interface ([membros da interface](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="4d5ad-234">No entanto, os membros na classe `object` estão disponíveis por meio de pesquisa de membro em qualquer tipo de interface ([pesquisa de membros](expressions.md#member-lookup)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="4d5ad-235">Membros da matriz</span><span class="sxs-lookup"><span data-stu-id="4d5ad-235">Array members</span></span>

<span data-ttu-id="4d5ad-236">Os membros de uma matriz são os membros herdados da classe `System.Array`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="4d5ad-237">Delegar Membros</span><span class="sxs-lookup"><span data-stu-id="4d5ad-237">Delegate members</span></span>

<span data-ttu-id="4d5ad-238">Os membros de um delegado são os membros herdados da classe `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="4d5ad-239">Acesso de membros</span><span class="sxs-lookup"><span data-stu-id="4d5ad-239">Member access</span></span>

<span data-ttu-id="4d5ad-240">Declarações de Membros permitem o controle sobre o acesso de membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="4d5ad-241">A acessibilidade de um membro é estabelecida pela acessibilidade declarada ([acessibilidade declarada](basic-concepts.md#declared-accessibility)) do membro combinado com a acessibilidade do tipo que o contém imediatamente, se houver.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="4d5ad-242">Quando o acesso a um membro específico é permitido, o membro é dito como ***acessível***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="4d5ad-243">Por outro lado, quando o acesso a um determinado membro não é permitido, o membro é dito como ***inacessível***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="4d5ad-244">O acesso a um membro é permitido quando o local textual no qual o acesso ocorre está incluído no domínio de acessibilidade ([domínios de acessibilidade](basic-concepts.md#accessibility-domains)) do membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="4d5ad-245">Acessibilidade declarada</span><span class="sxs-lookup"><span data-stu-id="4d5ad-245">Declared accessibility</span></span>

<span data-ttu-id="4d5ad-246">A ***acessibilidade declarada*** de um membro pode ser uma das seguintes:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="4d5ad-247">Public, que é selecionado incluindo um modificador `public` na declaração de membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="4d5ad-248">O significado intuitivo de `public` é "acesso não limitado".</span><span class="sxs-lookup"><span data-stu-id="4d5ad-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="4d5ad-249">Protegido, que é selecionado incluindo um modificador `protected` na declaração de membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="4d5ad-250">O significado intuitivo de `protected` é "acesso limitado à classe que a contém ou tipos derivados da classe que a contém".</span><span class="sxs-lookup"><span data-stu-id="4d5ad-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="4d5ad-251">Interno, que é selecionado incluindo um modificador `internal` na declaração de membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="4d5ad-252">O significado intuitivo de `internal` é "acesso limitado a este programa".</span><span class="sxs-lookup"><span data-stu-id="4d5ad-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="4d5ad-253">Protegido interno (ou seja, protegido ou interno), que é selecionado incluindo um `protected` e um modificador `internal` na declaração de membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="4d5ad-254">O significado intuitivo de `protected internal` é "acesso limitado a este programa ou tipos derivados da classe que a contém".</span><span class="sxs-lookup"><span data-stu-id="4d5ad-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="4d5ad-255">Privado, que é selecionado incluindo um modificador `private` na declaração de membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="4d5ad-256">O significado intuitivo de `private` é "acesso limitado ao tipo recipiente".</span><span class="sxs-lookup"><span data-stu-id="4d5ad-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="4d5ad-257">Dependendo do contexto no qual uma declaração de membro ocorre, somente determinados tipos de acessibilidade declarada são permitidos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="4d5ad-258">Além disso, quando uma declaração de membro não inclui nenhum modificador de acesso, o contexto no qual a declaração ocorre determina a acessibilidade declarada padrão.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="4d5ad-259">Os namespaces implicitamente têm `public` declaração de acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4d5ad-260">Nenhum modificador de acesso é permitido em declarações de namespace.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="4d5ad-261">Tipos declarados em unidades de compilação ou namespaces podem ter `public` ou `internal` declarado como acessibilidade e o padrão para `internal` a acessibilidade declarada.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="4d5ad-262">Os membros de classe podem ter qualquer um dos cinco tipos de acessibilidade declarada e o padrão para `private` declarou a acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="4d5ad-263">(Observe que um tipo declarado como membro de uma classe pode ter qualquer um dos cinco tipos de acessibilidade declarada, enquanto um tipo declarado como membro de um namespace pode ter apenas `public` ou `internal`, a acessibilidade foi declarada.)</span><span class="sxs-lookup"><span data-stu-id="4d5ad-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="4d5ad-264">Os membros de struct podem ter a acessibilidade `public`, `internal` ou `private` declarada e padrão para `private` a acessibilidade declarada porque as estruturas são seladas implicitamente.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="4d5ad-265">Membros de struct introduzidos em uma struct (ou seja, não herdados por essa struct) não podem ter `protected` ou `protected internal` declarou acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="4d5ad-266">(Observe que um tipo declarado como membro de um struct pode ter `public`, `internal` ou `private` declarados como acessibilidade, enquanto um tipo declarado como membro de um namespace pode ter apenas `public` ou `internal` com acessibilidade declarada.)</span><span class="sxs-lookup"><span data-stu-id="4d5ad-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="4d5ad-267">Os membros da interface têm implicitamente `public` com acessibilidade declarada.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4d5ad-268">Nenhum modificador de acesso é permitido em declarações de membro de interface.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="4d5ad-269">Os membros de enumeração têm implicitamente `public` declarou acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4d5ad-270">Nenhum modificador de acesso é permitido em declarações de membro de enumeração.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="4d5ad-271">Domínios de acessibilidade</span><span class="sxs-lookup"><span data-stu-id="4d5ad-271">Accessibility domains</span></span>

<span data-ttu-id="4d5ad-272">O ***domínio de acessibilidade*** de um membro consiste nas seções (possivelmente disjunção) do texto do programa no qual o acesso ao membro é permitido.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="4d5ad-273">Para fins de definição do domínio de acessibilidade de um membro, um membro será considerado de ***nível superior*** se ele não for declarado dentro de um tipo, e um membro será considerado ***aninhado*** se for declarado dentro de outro tipo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="4d5ad-274">Além disso, o ***texto do programa*** de um programa é definido como todo o texto do programa contido em todos os arquivos de origem do programa, e o texto do programa de um tipo é definido como todo o texto do programa contido no *type_declaration*s desse tipo (incluindo, possivelmente, tipos que são aninhados dentro do tipo).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="4d5ad-275">O domínio de acessibilidade de um tipo predefinido (como `object`, `int` ou `double`) é ilimitado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="4d5ad-276">O domínio de acessibilidade de um tipo não associado de nível superior `T` ([tipos vinculados e desvinculados](types.md#bound-and-unbound-types)) que é declarado em um programa `P` é definido da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="4d5ad-277">Se a acessibilidade declarada de `T` for `public`, o domínio de acessibilidade de `T` será o texto do programa de `P` e qualquer programa que faça referência a `P`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="4d5ad-278">Se a acessibilidade declarada de `T` for `internal`, o domínio de acessibilidade de `T` será o texto de programa de `P`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="4d5ad-279">A partir dessas definições, a seguir, o domínio de acessibilidade de um tipo não associado de nível superior é sempre pelo menos o texto do programa do programa no qual esse tipo é declarado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="4d5ad-280">O domínio de acessibilidade para um tipo construído `T<A1, ..., An>` é a interseção do domínio de acessibilidade do tipo genérico não associado `T` e os domínios de acessibilidade dos argumentos de tipo `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="4d5ad-281">O domínio de acessibilidade de um membro aninhado `M` declarado em um tipo `T` em um programa `P` é definido da seguinte maneira (observar que `M` em si pode ser um tipo):</span><span class="sxs-lookup"><span data-stu-id="4d5ad-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="4d5ad-282">Se a acessibilidade declarada de `M` for `public`, o domínio de acessibilidade de `M` será o domínio de acessibilidade de `T`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="4d5ad-283">Se a acessibilidade declarada de `M` for `protected internal`, permita que `D` seja a União do texto do programa de `P` e o texto do programa de qualquer tipo derivado de `T`, que é declarado fora de `P`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="4d5ad-284">O domínio de acessibilidade de `M` é a interseção do domínio de acessibilidade de `T` com `D`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="4d5ad-285">Se a acessibilidade declarada de `M` for `protected`, permita que `D` seja a União do texto do programa de `T` e o texto do programa de qualquer tipo derivado de `T`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="4d5ad-286">O domínio de acessibilidade de `M` é a interseção do domínio de acessibilidade de `T` com `D`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="4d5ad-287">Se a acessibilidade declarada de `M` for `internal`, o domínio de acessibilidade de `M` será a interseção do domínio de acessibilidade de `T` com o texto de programa de `P`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="4d5ad-288">Se a acessibilidade declarada de `M` for `private`, o domínio de acessibilidade de `M` será o texto de programa de `T`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="4d5ad-289">A partir dessas definições, a seguir, o domínio de acessibilidade de um membro aninhado é sempre pelo menos o texto do programa do tipo no qual o membro é declarado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="4d5ad-290">Além disso, ele segue que o domínio de acessibilidade de um membro nunca é mais inclusivo do que o domínio de acessibilidade do tipo no qual o membro é declarado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="4d5ad-291">Em termos intuitivos, quando um tipo ou membro `M` é acessado, as etapas a seguir são avaliadas para garantir que o acesso seja permitido:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="4d5ad-292">Primeiro, se `M` for declarado dentro de um tipo (em oposição a uma unidade de compilação ou um namespace), ocorrerá um erro em tempo de compilação se esse tipo não estiver acessível.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="4d5ad-293">Em seguida, se `M` for `public`, o acesso será permitido.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="4d5ad-294">Caso contrário, se `M` for `protected internal`, o acesso será permitido se ocorrer dentro do programa no qual `M` é declarado ou se ocorrer dentro de uma classe derivada da classe na qual o `M` é declarado e ocorre por meio do tipo de classe derivada ([protegido acesso para membros da instância](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="4d5ad-295">Caso contrário, se `M` for `protected`, o acesso será permitido se ocorrer dentro da classe na qual `M` é declarado, ou se ocorrer dentro de uma classe derivada da classe na qual `M` é declarado e ocorre por meio do tipo de classe derivada ([protegido acesso para membros da instância](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="4d5ad-296">Caso contrário, se `M` for `internal`, o acesso será permitido se ocorrer dentro do programa no qual `M` é declarado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="4d5ad-297">Caso contrário, se `M` for `private`, o acesso será permitido se ocorrer dentro do tipo no qual `M` é declarado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="4d5ad-298">Caso contrário, o tipo ou o membro será inacessível e ocorrerá um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="4d5ad-299">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="4d5ad-300">as classes e os membros têm os seguintes domínios de acessibilidade:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="4d5ad-301">O domínio de acessibilidade de `A` e `A.X` é ilimitado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="4d5ad-302">O domínio de acessibilidade de `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X` e `B.C.Y` é o texto do programa que contém o programa.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="4d5ad-303">O domínio de acessibilidade de `A.Z` é o texto do programa do `A`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="4d5ad-304">O domínio de acessibilidade de `B.Z` e `B.D` é o texto do programa de `B`, incluindo o texto do programa de `B.C` e `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="4d5ad-305">O domínio de acessibilidade de `B.C.Z` é o texto do programa do `B.C`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="4d5ad-306">O domínio de acessibilidade de `B.D.X` e `B.D.Y` é o texto do programa de `B`, incluindo o texto do programa de `B.C` e `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="4d5ad-307">O domínio de acessibilidade de `B.D.Z` é o texto do programa do `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="4d5ad-308">Como ilustra o exemplo, o domínio de acessibilidade de um membro nunca é maior que o de um tipo recipiente.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="4d5ad-309">Por exemplo, embora todos os membros `X` tenham acessibilidade declarada pública, tudo, mas `A.X`, têm domínios de acessibilidade restritos por um tipo recipiente.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="4d5ad-310">Conforme descrito em [Membros](basic-concepts.md#members), todos os membros de uma classe base, exceto para construtores de instância, destruidores e construtores estáticos, são herdados por tipos derivados.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="4d5ad-311">Isso inclui até membros privados de uma classe base.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-311">This includes even private members of a base class.</span></span> <span data-ttu-id="4d5ad-312">No entanto, o domínio de acessibilidade de um membro privado inclui apenas o texto do programa do tipo no qual o membro é declarado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="4d5ad-313">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="4d5ad-314">a classe `B` herda o membro privado `x` da classe `A`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="4d5ad-315">Como o membro é privado, ele só é acessível dentro do *class_body* de `A`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="4d5ad-316">Assim, o acesso a `b.x` é bem-sucedida no método `A.F`, mas falha no método `B.F`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="4d5ad-317">Acesso protegido para membros de instância</span><span class="sxs-lookup"><span data-stu-id="4d5ad-317">Protected access for instance members</span></span>

<span data-ttu-id="4d5ad-318">Quando um membro da instância `protected` é acessado fora do texto do programa da classe na qual ele é declarado e quando um membro da instância `protected internal` é acessado fora do texto do programa no qual ele é declarado, o acesso deve ocorrer dentro de uma classe declaração que deriva da classe na qual ela é declarada.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="4d5ad-319">Além disso, o acesso é necessário para ocorrer por meio de uma instância desse tipo de classe derivada ou um tipo de classe construído a partir dele.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="4d5ad-320">Essa restrição impede que uma classe derivada acesse membros protegidos de outras classes derivadas, mesmo quando os membros são herdados da mesma classe base.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="4d5ad-321">Permita que `B` seja uma classe base que declare um membro de instância protegida `M` e permita que `D` seja uma classe derivada de `B`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="4d5ad-322">Dentro do *class_body* de `D`, o acesso a `M` pode ter uma das seguintes formas:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="4d5ad-323">Um *type_name* ou *primary_expression* não qualificado do formulário `M`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="4d5ad-324">Um *primary_expression* do formulário `E.M`, desde que o tipo de `E` seja `T` ou uma classe derivada de `T`, em que `T` é o tipo de classe `D` ou um tipo de classe construído a partir de `D`</span><span class="sxs-lookup"><span data-stu-id="4d5ad-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="4d5ad-325">Um *primary_expression* do formulário `base.M`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="4d5ad-326">Além dessas formas de acesso, uma classe derivada pode acessar um construtor de instância protegida de uma classe base em um *constructor_initializer* ([inicializadores de Construtor](classes.md#constructor-initializers)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="4d5ad-327">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="4d5ad-328">dentro de `A`, é possível acessar `x` por meio de instâncias de `A` e `B`, já que, em ambos os casos, o acesso ocorre por meio de uma instância de `A` ou uma classe derivada de `A`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="4d5ad-329">No entanto, dentro de `B`, não é possível acessar `x` por meio de uma instância de `A`, já que `A` não deriva de `B`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="4d5ad-330">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="4d5ad-331">as três atribuições para `x` são permitidas porque todas elas ocorrem por meio de instâncias de tipos de classe construídos a partir do tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="4d5ad-332">Restrições de acessibilidade</span><span class="sxs-lookup"><span data-stu-id="4d5ad-332">Accessibility constraints</span></span>

<span data-ttu-id="4d5ad-333">Várias construções no C# idioma exigem que um tipo seja ***pelo menos como acessível como*** um membro ou outro tipo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="4d5ad-334">Um tipo `T` é considerado pelo menos como acessível como um membro ou tipo `M` se o domínio de acessibilidade de `T` for um superconjunto do domínio de acessibilidade de `M`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="4d5ad-335">Em outras palavras, `T` é pelo menos como acessível como `M` se `T` estiver acessível em todos os contextos nos quais `M` está acessível.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="4d5ad-336">Existem as seguintes restrições de acessibilidade:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="4d5ad-337">A classe base direta de um tipo de classe deve ser, pelo menos, tão acessível quanto o próprio tipo de classe.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="4d5ad-338">As interfaces base explícitas de um tipo de interface devem ser, pelo menos, tão acessíveis quanto o próprio tipo de interface.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="4d5ad-339">O tipo de retorno e os tipos de parâmetro de um tipo delegado devem ser, pelo menos, tão acessíveis quanto o próprio tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="4d5ad-340">O tipo de uma constante deve ser, pelo menos, tão acessível quanto a própria constante.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="4d5ad-341">O tipo de um campo deve ser, pelo menos, tão acessível quanto o próprio campo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="4d5ad-342">O tipo de retorno e os tipos de parâmetro de um método devem ser, pelo menos, tão acessíveis quanto o próprio método.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="4d5ad-343">O tipo de uma propriedade deve ser, pelo menos, tão acessível quanto a propriedade em si.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="4d5ad-344">O tipo de um evento deve ser, pelo menos, tão acessível quanto o próprio evento.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="4d5ad-345">O tipo e os tipos de parâmetro de um indexador devem ser, pelo menos, tão acessíveis quanto o próprio indexador.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="4d5ad-346">O tipo de retorno e os tipos de parâmetro de um operador devem ser, pelo menos, tão acessíveis quanto o próprio operador.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="4d5ad-347">Os tipos de parâmetro de um construtor de instância devem ser pelo menos tão acessíveis quanto o próprio construtor de instância.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="4d5ad-348">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="4d5ad-349">a classe `B` resulta em um erro de tempo de compilação porque `A` não é pelo menos tão acessível quanto `B`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="4d5ad-350">Da mesma forma, no exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="4d5ad-351">o método `H` no `B` resulta em um erro de tempo de compilação porque o tipo de retorno `A` não é pelo menos tão acessível quanto o método.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="4d5ad-352">Assinaturas e sobrecargas</span><span class="sxs-lookup"><span data-stu-id="4d5ad-352">Signatures and overloading</span></span>

<span data-ttu-id="4d5ad-353">Os métodos, construtores de instância, indexadores e operadores são caracterizados por suas ***assinaturas***:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="4d5ad-354">A assinatura de um método consiste no nome do método, no número de parâmetros de tipo e no tipo e tipo (valor, referência ou saída) de cada um de seus parâmetros formais, considerados na ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4d5ad-355">Para essas finalidades, qualquer parâmetro de tipo do método que ocorre no tipo de um parâmetro formal é identificado não por seu nome, mas por sua posição ordinal na lista de argumentos de tipo do método.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="4d5ad-356">A assinatura de um método especificamente não inclui o tipo de retorno, o modificador `params` que pode ser especificado para o parâmetro mais à direita, nem as restrições de parâmetro de tipo opcionais.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="4d5ad-357">A assinatura de um construtor de instância consiste no tipo e tipo (valor, referência ou saída) de cada um de seus parâmetros formais, considerados na ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4d5ad-358">A assinatura de um construtor de instância especificamente não inclui o modificador `params` que pode ser especificado para o parâmetro mais à direita.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="4d5ad-359">A assinatura de um indexador consiste no tipo de cada um de seus parâmetros formais, considerados na ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4d5ad-360">A assinatura de um indexador especificamente não inclui o tipo de elemento, nem inclui o modificador `params` que pode ser especificado para o parâmetro mais à direita.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="4d5ad-361">A assinatura de um operador consiste no nome do operador e no tipo de cada um de seus parâmetros formais, considerados na ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4d5ad-362">A assinatura de um operador especificamente não inclui o tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="4d5ad-363">As assinaturas são o mecanismo de habilitação para ***sobrecarga*** de membros em classes, estruturas e interfaces:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="4d5ad-364">A sobrecarga de métodos permite que uma classe, estrutura ou interface declare vários métodos com o mesmo nome, desde que suas assinaturas sejam exclusivas nessa classe, struct ou interface.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="4d5ad-365">A sobrecarga de construtores de instância permite que uma classe ou estrutura declare vários construtores de instância, desde que suas assinaturas sejam exclusivas dentro dessa classe ou estrutura.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="4d5ad-366">A sobrecarga de indexadores permite que uma classe, estrutura ou interface declare vários indexadores, desde que suas assinaturas sejam exclusivas nessa classe, struct ou interface.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="4d5ad-367">A sobrecarga de operadores permite que uma classe ou estrutura declare vários operadores com o mesmo nome, desde que suas assinaturas sejam exclusivas dentro dessa classe ou estrutura.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="4d5ad-368">Embora os modificadores de parâmetro `out` e `ref` sejam considerados parte de uma assinatura, os membros declarados em um único tipo não podem diferir na assinatura exclusivamente por `ref` e `out`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="4d5ad-369">Ocorrerá um erro de tempo de compilação se dois membros forem declarados no mesmo tipo com assinaturas que seriam as mesmas se todos os parâmetros em ambos os métodos com modificadores `out` foram alterados para os modificadores `ref`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="4d5ad-370">Para outras finalidades de correspondência de assinatura (por exemplo, ocultar ou substituir), `ref` e `out` são considerados parte da assinatura e não coincidem.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="4d5ad-371">(Essa restrição é permitir que C# os programas sejam facilmente convertidos para serem executados no Common Language Infrastructure (CLI), que não fornece uma maneira de definir métodos que diferem somente em `ref` e `out`.)</span><span class="sxs-lookup"><span data-stu-id="4d5ad-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="4d5ad-372">Para fins de assinatura, os tipos `object` e `dynamic` são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="4d5ad-373">Os membros declarados em um único tipo podem, portanto, não ser diferentes na assinatura exclusivamente por `object` e `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="4d5ad-374">O exemplo a seguir mostra um conjunto de declarações de método sobrecarregadas junto com suas assinaturas.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="4d5ad-375">Observe que quaisquer modificadores de parâmetro `ref` e `out` ([parâmetros de método](classes.md#method-parameters)) fazem parte de uma assinatura.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="4d5ad-376">Assim, `F(int)` e `F(ref int)` são assinaturas exclusivas.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="4d5ad-377">No entanto, `F(ref int)` e `F(out int)` não podem ser declarados na mesma interface porque suas assinaturas diferem exclusivamente por `ref` e `out`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="4d5ad-378">Além disso, observe que o tipo de retorno e o modificador `params` não fazem parte de uma assinatura, portanto não é possível sobrecarregar unicamente com base no tipo de retorno ou na inclusão ou exclusão do modificador `params`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="4d5ad-379">Como tal, as declarações dos métodos `F(int)` e `F(params string[])` identificados acima resultam em um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="4d5ad-380">Escopos</span><span class="sxs-lookup"><span data-stu-id="4d5ad-380">Scopes</span></span>

<span data-ttu-id="4d5ad-381">O ***escopo*** de um nome é a região do texto do programa no qual é possível fazer referência à entidade declarada pelo nome sem qualificação do nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="4d5ad-382">Os escopos podem ser ***aninhados***, e um escopo interno pode redeclarar o significado de um nome a partir de um escopo externo (isso não, no entanto, remover a restrição imposta por [declarações](basic-concepts.md#declarations) que dentro de um bloco aninhado não é possível declarar uma variável local com o mesmo nome que uma variável local em um bloco delimitador).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="4d5ad-383">O nome do escopo externo, em seguida, é dito como ***oculto*** na região do texto do programa coberto pelo escopo interno, e o acesso ao nome externo só é possível qualificando o nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="4d5ad-384">O escopo de um membro de namespace declarado por um *namespace_member_declaration* ([membros de namespace](namespaces.md#namespace-members)) sem delimitador *namespace_declaration* é o texto completo do programa.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="4d5ad-385">O escopo de um membro de namespace declarado por um *namespace_member_declaration* em um *namespace_declaration* cujo nome totalmente qualificado é `N` é o *namespace_body* de cada *namespace_declaration* , cujo total o nome qualificado é `N` ou começa com `N`, seguido de um ponto.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="4d5ad-386">O escopo do nome definido por um *extern_alias_directive* estende-se pelos *using_directive*s, *global_attributes* e *namespace_member_declaration*s de seu logo contendo a unidade de compilação ou o corpo do namespace.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="4d5ad-387">Um *extern_alias_directive* não contribui com nenhum novo membro para o espaço de declaração subjacente.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="4d5ad-388">Em outras palavras, um *extern_alias_directive* não é transitiva, mas, em vez disso, afeta apenas a unidade de compilação ou o corpo do namespace no qual ele ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="4d5ad-389">O escopo de um nome definido ou importado por um *using_directive* ([usando as diretivas](namespaces.md#using-directives)) estende-se pelos *namespace_member_declaration*s do *compilation_unit* ou *namespace_body* no qual o *using_directive* ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="4d5ad-390">Um *using_directive* pode tornar zero ou mais nomes de namespace, tipo ou membro disponíveis em um *compilation_unit* ou *namespace_body*específico, mas não contribui com novos membros para o espaço de declaração subjacente.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="4d5ad-391">Em outras palavras, um *using_directive* não é transitiva, mas afeta apenas o *compilation_unit* ou *namespace_body* em que ele ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="4d5ad-392">O escopo de um parâmetro de tipo declarado por um *type_parameter_list* em um *class_declaration* ([declarações de classe](classes.md#class-declarations)) é o *class_base*, *type_parameter_constraints_clause*s e *class_body* de que  *class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="4d5ad-393">O escopo de um parâmetro de tipo declarado por um *type_parameter_list* em *um struct_declaration* ([declarações struct](structs.md#struct-declarations)) é *struct_interfaces*, *type_parameter_constraints_clause*s e *struct_body* de Esse *struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="4d5ad-394">O escopo de um parâmetro de tipo declarado por um *type_parameter_list* em um *interface_declaration* ([declarações de interface](interfaces.md#interface-declarations)) é *interface_base*, *type_parameter_constraints_clause*s e *interface_body* desse *interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="4d5ad-395">O escopo de um parâmetro de tipo declarado por um *type_parameter_list* em um *delegate_declaration* ([declarações de representante](delegates.md#delegate-declarations)) é *return_type*, *formal_parameter_list*e *type_parameter_constraints_clause* s desse *delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="4d5ad-396">O escopo de um membro declarado por um *class_member_declaration* ([corpo de classe](classes.md#class-body)) é o *class_body* no qual a declaração ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="4d5ad-397">Além disso, o escopo de um membro de classe se estende para o *class_body* dessas classes derivadas que são incluídas no domínio de acessibilidade ([domínios de acessibilidade](basic-concepts.md#accessibility-domains)) do membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="4d5ad-398">O escopo de um membro declarado por um *struct_member_declaration* ([membros de struct](structs.md#struct-members)) é o *struct_body* no qual a declaração ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4d5ad-399">O escopo de um membro declarado por um *enum_member_declaration* ([membros de enum](enums.md#enum-members)) é o *enum_body* no qual a declaração ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4d5ad-400">O escopo de um parâmetro declarado em um *method_declaration* ([métodos](classes.md#methods)) é o *method_body* desse *method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="4d5ad-401">O escopo de um parâmetro declarado em um *indexer_declaration* ([indexadores](classes.md#indexers)) é o *accessor_declarations* desse *indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="4d5ad-402">O escopo de um parâmetro declarado em um *operator_declaration* ([Operators](classes.md#operators)) é o *bloco* desse *operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="4d5ad-403">O escopo de um parâmetro declarado em um *constructor_declaration* ([construtores de instância](classes.md#instance-constructors)) é o *constructor_initializer* e o *bloco* desse *constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="4d5ad-404">O escopo de um parâmetro declarado em um *lambda_expression* ([expressões de função anônimas](expressions.md#anonymous-function-expressions)) é o *anonymous_function_body* desse *lambda_expression*</span><span class="sxs-lookup"><span data-stu-id="4d5ad-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="4d5ad-405">O escopo de um parâmetro declarado em um *anonymous_method_expression* ([expressões de função anônimas](expressions.md#anonymous-function-expressions)) é o *bloco* desse *anonymous_method_expression*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="4d5ad-406">O escopo de um rótulo declarado em um *labeled_statement* ([instruções rotuladas](statements.md#labeled-statements)) é o *bloco* no qual a declaração ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4d5ad-407">O escopo de uma variável local declarada em um *local_variable_declaration* ([declarações de variável local](statements.md#local-variable-declarations)) é o bloco no qual a declaração ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="4d5ad-408">O escopo de uma variável local declarada em um *switch_block* de uma instrução `switch` ([a instrução switch](statements.md#the-switch-statement)) é o *switch_block*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="4d5ad-409">O escopo de uma variável local declarada em um *for_initializer* de uma instrução `for` ([a instrução for](statements.md#the-for-statement)) *é for_initializer*, *for_condition*, *for_iterator*e a *instrução* contida do instrução `for`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="4d5ad-410">O escopo de uma constante local declarada em uma *local_constant_declaration* ([declarações de constantes locais](statements.md#local-constant-declarations)) é o bloco no qual a declaração ocorre.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="4d5ad-411">É um erro de tempo de compilação para se referir a uma constante local em uma posição textual que precede seu *constant_declarator*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="4d5ad-412">O escopo de uma variável declarada como parte de um *foreach_statement*, *using_statement*, *lock_statement* ou *query_expression* é determinado pela expansão da construção fornecida.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="4d5ad-413">Dentro do escopo de um namespace, classe, struct ou membro de enumeração, é possível fazer referência ao membro em uma posição textual que precede a declaração do membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="4d5ad-414">Por exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="4d5ad-415">Aqui, é válido para `F` fazer referência a `i` antes de ser declarado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="4d5ad-416">Dentro do escopo de uma variável local, é um erro de tempo de compilação para se referir à variável local em uma posição textual que precede o *local_variable_declarator* da variável local.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="4d5ad-417">Por exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="4d5ad-418">No método `F` acima, a primeira atribuição para `i` especificamente não se refere ao campo declarado no escopo externo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="4d5ad-419">Em vez disso, ele se refere à variável local e resulta em um erro de tempo de compilação porque ele precede textualmente a declaração da variável.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="4d5ad-420">No método `G`, o uso de `j` no inicializador para a declaração de `j` é válido porque o uso não precede o *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="4d5ad-421">No método `H`, um *local_variable_declarator* subsequente se refere corretamente a uma variável local declarada em um *local_variable_declarator* anterior no mesmo *local_variable_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="4d5ad-422">As regras de escopo para variáveis locais são projetadas para garantir que o significado de um nome usado em um contexto de expressão seja sempre o mesmo dentro de um bloco.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="4d5ad-423">Se o escopo de uma variável local fosse estender apenas de sua declaração para o final do bloco, no exemplo acima, a primeira atribuição seria atribuída à variável de instância e a segunda atribuição seria atribuída à variável local, possivelmente levando a erros de tempo de compilação se as instruções do bloco foram posteriormente reorganizadas.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="4d5ad-424">O significado de um nome dentro de um bloco pode ser diferente com base no contexto no qual o nome é usado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="4d5ad-425">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="4d5ad-426">o nome `A` é usado em um contexto de expressão para se referir à variável local `A` e em um contexto de tipo para se referir à classe `A`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="4d5ad-427">Ocultação de nomes</span><span class="sxs-lookup"><span data-stu-id="4d5ad-427">Name hiding</span></span>

<span data-ttu-id="4d5ad-428">O escopo de uma entidade normalmente abrange mais texto de programa do que o espaço de declaração da entidade.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="4d5ad-429">Em particular, o escopo de uma entidade pode incluir declarações que apresentam novos espaços de declaração contendo entidades de mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="4d5ad-430">Tais declarações fazem com que a entidade original se torne ***oculta***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="4d5ad-431">Por outro lado, uma entidade é considerada ***visível*** quando não está oculta.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="4d5ad-432">A ocultação de nome ocorre quando os escopos se sobrepõem no aninhamento e quando os escopos se sobrepõem pela herança</span><span class="sxs-lookup"><span data-stu-id="4d5ad-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="4d5ad-433">As características dos dois tipos de ocultação são descritas nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="4d5ad-434">Ocultando por meio de aninhamento</span><span class="sxs-lookup"><span data-stu-id="4d5ad-434">Hiding through nesting</span></span>

<span data-ttu-id="4d5ad-435">O nome que oculta o aninhamento pode ocorrer como resultado de aninhar namespaces ou tipos dentro de namespaces, como resultado de aninhar tipos dentro de classes ou estruturas, e como resultado de declarações de parâmetro e variável local.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="4d5ad-436">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="4d5ad-437">dentro do método `F`, a variável de instância `i` é ocultada pela variável local `i`, mas dentro do método `G`, `i` ainda se refere à variável de instância.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="4d5ad-438">Quando um nome em um escopo interno oculta um nome em um escopo externo, ele oculta todas as ocorrências sobrecarregadas desse nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="4d5ad-439">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="4d5ad-440">a chamada `F(1)` invoca o `F` declarado em `Inner` porque todas as ocorrências externas de `F` são ocultadas pela declaração interna.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="4d5ad-441">Pelo mesmo motivo, a chamada `F("Hello")` resulta em um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="4d5ad-442">Ocultando por meio de herança</span><span class="sxs-lookup"><span data-stu-id="4d5ad-442">Hiding through inheritance</span></span>

<span data-ttu-id="4d5ad-443">O nome que se oculta pela herança ocorre quando as classes ou estruturas redeclaram nomes que foram herdados de classes base.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="4d5ad-444">Esse tipo de ocultação de nome usa uma das seguintes formas:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="4d5ad-445">Uma constante, campo, propriedade, evento ou tipo introduzido em uma classe ou struct oculta todos os membros da classe base com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="4d5ad-446">Um método introduzido em uma classe ou struct oculta todos os membros da classe base que não são de método com o mesmo nome e todos os métodos da classe base com a mesma assinatura (nome do método e contagem de parâmetros, modificadores e tipos).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="4d5ad-447">Um indexador introduzido em uma classe ou estrutura oculta todos os indexadores de classe base com a mesma assinatura (contagem de parâmetros e tipos).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="4d5ad-448">As regras que regem as declarações de operador ([operadores](classes.md#operators)) tornam impossível para uma classe derivada declarar um operador com a mesma assinatura de um operador em uma classe base.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="4d5ad-449">Portanto, os operadores nunca ocultam um ao outro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="4d5ad-450">Ao contrário de ocultar um nome de um escopo externo, ocultar um nome acessível de um escopo herdado faz com que um aviso seja relatado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="4d5ad-451">No exemplo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="4d5ad-452">a declaração de `F` em `Derived` faz com que um aviso seja relatado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="4d5ad-453">Ocultar um nome herdado não é especificamente um erro, já que isso impediria uma evolução separada das classes base.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="4d5ad-454">Por exemplo, a situação acima pode ter surgido porque uma versão mais recente do `Base` introduziu um método `F` que não estava presente em uma versão anterior da classe.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="4d5ad-455">Se houvesse um erro na situação acima, qualquer alteração feita em uma classe base em uma biblioteca de classes com controle de versão separada poderia potencialmente fazer com que as classes derivadas se tornassem inválidas.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="4d5ad-456">O aviso causado pela ocultação de um nome herdado pode ser eliminado por meio do uso do modificador `new`:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="4d5ad-457">O modificador `new` indica que o `F` em `Derived` é "novo" e que, na verdade, é destinado a ocultar o membro herdado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="4d5ad-458">Uma declaração de um novo membro oculta um membro herdado somente dentro do escopo do novo membro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="4d5ad-459">No exemplo acima, a declaração de `F` em `Derived` oculta o `F` que foi herdado de `Base`, mas como o novo `F` em `Derived` tem acesso privado, seu escopo não se estende para `MoreDerived`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="4d5ad-460">Assim, a chamada `F()` em `MoreDerived.G` é válida e invocará `Base.F`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="4d5ad-461">Namespace e nomes de tipo</span><span class="sxs-lookup"><span data-stu-id="4d5ad-461">Namespace and type names</span></span>

<span data-ttu-id="4d5ad-462">Vários contextos em um C# programa exigem que um *Namespace_Name* ou um *type_name* seja especificado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="4d5ad-463">Um *Namespace_Name* é um *namespace_or_type_name* que se refere a um namespace.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="4d5ad-464">Após a resolução, conforme descrito abaixo, o *namespace_or_type_name* de um *Namespace_Name* deve se referir a um namespace ou, caso contrário, ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="4d5ad-465">Nenhum argumento de tipo ([argumentos de tipo](types.md#type-arguments)) pode estar presente em um *Namespace_Name* (somente tipos podem ter argumentos de tipo).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="4d5ad-466">Um *type_name* é um *namespace_or_type_name* que se refere a um tipo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="4d5ad-467">Após a resolução, conforme descrito abaixo, o *namespace_or_type_name* de um *type_name* deve se referir a um tipo ou, caso contrário, ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="4d5ad-468">Se *namespace_or_type_name* for um membro de alias qualificado, seu significado será conforme descrito em [qualificadores de alias de namespace](namespaces.md#namespace-alias-qualifiers).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="4d5ad-469">Caso contrário, um *namespace_or_type_name* terá uma das quatro formas:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="4d5ad-470">onde `I` é um único identificador, `N` é um *namespace_or_type_name* e `<A1, ..., Ak>` é um *type_argument_list*opcional.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="4d5ad-471">Quando nenhum *type_argument_list* for especificado, considere `k` como zero.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="4d5ad-472">O significado de um *namespace_or_type_name* é determinado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="4d5ad-473">Se *namespace_or_type_name* estiver no formato `I` ou no formato `I<A1, ..., Ak>`:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="4d5ad-474">Se `K` for zero e o *namespace_or_type_name* aparecer dentro de uma declaração de método genérico ([métodos](classes.md#methods)) e se essa declaração incluir um parâmetro de tipo ([parâmetros de tipo](classes.md#type-parameters)) com o nome @ no__t-4, o *namespace_or_type_ nome* refere-se a esse parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="4d5ad-475">Caso contrário, se o *namespace_or_type_name* aparecer dentro de uma declaração de tipo, para cada tipo de instância @ no__t-1 ([o tipo de instância](classes.md#the-instance-type)), começando com o tipo de instância dessa declaração de tipo e continuando com o tipo de instância de cada declaração de classe ou struct de circunscrição (se houver):</span><span class="sxs-lookup"><span data-stu-id="4d5ad-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="4d5ad-476">Se `K` for zero e a declaração de `T` incluir um parâmetro de tipo com o nome @ no__t-2, o *namespace_or_type_name* se referirá a esse parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="4d5ad-477">Caso contrário, se o *namespace_or_type_name* aparecer no corpo da declaração de tipo e `T` ou qualquer um de seus tipos base contiver um tipo acessível aninhado com os parâmetros Name @ no__t-2 e `K` @ no__t-4type, então o *namespace_or_type _name* refere-se a esse tipo construído com os argumentos de tipo fornecidos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="4d5ad-478">Se houver mais de um tipo, o tipo declarado dentro do tipo mais derivado será selecionado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="4d5ad-479">Observe que os membros sem tipo (constantes, campos, métodos, propriedades, indexadores, operadores, construtores de instância, destruidores e construtores estáticos) e membros de tipo com um número diferente de parâmetros de tipo são ignorados ao determinar o significado do *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="4d5ad-480">Se as etapas anteriores não tiverem sido bem-sucedidas, para cada namespace @ no__t-0, começando com o namespace no qual o *namespace_or_type_name* ocorre, continuando com cada namespace delimitador (se houver) e terminando com o namespace global, o seguinte as etapas são avaliadas até que uma entidade esteja localizada:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="4d5ad-481">Se `K` for zero e `I` for o nome de um namespace em @ no__t-2, então:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="4d5ad-482">Se o local onde o *namespace_or_type_name* ocorrer é incluído por uma declaração de namespace para `N` e a declaração de namespace contém um *extern_alias_directive* ou *using_alias_directive* que associa o nome @ no __t-4 com um namespace ou tipo, o *namespace_or_type_name* é ambíguo e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="4d5ad-483">Caso contrário, o *namespace_or_type_name* refere-se ao namespace chamado `I` em `N`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="4d5ad-484">Caso contrário, se `N` contiver um tipo acessível com os parâmetros Name @ no__t-1 e `K` @ no__t-3type, então:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="4d5ad-485">Se `K` for zero e o local em que o *namespace_or_type_name* ocorrer for incluído por uma declaração de namespace para `N` e a declaração de namespace contiver um *extern_alias_directive* ou *using_alias_directive* que associa o nome @ no__t-5 a um namespace ou tipo, então, o *namespace_or_type_name* é ambíguo e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="4d5ad-486">Caso contrário, o *namespace_or_type_name* se refere ao tipo construído com os argumentos de tipo fornecidos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="4d5ad-487">Caso contrário, se o local onde o *namespace_or_type_name* ocorrer for incluído por uma declaração de namespace para `N`:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="4d5ad-488">Se `K` for zero e a declaração de namespace contiver um *extern_alias_directive* ou um *using_alias_directive* que associa o nome @ no__t-3 a um namespace ou tipo importado, o *namespace_or_type_name* se referirá a isso namespace ou tipo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="4d5ad-489">Caso contrário, se os namespaces e as declarações de tipo importados pelos *using_namespace_directive*s e *using_alias_directive*s da declaração de namespace contiverem exatamente um tipo acessível com o nome @ no__t-2 e `K` @ no__t-4type os parâmetros, em seguida, o *namespace_or_type_name* refere-se a esse tipo construído com os argumentos de tipo fornecidos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="4d5ad-490">Caso contrário, se os namespaces e as declarações de tipo importados pelos *using_namespace_directive*s e *using_alias_directive*s da declaração de namespace contiverem mais de um tipo acessível com o nome @ no__t-2 e `K` @ no__t-4type parâmetros, o *namespace_or_type_name* é ambíguo e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="4d5ad-491">Caso contrário, o *namespace_or_type_name* será indefinido e ocorrerá um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="4d5ad-492">Caso contrário, o *namespace_or_type_name* será do formato `N.I` ou do formulário `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="4d5ad-493">`N` é resolvido primeiro como um *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="4d5ad-494">Se a resolução de `N` não for bem-sucedida, ocorrerá um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="4d5ad-495">Caso contrário, `N.I` ou `N.I<A1, ..., Ak>` será resolvido da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="4d5ad-496">Se `K` for zero e `N` se referir a um namespace e `N` contiver um namespace aninhado com o nome `I`, o *namespace_or_type_name* se referirá a esse namespace aninhado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="4d5ad-497">Caso contrário, se `N` se referir a um namespace e `N` contiver um tipo acessível com os parâmetros Name @ no__t-2 e `K` @ no__t-4type, o *namespace_or_type_name* se referirá a esse tipo construído com os argumentos de tipo fornecidos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="4d5ad-498">Caso contrário, se `N` se referir a uma classe (possivelmente construída) ou tipo struct e `N` ou qualquer uma de suas classes base contiverem um tipo acessível aninhado com os parâmetros Name @ no__t-2 e `K` @ no__t-4type, o *namespace_or_type_name* se referirá a Esse tipo construído com os argumentos de tipo fornecidos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="4d5ad-499">Se houver mais de um tipo, o tipo declarado dentro do tipo mais derivado será selecionado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="4d5ad-500">Observe que, se o significado de `N.I` estiver sendo determinado como parte da resolução da especificação de classe base de `N`, a classe base direta de `N` será considerada objeto ([classes base](classes.md#base-classes)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="4d5ad-501">Caso contrário, `N.I` é um *namespace_or_type_name*inválido e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="4d5ad-502">Um *namespace_or_type_name* tem permissão para fazer referência a uma classe estática ([classes estáticas](classes.md#static-classes)) somente se</span><span class="sxs-lookup"><span data-stu-id="4d5ad-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="4d5ad-503">O *namespace_or_type_name* é o `T` em um *namespace_or_type_name* do formulário `T.I` ou</span><span class="sxs-lookup"><span data-stu-id="4d5ad-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="4d5ad-504">O *namespace_or_type_name* é o `T` em um *typeof_expression* ([lista de argumentos](expressions.md#argument-lists)1) do formato `typeof(T)`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="4d5ad-505">Nomes totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="4d5ad-505">Fully qualified names</span></span>

<span data-ttu-id="4d5ad-506">Cada namespace e tipo tem um ***nome totalmente qualificado***, que identifica exclusivamente o namespace ou o tipo entre todos os outros.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="4d5ad-507">O nome totalmente qualificado de um namespace ou tipo `N` é determinado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="4d5ad-508">Se `N` for um membro do namespace global, seu nome totalmente qualificado será `N`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="4d5ad-509">Caso contrário, seu nome totalmente qualificado é `S.N`, em que `S` é o nome totalmente qualificado do namespace ou tipo no qual `N` é declarado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="4d5ad-510">Em outras palavras, o nome totalmente qualificado de `N` é o caminho hierárquico completo dos identificadores que levam a `N`, a partir do namespace global.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="4d5ad-511">Como cada membro de um namespace ou tipo deve ter um nome exclusivo, ele segue que o nome totalmente qualificado de um namespace ou tipo é sempre exclusivo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="4d5ad-512">O exemplo a seguir mostra várias declarações de namespace e tipo junto com seus nomes totalmente qualificados associados.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="4d5ad-513">Gerenciamento automático de memória</span><span class="sxs-lookup"><span data-stu-id="4d5ad-513">Automatic memory management</span></span>

<span data-ttu-id="4d5ad-514">C#o emprega o gerenciamento automático de memória, que libera os desenvolvedores de alocar e liberar manualmente a memória ocupada por objetos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="4d5ad-515">As políticas de gerenciamento automático de memória são implementadas por um ***coletor de lixo***.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="4d5ad-516">O ciclo de vida de gerenciamento de memória de um objeto é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="4d5ad-517">Quando o objeto é criado, a memória é alocada para ele, o construtor é executado e o objeto é considerado dinâmico.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="4d5ad-518">Se o objeto, ou qualquer parte dele, não puder ser acessado por nenhuma possível continuação de execução, além da execução de destruidores, o objeto será considerado não em uso e se tornará elegível para destruição.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="4d5ad-519">O C# compilador e o coletor de lixo podem optar por analisar o código para determinar quais referências a um objeto podem ser usadas no futuro.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="4d5ad-520">Por exemplo, se uma variável local que está no escopo for a única referência existente a um objeto, mas essa variável local nunca for mencionada em qualquer continuação possível de execução do ponto de execução atual no procedimento, o coletor de lixo poderá (mas não é necessário para) tratar o objeto como não está mais em uso.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="4d5ad-521">Depois que o objeto estiver qualificado para destruição, em algum momento não especificado, o destruidor ([destruidores](classes.md#destructors)) (se houver) para o objeto será executado.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="4d5ad-522">Em circunstâncias normais, o destruidor para o objeto é executado apenas uma vez, embora APIs específicas de implementação possam permitir que esse comportamento seja substituído.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="4d5ad-523">Depois que o destruidor de um objeto for executado, se esse objeto ou qualquer parte dele, não puder ser acessado por qualquer continuação possível de execução, incluindo a execução de destruidores, o objeto será considerado inacessível e o objeto se tornará elegível para a coleta.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="4d5ad-524">Finalmente, em algum momento depois que o objeto se tornar qualificado para a coleta, o coletor de lixo liberará a memória associada a esse objeto.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="4d5ad-525">O coletor de lixo mantém informações sobre o uso do objeto e usa essas informações para tomar decisões de gerenciamento de memória, como o local na memória para localizar um objeto recém-criado, quando realocar um objeto e quando um objeto não está mais em uso ou inacessível.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="4d5ad-526">Assim como outras linguagens que assumem a existência de um C# coletor de lixo, é projetada para que o coletor de lixo possa implementar uma ampla gama de políticas de gerenciamento de memória.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="4d5ad-527">Por exemplo, C# o não exige que os destruidores sejam executados ou que os objetos sejam coletados assim que estiverem qualificados ou que os destruidores sejam executados em qualquer ordem específica ou em qualquer thread específico.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="4d5ad-528">O comportamento do coletor de lixo pode ser controlado, em algum grau, por meio de métodos estáticos na classe `System.GC`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="4d5ad-529">Essa classe pode ser usada para solicitar que uma coleção ocorra, destruidores sejam executados (ou não executados) e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="4d5ad-530">Como o coletor de lixo tem permissão de uma ampla latitude ao decidir quando coletar objetos e executar destruidores, uma implementação de conformidade pode produzir uma saída diferente da mostrada pelo código a seguir.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="4d5ad-531">O programa</span><span class="sxs-lookup"><span data-stu-id="4d5ad-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="4d5ad-532">Cria uma instância da classe `A` e uma instância da classe `B`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="4d5ad-533">Esses objetos se tornam qualificados para coleta de lixo quando a variável `b` recebe o valor `null`, já que, após esse tempo, é impossível para qualquer código escrito pelo usuário acessá-los.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="4d5ad-534">A saída pode ser</span><span class="sxs-lookup"><span data-stu-id="4d5ad-534">The output could be either</span></span>

```console
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="4d5ad-535">ou</span><span class="sxs-lookup"><span data-stu-id="4d5ad-535">or</span></span>
```console
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="4d5ad-536">Porque o idioma impõe nenhuma restrição na ordem em que os objetos são coletados como lixo.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="4d5ad-537">Em casos sutis, a distinção entre "qualificado para destruição" e "elegível para coleta" pode ser importante.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="4d5ad-538">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="4d5ad-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="4d5ad-539">No programa acima, se o coletor de lixo optar por executar o destruidor de `A` antes do destruidor de `B`, a saída desse programa poderá ser:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```console
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="4d5ad-540">Observe que, embora a instância de `A` não esteja em uso e o destruidor de `A` fosse executado, ainda é possível que os métodos de `A` (nesse caso, `F`) sejam chamados de outro destruidor.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="4d5ad-541">Além disso, observe que a execução de um destruidor pode fazer com que um objeto se torne utilizável do programa principal novamente.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="4d5ad-542">Nesse caso, a execução do destruidor de `B` causou uma instância de `A` que não estava em uso anteriormente para tornar-se acessível da referência dinâmica `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="4d5ad-543">Após a chamada para `WaitForPendingFinalizers`, a instância de `B` é elegível para a coleção, mas a instância de `A` não é, devido à referência `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="4d5ad-544">Para evitar confusão e comportamento inesperado, geralmente é uma boa ideia para destruidores apenas realizar a limpeza nos dados armazenados nos próprios campos de seu objeto e não executar ações em objetos referenciados ou em campos estáticos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="4d5ad-545">Uma alternativa ao uso de destruidores é permitir que uma classe implemente a interface `System.IDisposable`.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="4d5ad-546">Isso permite que o cliente do objeto determine quando liberar os recursos do objeto, normalmente acessando o objeto como um recurso em uma instrução `using` ([a instrução using](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="4d5ad-547">Ordem de execução</span><span class="sxs-lookup"><span data-stu-id="4d5ad-547">Execution order</span></span>

<span data-ttu-id="4d5ad-548">A execução de C# um programa prossegue de forma que os efeitos colaterais de cada thread em execução sejam preservados em pontos de execução críticos.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="4d5ad-549">Um ***efeito colateral*** é definido como uma leitura ou gravação de um campo volátil, uma gravação em uma variável não volátil, uma gravação em um recurso externo e o lançamento de uma exceção.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="4d5ad-550">Os pontos de execução críticos em que a ordem desses efeitos colaterais devem ser preservados são referências a campos voláteis ([campos voláteis](classes.md#volatile-fields)), instruções `lock` ([a instrução Lock](statements.md#the-lock-statement)) e a criação e o encerramento de threads.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="4d5ad-551">O ambiente de execução é livre para alterar a ordem de execução de C# um programa, sujeito às seguintes restrições:</span><span class="sxs-lookup"><span data-stu-id="4d5ad-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="4d5ad-552">A dependência de dados é preservada dentro de um thread de execução.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="4d5ad-553">Ou seja, o valor de cada variável é calculado como se todas as instruções no thread fossem executadas na ordem do programa original.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="4d5ad-554">As regras de ordenação de inicialização são preservadas ([inicialização de campo](classes.md#field-initialization) e [inicializadores de variável](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="4d5ad-555">A ordenação de efeitos colaterais é preservada em relação às leituras e gravações voláteis ([campos voláteis](classes.md#volatile-fields)).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="4d5ad-556">Além disso, o ambiente de execução não precisa avaliar parte de uma expressão se puder deduzir que o valor da expressão não é usado e que nenhum efeito colateral necessário é produzido (incluindo qualquer causado pela chamada de um método ou acesso a um campo volátil).</span><span class="sxs-lookup"><span data-stu-id="4d5ad-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="4d5ad-557">Quando a execução do programa é interrompida por um evento assíncrono (como uma exceção lançada por outro thread), não há garantia de que os efeitos laterais observáveis estão visíveis na ordem do programa original.</span><span class="sxs-lookup"><span data-stu-id="4d5ad-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>

---
ms.openlocfilehash: a01cf9387b8dc47de036bf0bd1496c19a441d81c
ms.sourcegitcommit: 7f7fc6e9e195e51b7ff8229aeaa70aa9fbbb63cb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/10/2019
ms.locfileid: "70876801"
---
# <a name="variables"></a><span data-ttu-id="db42a-101">Variáveis</span><span class="sxs-lookup"><span data-stu-id="db42a-101">Variables</span></span>

<span data-ttu-id="db42a-102">As variáveis representam locais de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="db42a-102">Variables represent storage locations.</span></span> <span data-ttu-id="db42a-103">Cada variável tem um tipo que determina quais valores podem ser armazenados na variável.</span><span class="sxs-lookup"><span data-stu-id="db42a-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="db42a-104">C#é um idioma de tipo seguro, e o C# compilador garante que os valores armazenados em variáveis sejam sempre do tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="db42a-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="db42a-105">O valor de uma variável pode ser alterado por atribuição ou pelo uso dos `++` operadores e. `--`</span><span class="sxs-lookup"><span data-stu-id="db42a-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="db42a-106">Uma variável deve ser ***definitivamente atribuída*** ([atribuição definitiva](variables.md#definite-assignment)) antes que seu valor possa ser obtido.</span><span class="sxs-lookup"><span data-stu-id="db42a-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="db42a-107">Conforme descrito nas seções a seguir, as variáveis são ***inicialmente atribuídas*** ou ***inicialmente não atribuídas***.</span><span class="sxs-lookup"><span data-stu-id="db42a-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="db42a-108">Uma variável atribuída inicialmente tem um valor inicial bem definido e é sempre considerada definitivamente atribuída.</span><span class="sxs-lookup"><span data-stu-id="db42a-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="db42a-109">Uma variável inicialmente não atribuída não tem valor inicial.</span><span class="sxs-lookup"><span data-stu-id="db42a-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="db42a-110">Para que uma variável inicialmente não atribuída seja considerada definitivamente atribuída em determinado local, uma atribuição para a variável deve ocorrer em cada caminho de execução possível, levando a esse local.</span><span class="sxs-lookup"><span data-stu-id="db42a-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="db42a-111">Categorias de variáveis</span><span class="sxs-lookup"><span data-stu-id="db42a-111">Variable categories</span></span>

<span data-ttu-id="db42a-112">C#define sete categorias de variáveis: variáveis estáticas, variáveis de instância, elementos de matriz, parâmetros de valor, parâmetros de referência, parâmetros de saída e variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="db42a-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="db42a-113">As seções a seguir descrevem cada uma dessas categorias.</span><span class="sxs-lookup"><span data-stu-id="db42a-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="db42a-114">No exemplo</span><span class="sxs-lookup"><span data-stu-id="db42a-114">In the example</span></span>
```csharp
class A
{
    public static int x;
    int y;

    void F(int[] v, int a, ref int b, out int c) {
        int i = 1;
        c = a + b++;
    }
}
```
<span data-ttu-id="db42a-115">`x`é uma variável estática, `y` é uma variável de instância `v[0]` , é um elemento de `a` matriz, é um parâmetro `b` de valor, é um `c` parâmetro de referência, é um `i` parâmetro de saída e é uma variável local .</span><span class="sxs-lookup"><span data-stu-id="db42a-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="db42a-116">Variáveis estáticas</span><span class="sxs-lookup"><span data-stu-id="db42a-116">Static variables</span></span>

<span data-ttu-id="db42a-117">Um campo declarado com o `static` modificador é chamado de uma ***variável estática***.</span><span class="sxs-lookup"><span data-stu-id="db42a-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="db42a-118">Uma variável estática entra em existência antes da execução do construtor estático ([construtores estáticos](classes.md#static-constructors)) para seu tipo recipiente e deixa de existir quando o domínio do aplicativo associado deixar de existir.</span><span class="sxs-lookup"><span data-stu-id="db42a-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="db42a-119">O valor inicial de uma variável estática é o valor padrão ([valores padrão](variables.md#default-values)) do tipo da variável.</span><span class="sxs-lookup"><span data-stu-id="db42a-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="db42a-120">Para fins de verificação de atribuição definitiva, uma variável estática é considerada inicialmente atribuída.</span><span class="sxs-lookup"><span data-stu-id="db42a-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="db42a-121">Variáveis de instância</span><span class="sxs-lookup"><span data-stu-id="db42a-121">Instance variables</span></span>

<span data-ttu-id="db42a-122">Um campo declarado sem o `static` modificador é chamado de ***variável de instância***.</span><span class="sxs-lookup"><span data-stu-id="db42a-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="db42a-123">Variáveis de instância em classes</span><span class="sxs-lookup"><span data-stu-id="db42a-123">Instance variables in classes</span></span>

<span data-ttu-id="db42a-124">Uma variável de instância de uma classe entra em existência quando uma nova instância dessa classe é criada e deixa de existir quando não há nenhuma referência a essa instância e o destruidor da instância (se houver) tiver sido executado.</span><span class="sxs-lookup"><span data-stu-id="db42a-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="db42a-125">O valor inicial de uma variável de instância de uma classe é o valor padrão ([valores padrão](variables.md#default-values)) do tipo da variável.</span><span class="sxs-lookup"><span data-stu-id="db42a-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="db42a-126">Para fins de verificação de atribuição definitiva, uma variável de instância de uma classe é considerada inicialmente atribuída.</span><span class="sxs-lookup"><span data-stu-id="db42a-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="db42a-127">Variáveis de instância em structs</span><span class="sxs-lookup"><span data-stu-id="db42a-127">Instance variables in structs</span></span>

<span data-ttu-id="db42a-128">Uma variável de instância de uma struct tem exatamente o mesmo tempo de vida que a variável de struct à qual ela pertence.</span><span class="sxs-lookup"><span data-stu-id="db42a-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="db42a-129">Em outras palavras, quando uma variável de um tipo struct entra em existência ou deixa de existir, também as variáveis de instância do struct.</span><span class="sxs-lookup"><span data-stu-id="db42a-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="db42a-130">O estado de atribuição inicial de uma variável de instância de uma struct é o mesmo da variável struct que a contém.</span><span class="sxs-lookup"><span data-stu-id="db42a-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="db42a-131">Em outras palavras, quando uma variável de struct é considerada inicialmente atribuída, também são suas variáveis de instância e, quando uma variável de struct é considerada inicialmente não atribuída, suas variáveis de instância são, da mesma forma, não atribuídas.</span><span class="sxs-lookup"><span data-stu-id="db42a-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="db42a-132">Elementos da matriz</span><span class="sxs-lookup"><span data-stu-id="db42a-132">Array elements</span></span>

<span data-ttu-id="db42a-133">Os elementos de uma matriz entram em existência quando uma instância de matriz é criada e deixa de existir quando não há nenhuma referência a essa instância de matriz.</span><span class="sxs-lookup"><span data-stu-id="db42a-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="db42a-134">O valor inicial de cada um dos elementos de uma matriz é o valor padrão ([valores padrão](variables.md#default-values)) do tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="db42a-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="db42a-135">Para fins de verificação de atribuição definitiva, um elemento de matriz é considerado inicialmente atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="db42a-136">Parâmetros de valor</span><span class="sxs-lookup"><span data-stu-id="db42a-136">Value parameters</span></span>

<span data-ttu-id="db42a-137">Um parâmetro declarado sem um `ref` modificador ou `out` é um ***parâmetro de valor***.</span><span class="sxs-lookup"><span data-stu-id="db42a-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="db42a-138">Um parâmetro de valor entra em existência na invocação do membro da função (método, Construtor de instância, acessador ou operador) ou função anônima à qual o parâmetro pertence, e é inicializado com o valor do argumento fornecido na invocação.</span><span class="sxs-lookup"><span data-stu-id="db42a-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="db42a-139">Um parâmetro de valor normalmente deixa de existir no retorno do membro da função ou da função anônima.</span><span class="sxs-lookup"><span data-stu-id="db42a-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="db42a-140">No entanto, se o parâmetro de valor for capturado por uma função anônima ([expressões de função anônima](expressions.md#anonymous-function-expressions)), seu tempo de vida se estenderá pelo menos até que a árvore de delegação ou expressão criada a partir dessa função anônima esteja qualificada para a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="db42a-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="db42a-141">Para fins de verificação de atribuição definitiva, um parâmetro value é considerado inicialmente atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="db42a-142">Parâmetros de referência</span><span class="sxs-lookup"><span data-stu-id="db42a-142">Reference parameters</span></span>

<span data-ttu-id="db42a-143">Um parâmetro declarado com um `ref` modificador é um ***parâmetro de referência***.</span><span class="sxs-lookup"><span data-stu-id="db42a-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="db42a-144">Um parâmetro de referência não cria um novo local de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="db42a-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="db42a-145">Em vez disso, um parâmetro de referência representa o mesmo local de armazenamento que a variável fornecida como o argumento no membro da função ou invocação de função anônima.</span><span class="sxs-lookup"><span data-stu-id="db42a-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="db42a-146">Assim, o valor de um parâmetro de referência é sempre o mesmo que a variável subjacente.</span><span class="sxs-lookup"><span data-stu-id="db42a-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="db42a-147">As regras de atribuição definidas a seguir se aplicam aos parâmetros de referência.</span><span class="sxs-lookup"><span data-stu-id="db42a-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="db42a-148">Observe as diferentes regras para os parâmetros de saída descritos em [parâmetros de saída](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="db42a-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="db42a-149">Uma variável deve ser definitivamente atribuída ([atribuição](variables.md#definite-assignment)definida) antes de poder ser passada como um parâmetro de referência em um membro de função ou uma invocação de delegado.</span><span class="sxs-lookup"><span data-stu-id="db42a-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="db42a-150">Dentro de um membro de função ou função anônima, um parâmetro de referência é considerado inicialmente atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="db42a-151">Dentro de um método de instância ou acessador de instância de `this` um tipo struct, a palavra-chave se comporta exatamente como um parâmetro de referência do tipo struct ([esse acesso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="db42a-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="db42a-152">Parâmetros de saída</span><span class="sxs-lookup"><span data-stu-id="db42a-152">Output parameters</span></span>

<span data-ttu-id="db42a-153">Um parâmetro declarado com um `out` modificador é um ***parâmetro de saída***.</span><span class="sxs-lookup"><span data-stu-id="db42a-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="db42a-154">Um parâmetro de saída não cria um novo local de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="db42a-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="db42a-155">Em vez disso, um parâmetro de saída representa o mesmo local de armazenamento que a variável fornecida como o argumento no membro da função ou na invocação de delegado.</span><span class="sxs-lookup"><span data-stu-id="db42a-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="db42a-156">Assim, o valor de um parâmetro de saída é sempre o mesmo que a variável subjacente.</span><span class="sxs-lookup"><span data-stu-id="db42a-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="db42a-157">As regras de atribuição definidas a seguir se aplicam aos parâmetros de saída.</span><span class="sxs-lookup"><span data-stu-id="db42a-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="db42a-158">Observe as diferentes regras para parâmetros de referência descritos em [parâmetros de referência](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="db42a-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="db42a-159">Uma variável não precisa ser definitivamente atribuída antes que possa ser passada como um parâmetro de saída em um membro de função ou invocação de delegado.</span><span class="sxs-lookup"><span data-stu-id="db42a-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="db42a-160">Após a conclusão normal de um membro de função ou de uma invocação de delegado, cada variável passada como um parâmetro de saída é considerada atribuída nesse caminho de execução.</span><span class="sxs-lookup"><span data-stu-id="db42a-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="db42a-161">Dentro de um membro de função ou função anônima, um parâmetro de saída é considerado inicialmente não atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="db42a-162">Cada parâmetro de saída de um membro de função ou função anônima deve ser definitivamente atribuído ([atribuição definitiva](variables.md#definite-assignment)) antes que o membro de função ou função anônima retorne normalmente.</span><span class="sxs-lookup"><span data-stu-id="db42a-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="db42a-163">Dentro de um construtor de instância de um tipo struct `this` , a palavra-chave se comporta exatamente como um parâmetro de saída do tipo struct ([esse acesso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="db42a-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="db42a-164">Variáveis locais</span><span class="sxs-lookup"><span data-stu-id="db42a-164">Local variables</span></span>

<span data-ttu-id="db42a-165">Uma ***variável local*** é declarada por um *local_variable_declaration*, que pode ocorrer em um *bloco*, um *for_statement*, um *switch_statement* ou um *using_statement*; ou por um *foreach_statement* ou um *specific_catch_clause* para um *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="db42a-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="db42a-166">O tempo de vida de uma variável local é a parte da execução do programa durante o qual o armazenamento tem a garantia de ser reservado para ele.</span><span class="sxs-lookup"><span data-stu-id="db42a-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="db42a-167">Esse tempo de vida estende pelo menos da entrada para o *bloco*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*ou *specific_catch_clause* com o qual está associado, até a execução desse *bloco*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*ou *specific_catch_clause* termina de qualquer maneira.</span><span class="sxs-lookup"><span data-stu-id="db42a-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="db42a-168">(Inserir um *bloco* anexado ou chamar um método suspende, mas não termina, execução do *bloco*atual, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*ou *specific_ catch_clause*.) Se a variável local for capturada por uma função anônima ([variáveis externas capturadas](expressions.md#captured-outer-variables)), seu tempo de vida se estenderá pelo menos até que a árvore de delegado ou expressão seja criada a partir da função anônima, juntamente com quaisquer outros objetos que venham a fazer referência ao a variável capturada está qualificada para a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="db42a-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="db42a-169">Se o *bloco*pai, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*ou *specific_catch_clause* for inserido recursivamente, uma nova instância da variável local será criada cada o tempo e seu *local_variable_initializer*, se houver, serão avaliados a cada vez.</span><span class="sxs-lookup"><span data-stu-id="db42a-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="db42a-170">Uma variável local introduzida por um *local_variable_declaration* não é inicializada automaticamente e, portanto, não tem valor padrão.</span><span class="sxs-lookup"><span data-stu-id="db42a-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="db42a-171">Para fins de verificação de atribuição definitiva, uma variável local introduzida por um *local_variable_declaration* é considerada inicialmente não atribuída.</span><span class="sxs-lookup"><span data-stu-id="db42a-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="db42a-172">Um *local_variable_declaration* pode incluir um *local_variable_initializer*; nesse caso, a variável é considerada definitivamente atribuída somente após a expressão de inicialização ([instruções de declaração](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="db42a-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="db42a-173">Dentro do escopo de uma variável local introduzida por um *local_variable_declaration*, é um erro de tempo de compilação para se referir a essa variável local em uma posição textual que precede seu *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="db42a-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="db42a-174">Se a declaração de variável local for implícita ([declarações de variável local](statements.md#local-variable-declarations)), também será um erro para se referir à variável dentro de seu *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="db42a-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="db42a-175">Uma variável local introduzida por um *foreach_statement* ou um *specific_catch_clause* é considerada definitivamente atribuída em seu escopo inteiro.</span><span class="sxs-lookup"><span data-stu-id="db42a-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="db42a-176">O tempo de vida real de uma variável local é dependente de implementação.</span><span class="sxs-lookup"><span data-stu-id="db42a-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="db42a-177">Por exemplo, um compilador pode determinar estaticamente que uma variável local em um bloco seja usada apenas para uma pequena parte desse bloco.</span><span class="sxs-lookup"><span data-stu-id="db42a-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="db42a-178">Usando essa análise, o compilador pode gerar código que resulta no armazenamento da variável que tem um tempo de vida menor do que o bloco que a contém.</span><span class="sxs-lookup"><span data-stu-id="db42a-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="db42a-179">O armazenamento referido por uma variável de referência local é recuperado independentemente do tempo de vida dessa variável de referência local ([Gerenciamento de memória automático](basic-concepts.md#automatic-memory-management)).</span><span class="sxs-lookup"><span data-stu-id="db42a-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="db42a-180">Valores padrão</span><span class="sxs-lookup"><span data-stu-id="db42a-180">Default values</span></span>

<span data-ttu-id="db42a-181">As seguintes categorias de variáveis são inicializadas automaticamente para seus valores padrão:</span><span class="sxs-lookup"><span data-stu-id="db42a-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="db42a-182">Variáveis estáticas.</span><span class="sxs-lookup"><span data-stu-id="db42a-182">Static variables.</span></span>
*  <span data-ttu-id="db42a-183">Variáveis de instância de instâncias de classe.</span><span class="sxs-lookup"><span data-stu-id="db42a-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="db42a-184">Elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="db42a-184">Array elements.</span></span>

<span data-ttu-id="db42a-185">O valor padrão de uma variável depende do tipo da variável e é determinado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="db42a-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="db42a-186">Para uma variável de um *value_type*, o valor padrão é o mesmo que o valor calculado pelo construtor padrão do *Value_type*([construtores padrão](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="db42a-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="db42a-187">Para uma variável de um *reference_type*, o valor padrão é `null`.</span><span class="sxs-lookup"><span data-stu-id="db42a-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="db42a-188">A inicialização para valores padrão normalmente é feita por ter o Gerenciador de memória ou o coletor de lixo inicializar a memória para todos os bits-zero antes que ele seja alocado para uso.</span><span class="sxs-lookup"><span data-stu-id="db42a-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="db42a-189">Por esse motivo, é conveniente usar todos os bits-zero para representar a referência nula.</span><span class="sxs-lookup"><span data-stu-id="db42a-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="db42a-190">Atribuição definitiva</span><span class="sxs-lookup"><span data-stu-id="db42a-190">Definite assignment</span></span>

<span data-ttu-id="db42a-191">Em um determinado local no código executável de um membro de função, uma variável é considerada ***definitivamente atribuída*** se o compilador pode provar, por uma análise de fluxo estático específica ([regras exatas para determinar a atribuição definitiva](variables.md#precise-rules-for-determining-definite-assignment)), que é a variável foi inicializado automaticamente ou tem sido o destino de pelo menos uma atribuição.</span><span class="sxs-lookup"><span data-stu-id="db42a-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="db42a-192">Indicado informalmente, as regras de atribuição definitiva são:</span><span class="sxs-lookup"><span data-stu-id="db42a-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="db42a-193">Uma variável atribuída inicialmente ([variáveis inicialmente atribuídas](variables.md#initially-assigned-variables)) é sempre considerada definitivamente atribuída.</span><span class="sxs-lookup"><span data-stu-id="db42a-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="db42a-194">Uma variável inicialmente não atribuída ([variáveis inicialmente não atribuídas](variables.md#initially-unassigned-variables)) será considerada definitivamente atribuída em um determinado local se todos os caminhos de execução possíveis que levam a esse local contiverem pelo menos um dos seguintes itens:</span><span class="sxs-lookup"><span data-stu-id="db42a-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="db42a-195">Uma atribuição simples ([atribuição simples](expressions.md#simple-assignment)) na qual a variável é o operando esquerdo.</span><span class="sxs-lookup"><span data-stu-id="db42a-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="db42a-196">Uma expressão de invocação ([expressões de invocação](expressions.md#invocation-expressions)) ou expressão de criação de objeto ([expressões de criação de objeto](expressions.md#object-creation-expressions)) que passa a variável como um parâmetro de saída.</span><span class="sxs-lookup"><span data-stu-id="db42a-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="db42a-197">Para uma variável local, uma declaração de variável local ([declarações de variável local](statements.md#local-variable-declarations)) que inclui um inicializador de variável.</span><span class="sxs-lookup"><span data-stu-id="db42a-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="db42a-198">A especificação formal subjacente às regras informais acima é descrita em [variáveis atribuídas inicialmente](variables.md#initially-assigned-variables), [variáveis inicialmente não atribuídas](variables.md#initially-unassigned-variables)e [regras precisas para determinar a atribuição definitiva](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="db42a-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="db42a-199">Os Estados de atribuição definitivos de variáveis de instância de uma variável *struct_type* são acompanhados individualmente, bem como coletivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="db42a-200">Além das regras acima, as regras a seguir se aplicam a variáveis *struct_type* e suas variáveis de instância:</span><span class="sxs-lookup"><span data-stu-id="db42a-200">In addition to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="db42a-201">Uma variável de instância é considerada definitivamente atribuída se a variável que a contém *struct_type* é considerada definitivamente atribuída.</span><span class="sxs-lookup"><span data-stu-id="db42a-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="db42a-202">Uma variável *struct_type* será considerada definitivamente atribuída se cada uma de suas variáveis de instância for considerada definitivamente atribuída.</span><span class="sxs-lookup"><span data-stu-id="db42a-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="db42a-203">A atribuição definitiva é um requisito nos seguintes contextos:</span><span class="sxs-lookup"><span data-stu-id="db42a-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="db42a-204">Uma variável deve ser atribuída definitivamente em cada local em que seu valor é obtido.</span><span class="sxs-lookup"><span data-stu-id="db42a-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="db42a-205">Isso garante que os valores indefinidos nunca ocorram.</span><span class="sxs-lookup"><span data-stu-id="db42a-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="db42a-206">A ocorrência de uma variável em uma expressão é considerada para obter o valor da variável, exceto quando</span><span class="sxs-lookup"><span data-stu-id="db42a-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="db42a-207">a variável é o operando esquerdo de uma atribuição simples,</span><span class="sxs-lookup"><span data-stu-id="db42a-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="db42a-208">a variável é passada como um parâmetro de saída ou</span><span class="sxs-lookup"><span data-stu-id="db42a-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="db42a-209">a variável é uma variável *struct_type* e ocorre como o operando esquerdo de um acesso de membro.</span><span class="sxs-lookup"><span data-stu-id="db42a-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="db42a-210">Uma variável deve ser definitivamente atribuída em cada local em que é passada como um parâmetro de referência.</span><span class="sxs-lookup"><span data-stu-id="db42a-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="db42a-211">Isso garante que o membro da função que está sendo invocado pode considerar o parâmetro de referência inicialmente atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="db42a-212">Todos os parâmetros de saída de um membro de função devem ser definitivamente atribuídos em cada local em que o membro da `return` função retorna (por meio de uma instrução ou por meio da execução que chega ao final do corpo do membro da função).</span><span class="sxs-lookup"><span data-stu-id="db42a-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="db42a-213">Isso garante que os membros da função não retornem valores indefinidos nos parâmetros de saída, permitindo que o compilador considere uma invocação de membro de função que usa uma variável como um parâmetro de saída equivalente a uma atribuição para a variável.</span><span class="sxs-lookup"><span data-stu-id="db42a-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="db42a-214">A `this` variável de um construtor de instância *struct_type* deve ser definitivamente atribuída em cada local em que o construtor de instância retorna.</span><span class="sxs-lookup"><span data-stu-id="db42a-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="db42a-215">Variáveis inicialmente atribuídas</span><span class="sxs-lookup"><span data-stu-id="db42a-215">Initially assigned variables</span></span>

<span data-ttu-id="db42a-216">As seguintes categorias de variáveis são classificadas como atribuídas inicialmente:</span><span class="sxs-lookup"><span data-stu-id="db42a-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="db42a-217">Variáveis estáticas.</span><span class="sxs-lookup"><span data-stu-id="db42a-217">Static variables.</span></span>
*  <span data-ttu-id="db42a-218">Variáveis de instância de instâncias de classe.</span><span class="sxs-lookup"><span data-stu-id="db42a-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="db42a-219">Variáveis de instância de variáveis de struct inicialmente atribuídas.</span><span class="sxs-lookup"><span data-stu-id="db42a-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="db42a-220">Elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="db42a-220">Array elements.</span></span>
*  <span data-ttu-id="db42a-221">Parâmetros de valor.</span><span class="sxs-lookup"><span data-stu-id="db42a-221">Value parameters.</span></span>
*  <span data-ttu-id="db42a-222">Parâmetros de referência.</span><span class="sxs-lookup"><span data-stu-id="db42a-222">Reference parameters.</span></span>
*  <span data-ttu-id="db42a-223">Variáveis declaradas `catch` em uma cláusula `foreach` ou em uma instrução.</span><span class="sxs-lookup"><span data-stu-id="db42a-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="db42a-224">Variáveis inicialmente não atribuídas</span><span class="sxs-lookup"><span data-stu-id="db42a-224">Initially unassigned variables</span></span>

<span data-ttu-id="db42a-225">As seguintes categorias de variáveis são classificadas como inicialmente não atribuídas:</span><span class="sxs-lookup"><span data-stu-id="db42a-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="db42a-226">Variáveis de instância de variáveis struct inicialmente não atribuídas.</span><span class="sxs-lookup"><span data-stu-id="db42a-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="db42a-227">Parâmetros de saída, incluindo `this` a variável de construtores de instância de struct.</span><span class="sxs-lookup"><span data-stu-id="db42a-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="db42a-228">Variáveis locais, exceto aquelas declaradas `catch` em uma cláusula `foreach` ou uma instrução.</span><span class="sxs-lookup"><span data-stu-id="db42a-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="db42a-229">Regras precisas para determinar a atribuição definitiva</span><span class="sxs-lookup"><span data-stu-id="db42a-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="db42a-230">Para determinar se cada variável usada é definitivamente atribuída, o compilador deve usar um processo que seja equivalente ao descrito nesta seção.</span><span class="sxs-lookup"><span data-stu-id="db42a-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="db42a-231">O compilador processa o corpo de cada membro de função que tem uma ou mais variáveis não atribuídas inicialmente.</span><span class="sxs-lookup"><span data-stu-id="db42a-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="db42a-232">Para cada variável *v*inicialmente não atribuída, o compilador determina um ***estado de atribuição definitivo*** para *v* em cada um dos seguintes pontos no membro da função:</span><span class="sxs-lookup"><span data-stu-id="db42a-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="db42a-233">No início de cada instrução</span><span class="sxs-lookup"><span data-stu-id="db42a-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="db42a-234">No ponto de extremidade ([pontos de extremidade e acessibilidade](statements.md#end-points-and-reachability)) de cada instrução</span><span class="sxs-lookup"><span data-stu-id="db42a-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="db42a-235">Em cada arco que transfere o controle para outra instrução ou para o ponto final de uma instrução</span><span class="sxs-lookup"><span data-stu-id="db42a-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="db42a-236">No início de cada expressão</span><span class="sxs-lookup"><span data-stu-id="db42a-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="db42a-237">No final de cada expressão</span><span class="sxs-lookup"><span data-stu-id="db42a-237">At the end of each expression</span></span>

<span data-ttu-id="db42a-238">O estado de atribuição definitivo de *v* pode ser:</span><span class="sxs-lookup"><span data-stu-id="db42a-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="db42a-239">Definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-239">Definitely assigned.</span></span> <span data-ttu-id="db42a-240">Isso indica que em todos os fluxos de controle possíveis para esse ponto, *v* recebeu um valor.</span><span class="sxs-lookup"><span data-stu-id="db42a-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="db42a-241">Não é definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-241">Not definitely assigned.</span></span> <span data-ttu-id="db42a-242">Para o estado de uma variável no final de uma expressão do tipo `bool`, o estado de uma variável que não está definitivamente atribuída pode (mas não necessariamente) se enquadrar em um dos seguintes subcaminhos:</span><span class="sxs-lookup"><span data-stu-id="db42a-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="db42a-243">Atribuído definitivamente após a expressão true.</span><span class="sxs-lookup"><span data-stu-id="db42a-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="db42a-244">Esse estado indica que *v* é definitivamente atribuído se a expressão booliana for avaliada como true, mas não será necessariamente atribuído se a expressão booliana for avaliada como false.</span><span class="sxs-lookup"><span data-stu-id="db42a-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="db42a-245">Definitivamente atribuída após expressão false.</span><span class="sxs-lookup"><span data-stu-id="db42a-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="db42a-246">Esse estado indica que *v* é definitivamente atribuído se a expressão booliana for avaliada como false, mas não será necessariamente atribuída se a expressão booliana for avaliada como true.</span><span class="sxs-lookup"><span data-stu-id="db42a-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="db42a-247">As regras a seguir regem como o estado de uma variável *v* é determinado em cada local.</span><span class="sxs-lookup"><span data-stu-id="db42a-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="db42a-248">Regras gerais para instruções</span><span class="sxs-lookup"><span data-stu-id="db42a-248">General rules for statements</span></span>

*  <span data-ttu-id="db42a-249">*v* não é definitivamente atribuído no início de um corpo de membro de função.</span><span class="sxs-lookup"><span data-stu-id="db42a-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="db42a-250">o *v* é definitivamente atribuído no início de qualquer instrução inacessível.</span><span class="sxs-lookup"><span data-stu-id="db42a-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="db42a-251">O estado de atribuição definitivo de *v* no início de qualquer outra instrução é determinado verificando o estado de atribuição definido de *v* em todas as transferências de fluxo de controle direcionadas ao início dessa instrução.</span><span class="sxs-lookup"><span data-stu-id="db42a-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="db42a-252">Se (e somente se) *v* for definitivamente atribuído a todas as transferências de fluxo de controle, *v* será definitivamente atribuído no início da instrução.</span><span class="sxs-lookup"><span data-stu-id="db42a-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="db42a-253">O conjunto de possíveis transferências de fluxo de controle é determinado da mesma forma que para verificar a acessibilidade da instrução ([pontos de extremidade e acessibilidade](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="db42a-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="db42a-254">O estado de atribuição definitivo de *v* no ponto de extremidade de um `checked`bloco `unchecked`, `if` `lock` `while` `foreach` `do` `for`,,,,,, `using`,, ou `switch`a instrução é determinada verificando o estado de atribuição definido de *v* em todas as transferências de fluxo de controle direcionadas ao ponto de extremidade dessa instrução.</span><span class="sxs-lookup"><span data-stu-id="db42a-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="db42a-255">Se *v* for definitivamente atribuído a todas essas transferências de fluxo de controle, então *v* será definitivamente atribuído no ponto de extremidade da instrução.</span><span class="sxs-lookup"><span data-stu-id="db42a-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="db42a-256">, *v* não é definitivamente atribuído no ponto de extremidade da instrução.</span><span class="sxs-lookup"><span data-stu-id="db42a-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="db42a-257">O conjunto de possíveis transferências de fluxo de controle é determinado da mesma forma que para verificar a acessibilidade da instrução ([pontos de extremidade e acessibilidade](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="db42a-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="db42a-258">Instruções Block, instruções marcadas e desmarcadas</span><span class="sxs-lookup"><span data-stu-id="db42a-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="db42a-259">O estado de atribuição definitivo de *v* na transferência de controle para a primeira instrução da lista de instruções no bloco (ou até o ponto final do bloco, se a lista de instruções estiver vazia) é igual à instrução de atribuição definitiva de *v* antes do bloco instrução `checked`, ou `unchecked` .</span><span class="sxs-lookup"><span data-stu-id="db42a-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="db42a-260">Instruções de expressão</span><span class="sxs-lookup"><span data-stu-id="db42a-260">Expression statements</span></span>

<span data-ttu-id="db42a-261">Para uma instrução de expressão *stmt* que consiste na expressão *Expression:*</span><span class="sxs-lookup"><span data-stu-id="db42a-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="db42a-262">*v* tem o mesmo estado de atribuição definitivo no início de *expr* como no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-263">Se *for* definitivamente atribuído ao final de *expr*, ele será definitivamente atribuído no ponto final de *stmt*; , Ele não é definitivamente atribuído no ponto de extremidade de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="db42a-264">Instruções de declaração</span><span class="sxs-lookup"><span data-stu-id="db42a-264">Declaration statements</span></span>

*  <span data-ttu-id="db42a-265">Se *stmt* for uma instrução de declaração sem inicializadores, *v* terá o mesmo estado de atribuição definitivo no ponto de extremidade de *stmt* como no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-266">Se *stmt* for uma instrução de declaração com inicializadores, o estado de atribuição definitivo para *v* será determinado como se *stmt* fosse uma lista de instruções, com uma instrução de atribuição para cada declaração com um inicializador (na ordem de declaração).</span><span class="sxs-lookup"><span data-stu-id="db42a-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="db42a-267">Instruções If</span><span class="sxs-lookup"><span data-stu-id="db42a-267">If statements</span></span>

<span data-ttu-id="db42a-268">Para uma `if` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="db42a-269">*v* tem o mesmo estado de atribuição definitivo no início de *expr* como no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-270">Se *v* for definitivamente atribuído ao final de *expr*, ele será definitivamente atribuído na transferência de fluxo de controle para *then_stmt* e *else_stmt* ou para o ponto de extremidade de *stmt* se não houver nenhuma cláusula else.</span><span class="sxs-lookup"><span data-stu-id="db42a-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="db42a-271">Se *v* tiver o estado "definitivamente atribuído após expressão verdadeira" no final de *expr*, ele será definitivamente atribuído na transferência de fluxo de controle para *then_stmt*e não definitivamente atribuído na transferência de fluxo de controle para *else_ stmt* ou para o ponto de extremidade de *stmt* se não houver nenhuma cláusula else.</span><span class="sxs-lookup"><span data-stu-id="db42a-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="db42a-272">Se *v* tiver o estado "definitivamente atribuído após expressão falsa" no final de *expr*, ele será definitivamente atribuído na transferência de fluxo de controle para *else_stmt*e não definitivamente atribuído na transferência de fluxo de controle para *then_stmt* .</span><span class="sxs-lookup"><span data-stu-id="db42a-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="db42a-273">Ele é definitivamente atribuído no ponto de extremidade de *stmt* se e somente se ele for definitivamente atribuído no ponto de extremidade de *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="db42a-274">Caso contrário, *v* é considerado não definitivamente atribuído na transferência de fluxo de controle para *then_stmt* ou *else_stmt*, ou para o ponto de extremidade de *stmt* se não houver nenhuma cláusula else.</span><span class="sxs-lookup"><span data-stu-id="db42a-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="db42a-275">Instruções switch</span><span class="sxs-lookup"><span data-stu-id="db42a-275">Switch statements</span></span>

<span data-ttu-id="db42a-276">Em uma `switch` instrução *stmt* com uma *expr*de expressão de controle:</span><span class="sxs-lookup"><span data-stu-id="db42a-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="db42a-277">O estado de atribuição definitivo de *v* no início de *expr* é o mesmo que o estado de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-278">O estado de atribuição definitivo de *v* na transferência de fluxo de controle para uma lista de instrução de bloqueio de switch acessível é igual ao estado de atribuição definido de *v* no final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="db42a-279">Instruções while</span><span class="sxs-lookup"><span data-stu-id="db42a-279">While statements</span></span>

<span data-ttu-id="db42a-280">Para uma `while` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="db42a-281">*v* tem o mesmo estado de atribuição definitivo no início de *expr* como no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-282">Se *v* for definitivamente atribuído ao final de *expr*, ele será definitivamente atribuído na transferência de fluxo de controle para *while_body* e para o ponto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="db42a-283">Se *v* tiver o estado "definitivamente atribuído após expressão verdadeira" no final de *expr*, ele será definitivamente atribuído na transferência de fluxo de controle para *while_body*, mas não definitivamente atribuído no ponto de extremidade de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="db42a-284">Se *v* tiver o estado "definitivamente atribuído após expressão falsa" no final de *expr*, ele será definitivamente atribuído na transferência de fluxo de controle para o ponto final de *stmt*, mas não definitivamente atribuído na transferência de fluxo de controle ao *while _body*.</span><span class="sxs-lookup"><span data-stu-id="db42a-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="db42a-285">Instruções do</span><span class="sxs-lookup"><span data-stu-id="db42a-285">Do statements</span></span>

<span data-ttu-id="db42a-286">Para uma `do` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="db42a-287">*v* tem o mesmo estado de atribuição definitivo na transferência de fluxo de controle do início de *stmt* para *do_body* como no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-288">*v* tem o mesmo estado de atribuição definitivo no início de *expr* como no ponto de extremidade de *do_body*.</span><span class="sxs-lookup"><span data-stu-id="db42a-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="db42a-289">Se *v* for definitivamente atribuído ao final de *expr*, ele será definitivamente atribuído na transferência de fluxo de controle para o ponto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="db42a-290">Se *v* tiver o estado "definitivamente atribuído após expressão falsa" no final de *expr*, ele será definitivamente atribuído na transferência de fluxo de controle para o ponto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="db42a-291">Instruções for</span><span class="sxs-lookup"><span data-stu-id="db42a-291">For statements</span></span>

<span data-ttu-id="db42a-292">Verificação de atribuição definitiva `for` para uma instrução do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="db42a-293">é feito como se a instrução fosse gravada:</span><span class="sxs-lookup"><span data-stu-id="db42a-293">is done as if the statement were written:</span></span>
```csharp
{
    for_initializer ;
    while ( for_condition ) {
        embedded_statement ;
        for_iterator ;
    }
}
```

<span data-ttu-id="db42a-294">Se o *for_condition* for omitido da `for` instrução, a avaliação da atribuição definitiva continuará como se *for_condition* fosse substituído `true` por na expansão acima.</span><span class="sxs-lookup"><span data-stu-id="db42a-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="db42a-295">Instruções Break, continue e goto</span><span class="sxs-lookup"><span data-stu-id="db42a-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="db42a-296">O estado de atribuição definitivo de *v* na transferência de fluxo de controle `break`causada `continue`por uma `goto` instrução, ou é igual ao estado de atribuição definido de *v* no início da instrução.</span><span class="sxs-lookup"><span data-stu-id="db42a-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="db42a-297">Instruções throw</span><span class="sxs-lookup"><span data-stu-id="db42a-297">Throw statements</span></span>

<span data-ttu-id="db42a-298">Para uma instrução *stmt* do formulário</span><span class="sxs-lookup"><span data-stu-id="db42a-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="db42a-299">O estado de atribuição definitivo de *v* no início de *expr* é o mesmo que o estado de atribuição definido de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="db42a-300">Instruções de retorno</span><span class="sxs-lookup"><span data-stu-id="db42a-300">Return statements</span></span>

<span data-ttu-id="db42a-301">Para uma instrução *stmt* do formulário</span><span class="sxs-lookup"><span data-stu-id="db42a-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="db42a-302">O estado de atribuição definitivo de *v* no início de *expr* é o mesmo que o estado de atribuição definido de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-303">Se *v* for um parâmetro de saída, ele deverá ser definitivamente atribuído a:</span><span class="sxs-lookup"><span data-stu-id="db42a-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="db42a-304">Depois de *expr*</span><span class="sxs-lookup"><span data-stu-id="db42a-304">after *expr*</span></span>
    * <span data-ttu-id="db42a-305">ou no final `finally` do bloco de um `try` ou`return` que incluiainstrução.- `try` - `finally` `catch` - `finally`</span><span class="sxs-lookup"><span data-stu-id="db42a-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="db42a-306">Para uma instrução stmt do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="db42a-307">Se *v* for um parâmetro de saída, ele deverá ser definitivamente atribuído a:</span><span class="sxs-lookup"><span data-stu-id="db42a-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="db42a-308">antes de *stmt*</span><span class="sxs-lookup"><span data-stu-id="db42a-308">before *stmt*</span></span>
    * <span data-ttu-id="db42a-309">ou no final `finally` do bloco de um `try` ou`return` que incluiainstrução.- `try` - `finally` `catch` - `finally`</span><span class="sxs-lookup"><span data-stu-id="db42a-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="db42a-310">Instruções Try-Catch</span><span class="sxs-lookup"><span data-stu-id="db42a-310">Try-catch statements</span></span>

<span data-ttu-id="db42a-311">Para uma instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="db42a-312">O estado de atribuição definitivo de *v* no início de *try_block* é o mesmo que o estado de atribuição definido de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-313">O estado de atribuição definitivo de *v* no início de *catch_block_i* (para qualquer *i*) é igual ao estado de atribuição definitivo de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-314">O estado de atribuição definitivo de *v* no ponto de extremidade de *stmt* é definitivamente atribuído se (e somente se) *v* for definitivamente atribuído no ponto de extremidade de *try_block* e a cada *catch_block_i* (para cada *i* de 1 a *n* ).</span><span class="sxs-lookup"><span data-stu-id="db42a-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="db42a-315">Instruções try – finally</span><span class="sxs-lookup"><span data-stu-id="db42a-315">Try-finally statements</span></span>

<span data-ttu-id="db42a-316">Para uma `try` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="db42a-317">O estado de atribuição definitivo de *v* no início de *try_block* é o mesmo que o estado de atribuição definido de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-318">O estado de atribuição definitivo de *v* no início de *finally_block* é o mesmo que o estado de atribuição definido de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-319">O estado de atribuição definitivo de *v* no ponto de extremidade de *stmt* é definitivamente atribuído se (e somente se) pelo menos uma das seguintes opções for verdadeira:</span><span class="sxs-lookup"><span data-stu-id="db42a-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="db42a-320">o *v* é definitivamente atribuído no ponto de extremidade de *try_block*</span><span class="sxs-lookup"><span data-stu-id="db42a-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="db42a-321">o *v* é definitivamente atribuído no ponto de extremidade de *finally_block*</span><span class="sxs-lookup"><span data-stu-id="db42a-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="db42a-322">Se uma transferência de fluxo de controle (por exemplo `goto` , uma instrução) for feita em *try_block*e terminar fora de *try_block*, então *v* também será considerado definitivamente atribuído nessa transferência de fluxo de controle se *v* for definitivamente atribuído no ponto de extremidade de *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="db42a-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="db42a-323">(Isso não é apenas se — se *v* for definitivamente atribuído por outro motivo nessa transferência de fluxo de controle, ele ainda será considerado definitivamente atribuído.)</span><span class="sxs-lookup"><span data-stu-id="db42a-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="db42a-324">Instruções try – catch-finally</span><span class="sxs-lookup"><span data-stu-id="db42a-324">Try-catch-finally statements</span></span>

<span data-ttu-id="db42a-325">Análise de atribuição definitiva `try` para uma - - `catch` instruçãodoformulário`finally` :</span><span class="sxs-lookup"><span data-stu-id="db42a-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="db42a-326">é feito como se a instrução fosse uma `try` - `try` - `finally` instrução delimitando uma `catch` instrução:</span><span class="sxs-lookup"><span data-stu-id="db42a-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
    try try_block
    catch(...) catch_block_1
    ...
    catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="db42a-327">O exemplo a seguir demonstra como os diferentes blocos de `try` uma instrução ([a instrução try](statements.md#the-try-statement)) afetam a atribuição definitiva.</span><span class="sxs-lookup"><span data-stu-id="db42a-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
    static void F() {
        int i, j;
        try {
            goto LABEL;
            // neither i nor j definitely assigned
            i = 1;
            // i definitely assigned
        }

        catch {
            // neither i nor j definitely assigned
            i = 3;
            // i definitely assigned
        }

        finally {
            // neither i nor j definitely assigned
            j = 5;
            // j definitely assigned
            }
        // i and j definitely assigned
        LABEL:;
        // j definitely assigned

    }
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="db42a-328">Instruções Foreach</span><span class="sxs-lookup"><span data-stu-id="db42a-328">Foreach statements</span></span>

<span data-ttu-id="db42a-329">Para uma `foreach` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="db42a-330">O estado de atribuição definitivo de *v* no início de *expr* é o mesmo que o estado de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-331">O estado de atribuição definitivo de *v* na transferência de fluxo de controle para *embedded_statement* ou para o ponto final de *stmt* é igual ao estado de *v* no final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="db42a-332">Usando instruções</span><span class="sxs-lookup"><span data-stu-id="db42a-332">Using statements</span></span>

<span data-ttu-id="db42a-333">Para uma `using` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="db42a-334">O estado de atribuição definitivo de *v* no início de *resource_acquisition* é o mesmo que o estado de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-335">O estado de atribuição definitivo de *v* na transferência de fluxo de controle para *embedded_statement* é o mesmo que o estado de *v* no final de *resource_acquisition*.</span><span class="sxs-lookup"><span data-stu-id="db42a-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="db42a-336">Instruções Lock</span><span class="sxs-lookup"><span data-stu-id="db42a-336">Lock statements</span></span>

<span data-ttu-id="db42a-337">Para uma `lock` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="db42a-338">O estado de atribuição definitivo de *v* no início de *expr* é o mesmo que o estado de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-339">O estado de atribuição definitivo de *v* na transferência de fluxo de controle para *embedded_statement* é o mesmo que o estado de *v* no final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="db42a-340">Instruções yield</span><span class="sxs-lookup"><span data-stu-id="db42a-340">Yield statements</span></span>

<span data-ttu-id="db42a-341">Para uma `yield return` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="db42a-342">O estado de atribuição definitivo de *v* no início de *expr* é o mesmo que o estado de *v* no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="db42a-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="db42a-343">O estado de atribuição definitivo de *v* no final de *stmt* é igual ao estado de *v* no final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="db42a-344">Uma `yield break` instrução não tem nenhum efeito sobre o estado de atribuição definitivo.</span><span class="sxs-lookup"><span data-stu-id="db42a-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="db42a-345">Regras gerais para expressões simples</span><span class="sxs-lookup"><span data-stu-id="db42a-345">General rules for simple expressions</span></span>

<span data-ttu-id="db42a-346">A regra a seguir se aplica a esses tipos de expressões: literais ([literais](expressions.md#literals)), nomes simples ([nomes simples](expressions.md#simple-names)), expressões de acesso de membro ([acesso de membro](expressions.md#member-access)), expressões de acesso base não indexadas ([acesso de base](expressions.md#base-access)), `typeof`expressões ([o operador typeof](expressions.md#the-typeof-operator)), expressões de valor padrão ([expressões de valor padrão](expressions.md#default-value-expressions)) e `nameof` expressões ([expressões nameof](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="db42a-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="db42a-347">O estado de atribuição definitivo de *v* no final de tal expressão é igual ao estado de atribuição definido de *v* no início da expressão.</span><span class="sxs-lookup"><span data-stu-id="db42a-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="db42a-348">Regras gerais para expressões com expressões inseridas</span><span class="sxs-lookup"><span data-stu-id="db42a-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="db42a-349">As regras a seguir se aplicam a esses tipos de expressões: expressões entre parênteses ([expressões entre parênteses](expressions.md#parenthesized-expressions)), expressões de acesso de elemento ([acesso de elemento](expressions.md#element-access)), expressões de acesso de base com indexação ([acesso de base](expressions.md#base-access)), incremento e decrementar expressões ([operadores de incremento e diminuição de sufixo](expressions.md#postfix-increment-and-decrement-operators), [incremento de prefixo e diminuir operadores](expressions.md#prefix-increment-and-decrement-operators)), expressões de conversão ( `~`expressões de[conversão](expressions.md#cast-expressions)), unário `+`, `-` `*`,,expressões, binary `+` `-` ,`%` ,,`>=`,, ,,`>>`,, ,`>`, `<<` `/` `*` `<` `<=` `==` `!=` expressões,`|`,,,, ,`^` ([operadores aritméticos](expressions.md#arithmetic-operators), [operadores de deslocamento](expressions.md#shift-operators), relacionais e de tipo-teste `is` `as` `&` [ operadores](expressions.md#relational-and-type-testing-operators), [operadores lógicos](expressions.md#logical-operators), expressões de atribuição compostas ( `checked` [atribuição composta](expressions.md#compound-assignment)) e `unchecked` expressões ([os operadores marcados e não verificados](expressions.md#the-checked-and-unchecked-operators)), além de matriz e delegado expressões de criação ([o novo operador](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="db42a-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="db42a-350">Cada uma dessas expressões tem uma ou mais subexpressãos que são avaliadas incondicionalmente em uma ordem fixa.</span><span class="sxs-lookup"><span data-stu-id="db42a-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="db42a-351">Por exemplo, o operador `%` binário avalia o lado esquerdo do operador e, em seguida, o lado direito.</span><span class="sxs-lookup"><span data-stu-id="db42a-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="db42a-352">Uma operação de indexação avalia a expressão indexada e, em seguida, avalia cada uma das expressões de índice, na ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="db42a-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="db42a-353">Para uma *expr*de expressão, que tem subexpressãos *E1, E2,..., en*, avaliadas nessa ordem:</span><span class="sxs-lookup"><span data-stu-id="db42a-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="db42a-354">O estado de atribuição definitivo de *v* no início do *E1* é o mesmo que o estado de atribuição definido no início de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="db42a-355">O estado de atribuição definitivo de *v* no início de *Ei* (*i* maior que um) é o mesmo que o estado de atribuição definido no final da subexpressão anterior.</span><span class="sxs-lookup"><span data-stu-id="db42a-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="db42a-356">O estado de atribuição definitivo de *v* no final de *expr* é igual ao estado de atribuição definido no final de *en*</span><span class="sxs-lookup"><span data-stu-id="db42a-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="db42a-357">Expressões de invocação e expressões de criação de objeto</span><span class="sxs-lookup"><span data-stu-id="db42a-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="db42a-358">Para uma *expr* de expressão de invocação do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="db42a-359">ou uma expressão de criação de objeto do formulário:</span><span class="sxs-lookup"><span data-stu-id="db42a-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="db42a-360">Para uma expressão de invocação, o estado de atribuição definitivo de *v* antes de *primary_expression* é o mesmo que o estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="db42a-361">Para uma expressão de invocação, o estado de atribuição definitivo de *v* antes de *arg1* é o mesmo que o estado de *v* após *primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="db42a-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="db42a-362">Para uma expressão de criação de objeto, o estado de atribuição definitivo de *v* antes de *arg1* é o mesmo que o estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="db42a-363">Para cada argumento *Argi*, o estado de atribuição definitivo de *v* após *Argi* é determinado pelas regras de expressão normal, `ref` ignorando quaisquer modificadores ou `out` .</span><span class="sxs-lookup"><span data-stu-id="db42a-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="db42a-364">Para cada argumento *Argi* para qualquer *i* maior que um, o estado de atribuição definitivo de *v* antes de *Argi* é o mesmo que o estado de *v* após o *ARG*anterior.</span><span class="sxs-lookup"><span data-stu-id="db42a-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="db42a-365">Se a variável *v* for passada como um `out` argumento (ou seja, um argumento do formulário `out v`) em qualquer um dos argumentos, o estado de *v* após *expr* será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="db42a-366">, o estado de *v* After *expr* é o mesmo que o estado de *v* após *argN*.</span><span class="sxs-lookup"><span data-stu-id="db42a-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="db42a-367">Para inicializadores de matriz ([expressões de criação de matriz](expressions.md#array-creation-expressions)), inicializadores de objeto ([inicializadores de objeto](expressions.md#object-initializers)), inicializadores de coleção ([inicializadores de coleção](expressions.md#collection-initializers)) e inicializadores de objeto anônimos (criação de[objeto anônimo expressões](expressions.md#anonymous-object-creation-expressions)), o estado de atribuição definitivo é determinado pela expansão de que essas construções são definidas em termos de.</span><span class="sxs-lookup"><span data-stu-id="db42a-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="db42a-368">Expressões de atribuição simples</span><span class="sxs-lookup"><span data-stu-id="db42a-368">Simple assignment expressions</span></span>

<span data-ttu-id="db42a-369">Para uma *expr* de expressão do formulário `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="db42a-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="db42a-370">O estado de atribuição definitivo de *v* antes de *expr_rhs* é o mesmo que o estado de atribuição definido de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="db42a-371">O estado de atribuição definitivo de *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="db42a-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="db42a-372">Se *w* for a mesma variável que *v*, o estado de atribuição definitivo de *v* após *expr* será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="db42a-373">Caso contrário, se a atribuição ocorrer dentro do construtor de instância de um tipo de struct, se *w* for um acesso de propriedade que designa uma propriedade automaticamente implementada *P* na instância que está sendo construída e *v* for o campo de apoio oculto de *P*. em seguida, o estado de atribuição definitiva de *v* após *expr* é atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="db42a-374">Caso contrário, o estado de atribuição definitivo de *v* após *expr* será o mesmo que o estado de atribuição definido de *v* após *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="db42a-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="db42a-375">& & (condicional e) expressões</span><span class="sxs-lookup"><span data-stu-id="db42a-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="db42a-376">Para uma *expr* de expressão do formulário `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="db42a-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="db42a-377">O estado de atribuição definitivo de *v* antes de *expr_first* é o mesmo que o estado de atribuição definido de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="db42a-378">O estado de atribuição definitivo de *v* antes de *expr_second* será definitivamente atribuído se o estado de *v* após *expr_first* for definitivamente atribuído ou "definitivamente atribuído após a expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="db42a-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="db42a-379">Caso contrário, ele não é definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="db42a-380">O estado de atribuição definitivo de *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="db42a-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="db42a-381">Se *expr_first* for uma expressão constante com o valor `false`, o estado de atribuição definitivo de *v* após *expr* será o mesmo que o estado de atribuição definido de *v* após *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="db42a-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="db42a-382">Caso contrário, se o estado de *v* após *expr_first* for definitivamente atribuído, o estado de *v* após *expr* será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="db42a-383">Caso contrário, se o estado de *v* após *expr_second* for definitivamente atribuído, e o estado *de v* após *expr_first* for "definitivamente atribuído após expressão falsa", o estado de *v* após *expr* será definitivamente associada.</span><span class="sxs-lookup"><span data-stu-id="db42a-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="db42a-384">Caso contrário, se o estado de *v* após *expr_second* for definitivamente atribuído ou "definitivamente atribuído após a expressão verdadeira", o estado de *v* após *expr* será "definitivamente atribuído após a expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="db42a-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="db42a-385">Caso contrário, se o estado de *v* após *expr_first* for "definitivamente atribuído após a expressão falsa", e o estado de *v* após *expr_second* for "definitivamente atribuído após a expressão falsa", o estado de *v* após  *expr* é "definitivamente atribuída após expressão falsa".</span><span class="sxs-lookup"><span data-stu-id="db42a-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="db42a-386">Caso contrário, o estado de *v* após *expr* não será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="db42a-387">No exemplo</span><span class="sxs-lookup"><span data-stu-id="db42a-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="db42a-388">a variável `i` é considerada definitivamente atribuída em uma das instruções inseridas de uma `if` instrução, mas não no outro.</span><span class="sxs-lookup"><span data-stu-id="db42a-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="db42a-389">Na instrução no método `F`, a variável `i` é definitivamente atribuída na primeira instrução inserida porque a execução da expressão `(i = y)` sempre precede a execução dessa instrução inserida. `if`</span><span class="sxs-lookup"><span data-stu-id="db42a-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="db42a-390">Por outro lado, a `i` variável não é definitivamente atribuída na segunda instrução incorporada, `x >= 0` pois pode ter testado false, resultando na `i` não atribuição da variável.</span><span class="sxs-lookup"><span data-stu-id="db42a-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="db42a-391">|| expressões (condicionais ou)</span><span class="sxs-lookup"><span data-stu-id="db42a-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="db42a-392">Para uma *expr* de expressão do formulário `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="db42a-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="db42a-393">O estado de atribuição definitivo de *v* antes de *expr_first* é o mesmo que o estado de atribuição definido de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="db42a-394">O estado de atribuição definitivo de *v* antes de *expr_second* será definitivamente atribuído se o estado de *v* após *expr_first* for definitivamente atribuído ou "definitivamente atribuído após expressão falsa".</span><span class="sxs-lookup"><span data-stu-id="db42a-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="db42a-395">Caso contrário, ele não é definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="db42a-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="db42a-396">A instrução de atribuição definitiva de *v* após *expr* é determinada por:</span><span class="sxs-lookup"><span data-stu-id="db42a-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="db42a-397">Se *expr_first* for uma expressão constante com o valor `true`, o estado de atribuição definitivo de *v* após *expr* será o mesmo que o estado de atribuição definido de *v* após *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="db42a-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="db42a-398">Caso contrário, se o estado de *v* após *expr_first* for definitivamente atribuído, o estado de *v* após *expr* será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="db42a-399">Caso contrário, se o estado de *v* após *expr_second* for definitivamente atribuído, e o estado *de v* após *expr_first* for "definitivamente atribuído após a expressão verdadeira", o estado de *v* após *expr* será definitivamente associada.</span><span class="sxs-lookup"><span data-stu-id="db42a-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="db42a-400">Caso contrário, se o estado de *v* após *expr_second* for definitivamente atribuído ou "definitivamente atribuído após a expressão falsa", o estado de *v* após *expr* será "definitivamente atribuído após a expressão falsa".</span><span class="sxs-lookup"><span data-stu-id="db42a-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="db42a-401">Caso contrário, se o estado de *v* após *expr_first* for "definitivamente atribuído após a expressão verdadeira", e o estado de *v* após *expr_second* for "definitivamente atribuído após a expressão verdadeira", o estado de *v* após *expr* é "definitivamente atribuído após expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="db42a-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="db42a-402">Caso contrário, o estado de *v* após *expr* não será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="db42a-403">No exemplo</span><span class="sxs-lookup"><span data-stu-id="db42a-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="db42a-404">a variável `i` é considerada definitivamente atribuída em uma das instruções inseridas de uma `if` instrução, mas não no outro.</span><span class="sxs-lookup"><span data-stu-id="db42a-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="db42a-405">Na instrução no método `G`, a variável `i` é definitivamente atribuída na segunda instrução inserida porque a execução da expressão `(i = y)` sempre precede a execução dessa instrução inserida. `if`</span><span class="sxs-lookup"><span data-stu-id="db42a-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="db42a-406">Por outro lado, a `i` variável não é definitivamente atribuída na primeira instrução inserida, `x >= 0` pois pode ter testado verdadeiro, resultando na `i` não atribuição da variável.</span><span class="sxs-lookup"><span data-stu-id="db42a-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="db42a-407">!</span><span class="sxs-lookup"><span data-stu-id="db42a-407">!</span></span> <span data-ttu-id="db42a-408">(negação lógica) expressões</span><span class="sxs-lookup"><span data-stu-id="db42a-408">(logical negation) expressions</span></span>

<span data-ttu-id="db42a-409">Para uma *expr* de expressão do formulário `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="db42a-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="db42a-410">O estado de atribuição definitivo de *v* antes de *expr_operand* é o mesmo que o estado de atribuição definido de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="db42a-411">O estado de atribuição definitivo de *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="db42a-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="db42a-412">Se o estado de *v* After \* expr_operand \* for definitivamente atribuído, o estado de *v* após *expr* será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="db42a-413">Se o estado de *v* After \* expr_operand \* não for definitivamente atribuído, o estado de *v* após *expr* não será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="db42a-414">Se o estado de *v* After \* expr_operand \* for "definitivamente atribuído após a expressão falsa", o estado de *v* após *expr* será "definitivamente atribuído após a expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="db42a-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="db42a-415">Se o estado de *v* After \* expr_operand \* for "definitivamente atribuído após a expressão verdadeira", o estado de *v* após *expr* será "definitivamente atribuído após a expressão falsa".</span><span class="sxs-lookup"><span data-stu-id="db42a-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="db42a-416">??</span><span class="sxs-lookup"><span data-stu-id="db42a-416">??</span></span> <span data-ttu-id="db42a-417">(União nula) expressões</span><span class="sxs-lookup"><span data-stu-id="db42a-417">(null coalescing) expressions</span></span>

<span data-ttu-id="db42a-418">Para uma *expr* de expressão do formulário `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="db42a-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="db42a-419">O estado de atribuição definitivo de *v* antes de *expr_first* é o mesmo que o estado de atribuição definido de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="db42a-420">O estado de atribuição definitivo de *v* antes de *expr_second* é o mesmo que o estado de atribuição definido de *v* após *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="db42a-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="db42a-421">A instrução de atribuição definitiva de *v* após *expr* é determinada por:</span><span class="sxs-lookup"><span data-stu-id="db42a-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="db42a-422">Se *expr_first* for uma expressão constante ([expressões constantes](expressions.md#constant-expressions)) com o valor NULL, o estado de *v* After *expr* será o mesmo que o estado de *v* após *expr_second*.</span><span class="sxs-lookup"><span data-stu-id="db42a-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="db42a-423">Caso contrário, o estado de *v* After *expr* será o mesmo que o estado de atribuição definido de *v* após *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="db42a-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="db42a-424">expressões?: (condicionais)</span><span class="sxs-lookup"><span data-stu-id="db42a-424">?: (conditional) expressions</span></span>

<span data-ttu-id="db42a-425">Para uma *expr* de expressão do formulário `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="db42a-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="db42a-426">O estado de atribuição definitivo de *v* antes de *expr_cond* é o mesmo que o estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="db42a-427">O estado de atribuição definitivo de *v* antes de *expr_true* é definitivamente atribuído se e somente se uma das seguintes isenções:</span><span class="sxs-lookup"><span data-stu-id="db42a-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="db42a-428">*expr_cond* é uma expressão constante com o valor`false`</span><span class="sxs-lookup"><span data-stu-id="db42a-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="db42a-429">o estado de *v* após *expr_cond* é definitivamente atribuído ou "definitivamente atribuído após a expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="db42a-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="db42a-430">O estado de atribuição definitivo de *v* antes de *expr_false* é definitivamente atribuído se e somente se uma das seguintes isenções:</span><span class="sxs-lookup"><span data-stu-id="db42a-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="db42a-431">*expr_cond* é uma expressão constante com o valor`true`</span><span class="sxs-lookup"><span data-stu-id="db42a-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="db42a-432">o estado de *v* após *expr_cond* é definitivamente atribuído ou "definitivamente atribuído após expressão falsa".</span><span class="sxs-lookup"><span data-stu-id="db42a-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="db42a-433">O estado de atribuição definitivo de *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="db42a-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="db42a-434">Se *expr_cond* for uma expressão constante ([expressões constantes](expressions.md#constant-expressions)) com valor `true` , o estado de *v* após *expr* será o mesmo que o estado de *v* após *expr_true*.</span><span class="sxs-lookup"><span data-stu-id="db42a-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="db42a-435">Caso contrário, *se expr_cond* for uma expressão constante[(expressões constantes](expressions.md#constant-expressions)) com `false` valor, o estado *de v* após *expr* será o mesmo que o estado de *v* após *expr_false*.</span><span class="sxs-lookup"><span data-stu-id="db42a-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="db42a-436">Caso contrário, se o estado de *v* após *expr_true* for definitivamente atribuído e o estado de *v* depois de *expr_false* for definitivamente atribuído, o estado de *v* após *expr* será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="db42a-437">Caso contrário, o estado de *v* após *expr* não será atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="db42a-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="db42a-438">Funções anônimas</span><span class="sxs-lookup"><span data-stu-id="db42a-438">Anonymous functions</span></span>

<span data-ttu-id="db42a-439">Para uma *expr* *lambda_expression* ou *anonymous_method_expression* com um corpo ( *bloco* ou *expressão*) *corpo*:</span><span class="sxs-lookup"><span data-stu-id="db42a-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="db42a-440">O estado de atribuição definitivo de uma variável externa *v* para o *corpo* é o mesmo que o estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="db42a-441">Ou seja, o estado de atribuição definitivo de variáveis externas é herdado do contexto da função anônima.</span><span class="sxs-lookup"><span data-stu-id="db42a-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="db42a-442">O estado de atribuição definitivo de uma variável externa *v* depois de *expr* é o mesmo que o estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="db42a-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="db42a-443">O exemplo</span><span class="sxs-lookup"><span data-stu-id="db42a-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="db42a-444">gera um erro de tempo de compilação `max` porque não é definitivamente atribuído onde a função anônima é declarada.</span><span class="sxs-lookup"><span data-stu-id="db42a-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="db42a-445">O exemplo</span><span class="sxs-lookup"><span data-stu-id="db42a-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="db42a-446">também gera um erro de tempo de compilação porque a atribuição `n` para na função anônima não tem nenhum efeito sobre o estado de atribuição `n` definitivo de fora da função anônima.</span><span class="sxs-lookup"><span data-stu-id="db42a-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="db42a-447">Referências de variáveis</span><span class="sxs-lookup"><span data-stu-id="db42a-447">Variable references</span></span>

<span data-ttu-id="db42a-448">Um *variable_reference* é uma *expressão* que é classificada como uma variável.</span><span class="sxs-lookup"><span data-stu-id="db42a-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="db42a-449">Um *variable_reference* denota um local de armazenamento que pode ser acessado para buscar o valor atual e para armazenar um novo valor.</span><span class="sxs-lookup"><span data-stu-id="db42a-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="db42a-450">Em C e C++, um *variable_reference* é conhecido como um *lvalue*.</span><span class="sxs-lookup"><span data-stu-id="db42a-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="db42a-451">Atomicidade de referências de variáveis</span><span class="sxs-lookup"><span data-stu-id="db42a-451">Atomicity of variable references</span></span>

<span data-ttu-id="db42a-452">Leituras e gravações dos seguintes tipos de dados são Atomic: `bool`, `char`, `byte`, `sbyte` `int` `ushort` `short`,,, `uint`,, `float`e tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="db42a-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="db42a-453">Além disso, leituras e gravações de tipos de enumeração com um tipo subjacente na lista anterior também são atômicas.</span><span class="sxs-lookup"><span data-stu-id="db42a-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="db42a-454">As leituras e gravações de outros tipos, `long`incluindo `ulong` `double`,, e `decimal`, bem como tipos definidos pelo usuário, não têm garantia de serem atômicas.</span><span class="sxs-lookup"><span data-stu-id="db42a-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="db42a-455">Além das funções de biblioteca projetadas para essa finalidade, não há nenhuma garantia de leitura-modificação-gravação atômica, como no caso de incremento ou decréscimo.</span><span class="sxs-lookup"><span data-stu-id="db42a-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>


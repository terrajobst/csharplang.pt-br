---
ms.openlocfilehash: b7bb7dd575d9e2e6d5dd85bdd3e535411e29fcf4
ms.sourcegitcommit: 3fc033b6e98ed7ecdf46a85c79b00a3a3ddcf963
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/18/2019
ms.locfileid: "47229480"
---
# <a name="variables"></a><span data-ttu-id="6bcf4-101">Variáveis</span><span class="sxs-lookup"><span data-stu-id="6bcf4-101">Variables</span></span>

<span data-ttu-id="6bcf4-102">As variáveis representam os locais de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-102">Variables represent storage locations.</span></span> <span data-ttu-id="6bcf4-103">Cada variável tem um tipo que determina quais valores podem ser armazenados na variável.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="6bcf4-104">C# é uma linguagem fortemente tipada e o compilador C# garante que os valores armazenados em variáveis são sempre do tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="6bcf4-105">O valor de uma variável pode ser alterado por meio de atribuição ou por meio do uso do `++` e `--` operadores.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="6bcf4-106">Uma variável deve ser ***definitivamente atribuído*** ([atribuição definitiva](variables.md#definite-assignment)) antes de seu valor pode ser obtido.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="6bcf4-107">Conforme descrito nas seções a seguir, as variáveis são ***inicialmente atribuída*** ou ***atribuídas inicialmente***.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="6bcf4-108">Uma variável inicialmente atribuída tem um valor inicial bem definido e é sempre considerado definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="6bcf4-109">Uma variável não atribuída inicialmente não tem nenhum valor inicial.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="6bcf4-110">Para uma variável inicialmente não atribuída a serem considerados definitivamente atribuído em um determinado local, uma atribuição à variável deve ocorrer em todos os caminhos possíveis de execução levando a nesse local.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="6bcf4-111">Categorias variáveis</span><span class="sxs-lookup"><span data-stu-id="6bcf4-111">Variable categories</span></span>

<span data-ttu-id="6bcf4-112">C# define sete categorias de variáveis: variáveis estáticas, variáveis de instância, elementos de matriz, parâmetros de valor, parâmetros de referência, parâmetros de saída e as variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="6bcf4-113">As seções a seguir descrevem cada uma dessas categorias.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="6bcf4-114">No exemplo</span><span class="sxs-lookup"><span data-stu-id="6bcf4-114">In the example</span></span>
```csharp
class A
{
    public static int x;
    int y;

    void F(int[] v, int a, ref int b, out int c) {
        int i = 1;
        c = a + b++;
    }
}
```
<span data-ttu-id="6bcf4-115">`x` é uma variável estática, `y` é uma variável de instância `v[0]` é um elemento de matriz `a` é um parâmetro de valor `b` é um parâmetro de referência `c` é um parâmetro de saída, e `i` é uma variável local.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="6bcf4-116">Variáveis estáticas</span><span class="sxs-lookup"><span data-stu-id="6bcf4-116">Static variables</span></span>

<span data-ttu-id="6bcf4-117">Um campo declarado com o `static` modificador é chamado um ***variável estática***.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="6bcf4-118">Uma variável estática entra em existência antes da execução do construtor estático ([construtores estáticos](classes.md#static-constructors)) para seu tipo recipiente e deixe de existir quando o domínio de aplicativo associado deixa de existir.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="6bcf4-119">O valor inicial de uma variável estática é o valor padrão ([valores padrão](variables.md#default-values)) do tipo da variável.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="6bcf4-120">Para fins de verificação de atribuição definitiva, uma variável estática é considerada inicialmente atribuída.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="6bcf4-121">Variáveis de instância</span><span class="sxs-lookup"><span data-stu-id="6bcf4-121">Instance variables</span></span>

<span data-ttu-id="6bcf4-122">Um campo declarado sem o `static` modificador é chamado um ***variável de instância***.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="6bcf4-123">Variáveis de instância em classes</span><span class="sxs-lookup"><span data-stu-id="6bcf4-123">Instance variables in classes</span></span>

<span data-ttu-id="6bcf4-124">Uma variável de instância de uma classe entra em existência quando uma nova instância dessa classe é criada e deixa de existir quando nenhuma referência a essa instância e o destruidor da instância (se houver) foi executada.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="6bcf4-125">O valor inicial de uma variável de instância de uma classe é o valor padrão ([valores padrão](variables.md#default-values)) do tipo da variável.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="6bcf4-126">Para fins de verificação de atribuição definitiva, uma variável de instância de uma classe é considerada inicialmente atribuída.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="6bcf4-127">Variáveis de instância em structs</span><span class="sxs-lookup"><span data-stu-id="6bcf4-127">Instance variables in structs</span></span>

<span data-ttu-id="6bcf4-128">Uma variável de instância de um struct tem exatamente a mesma duração como a variável de struct ao qual ele pertence.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="6bcf4-129">Em outras palavras, quando uma variável de um tipo de struct entra em existência ou deixa de existir, isso também fazer as variáveis de instância do struct.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="6bcf4-130">O estado de atribuição inicial de uma variável de instância de um struct é o mesmo que a variável que contém de struct.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="6bcf4-131">Em outras palavras, quando uma variável de struct é considerada inicialmente atribuída, isso também são suas variáveis de instância e quando uma variável de struct é considerada inicialmente não atribuída, suas variáveis de instância da mesma forma são não atribuídos.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="6bcf4-132">Elementos de matriz</span><span class="sxs-lookup"><span data-stu-id="6bcf4-132">Array elements</span></span>

<span data-ttu-id="6bcf4-133">Os elementos de uma matriz passam a existir quando uma instância de matriz é criada e deixam de existir quando não houver nenhuma referência a essa instância de matriz.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="6bcf4-134">O valor inicial de cada um dos elementos de uma matriz é o valor padrão ([valores padrão](variables.md#default-values)) do tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="6bcf4-135">Para fins de verificação de atribuição definitiva, um elemento de matriz é considerado inicialmente atribuída.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="6bcf4-136">Parâmetros de valor</span><span class="sxs-lookup"><span data-stu-id="6bcf4-136">Value parameters</span></span>

<span data-ttu-id="6bcf4-137">Um parâmetro declarado sem um `ref` ou `out` modificador é um ***parâmetro value***.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="6bcf4-138">Um parâmetro de valor entra em existência mediante invocação do membro da função (método, construtor de instância, acessador ou operador) ou da função anônima para o qual o parâmetro pertence e é inicializado com o valor do argumento fornecido na invocação.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="6bcf4-139">Um parâmetro de valor normalmente deixa de existir após o retorno do membro da função ou função anônima.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="6bcf4-140">No entanto, se o parâmetro de valor é capturado por uma função anônima ([expressões de função anônima](expressions.md#anonymous-function-expressions)), seu tempo de vida se estende de pelo menos até que o delegado ou árvore de expressão criada a partir dessa função anônima é elegível para coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="6bcf4-141">Para fins de verificação de atribuição definitiva, um parâmetro de valor é considerado inicialmente atribuída.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="6bcf4-142">Parâmetros de referência</span><span class="sxs-lookup"><span data-stu-id="6bcf4-142">Reference parameters</span></span>

<span data-ttu-id="6bcf4-143">Um parâmetro declarado com um `ref` modificador é uma ***parâmetro de referência***.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="6bcf4-144">Um parâmetro de referência não cria um novo local de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="6bcf4-145">Em vez disso, um parâmetro de referência representa o mesmo local de armazenamento como a variável fornecido como o argumento na chamada de função anônima ou membro da função.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="6bcf4-146">Portanto, o valor de um parâmetro de referência é sempre o mesmo que a variável subjacente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="6bcf4-147">As regras de atribuição definitiva a seguir se aplicam a parâmetros de referência.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="6bcf4-148">Observe as regras diferentes para parâmetros de saída, descritos em [parâmetros de saída](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="6bcf4-149">Uma variável deve ser definitivamente atribuída ([atribuição definitiva](variables.md#definite-assignment)) antes que ela pode ser passada como um parâmetro de referência em uma invocação de delegado ou de membro de função.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="6bcf4-150">Dentro de um membro da função ou função anônima, um parâmetro de referência é considerado inicialmente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="6bcf4-151">Dentro de um método de instância ou o acessador de instância de um tipo de struct, o `this` palavra-chave se comporta exatamente como um parâmetro de referência do tipo struct ([esse acesso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="6bcf4-152">Parâmetros de saída</span><span class="sxs-lookup"><span data-stu-id="6bcf4-152">Output parameters</span></span>

<span data-ttu-id="6bcf4-153">Um parâmetro declarado com um `out` modificador é um ***parâmetro de saída***.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="6bcf4-154">Um parâmetro de saída não cria um novo local de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="6bcf4-155">Em vez disso, um parâmetro de saída representa o mesmo local de armazenamento como a variável fornecido como o argumento na invocação de delegado ou de membro da função.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="6bcf4-156">Portanto, o valor de um parâmetro de saída é sempre o mesmo que a variável subjacente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="6bcf4-157">As regras de atribuição definitiva a seguir se aplicam a parâmetros de saída.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="6bcf4-158">Observe as regras diferentes para parâmetros de referência, descritos em [fazer referência a parâmetros](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="6bcf4-159">Uma variável não precisa ser definitivamente atribuída antes que ele pode ser passado como um parâmetro de saída em um membro da função ou invocação de delegado.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="6bcf4-160">Após a conclusão normal de uma invocação de delegado ou de membro de função, cada variável que foi passado como um parâmetro de saída é considerado atribuído nesse caminho de execução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="6bcf4-161">Dentro de um membro da função ou função anônima, um parâmetro de saída é considerado inicialmente não atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="6bcf4-162">Cada parâmetro de saída de um membro da função ou função anônima deve ser definitivamente atribuído ([atribuição definitiva](variables.md#definite-assignment)) antes da função de membro ou função anônima retorna normalmente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="6bcf4-163">Dentro de um construtor de instância de um tipo de struct, o `this` palavra-chave se comporta exatamente como um parâmetro de saída do tipo struct ([esse acesso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="6bcf4-164">Variáveis locais</span><span class="sxs-lookup"><span data-stu-id="6bcf4-164">Local variables</span></span>

<span data-ttu-id="6bcf4-165">Um ***variável local*** é declarado por uma *local_variable_declaration*, que podem ocorrer em um *bloco*, um *for_statement*, um *switch_statement* ou um *using_statement*; ou por um *foreach_statement* ou uma *specific_catch_clause* para um *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="6bcf4-166">O tempo de vida de uma variável local é a parte da execução do programa durante o qual o armazenamento é garantido para ser reservado para ele.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="6bcf4-167">Esse tempo de vida se estende de pelo menos de entrada para o *bloco*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, ou *specific_catch_clause* à qual ele está associado, até a execução desse *bloco*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, ou *specific_catch_clause* extremidades de qualquer forma.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="6bcf4-168">(Inserir um contido *bloco* ou chamar um método suspende, mas não termina a execução do atual *bloco*, *for_statement*, *switch_statement* , *using_statement*, *foreach_statement*, ou *specific_catch_clause*.) Se a variável local é capturada por uma função anônima ([capturados variáveis externas](expressions.md#captured-outer-variables)), seu tempo de vida se estende de pelo menos até que a árvore de expressão ou delegado criada a partir da função anônima, juntamente com quaisquer outros objetos que vêm para fazer referência à variável capturada, está qualificado para coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="6bcf4-169">Se o pai *bloco*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, ou *specific_catch_clause* é inserido recursivamente, uma nova instância da variável local é criada cada vez e seu *local_variable_initializer*, se houver, é avaliada cada vez.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="6bcf4-170">Uma variável local introduzida por uma *local_variable_declaration* não é inicializado automaticamente e, portanto, não tem valor padrão.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="6bcf4-171">Para fins de verificação de atribuição definitiva, uma variável local introduzidos por uma *local_variable_declaration* é considerado inicialmente não atribuídas.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="6bcf4-172">Um *local_variable_declaration* pode incluir uma *local_variable_initializer*, caso em que a variável é considerada definitivamente atribuída apenas após a expressão de inicialização ([ Instruções de declaração](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="6bcf4-173">Dentro do escopo de uma variável local introduzido por uma *local_variable_declaration*, ele é um erro de tempo de compilação para se referir a essa variável local em uma posição textual que precede seu *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="6bcf4-174">Se a declaração de variável local é implícita ([declarações de variável Local](statements.md#local-variable-declarations)), também é um erro ao fazer referência à variável dentro do seu *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="6bcf4-175">Uma variável local introduzida por uma *foreach_statement* ou um *specific_catch_clause* é considerado atribuído definitivamente em seu escopo inteiro.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="6bcf4-176">O tempo de vida real de uma variável local é dependente de implementação.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="6bcf4-177">Por exemplo, um compilador estaticamente pode determinar que uma variável local em um bloco só é usada para uma pequena parte desse bloco.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="6bcf4-178">Usando essa análise, o compilador pode gerar código que resulta em ter um tempo de vida mais curto que o bloco de armazenamento da variável.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="6bcf4-179">O armazenamento referenciado por uma variável de referência local seja recuperado, independentemente do tempo de vida da variável local de referência ([gerenciamento automático de memória](basic-concepts.md#automatic-memory-management)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="6bcf4-180">Valores padrão</span><span class="sxs-lookup"><span data-stu-id="6bcf4-180">Default values</span></span>

<span data-ttu-id="6bcf4-181">As seguintes categorias de variáveis são inicializadas automaticamente para seus valores padrão:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="6bcf4-182">Variáveis estáticas.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-182">Static variables.</span></span>
*  <span data-ttu-id="6bcf4-183">Variáveis de instância de instâncias de classes.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="6bcf4-184">Elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-184">Array elements.</span></span>

<span data-ttu-id="6bcf4-185">O valor padrão de uma variável depende do tipo da variável e é determinado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="6bcf4-186">Para uma variável de um *value_type*, o valor padrão é o mesmo que o valor calculado pelo *value_type*do construtor padrão ([1&gt;construtores padrão](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="6bcf4-187">Para uma variável de um *reference_type*, o valor padrão é `null`.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="6bcf4-188">Inicialização para valores padrão normalmente é feita fazendo com que o Gerenciador de memória ou o coletor de lixo inicializar a memória para todos os bits-zero antes que ele é alocado para uso.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="6bcf4-189">Por esse motivo, é conveniente usar zeros bits para representar a referência nula.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="6bcf4-190">Atribuição definida</span><span class="sxs-lookup"><span data-stu-id="6bcf4-190">Definite assignment</span></span>

<span data-ttu-id="6bcf4-191">Em um determinado local no código executável de um membro da função, uma variável é considerada ***definitivamente atribuído*** se o compilador pode comprovar a análise de fluxo estático particular ([precisas regras para determinar definitiva atribuição](variables.md#precise-rules-for-determining-definite-assignment)), que a variável foi inicializada automaticamente ou foi o destino de pelo menos uma atribuição.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="6bcf4-192">As regras de atribuição definitiva informalmente mencionado, são:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="6bcf4-193">Uma variável inicialmente atribuída ([inicialmente atribuída variáveis](variables.md#initially-assigned-variables)) é sempre considerado atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="6bcf4-194">Uma variável não atribuída inicialmente ([inicialmente não atribuídos a variáveis](variables.md#initially-unassigned-variables)) é considerado definitivamente atribuído em um determinado local se todos os possíveis caminhos de execução levando a esse local contém pelo menos um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="6bcf4-195">Uma atribuição simples ([atribuição simples](expressions.md#simple-assignment)) no qual a variável é o operando esquerdo.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="6bcf4-196">Uma expressão de invocação ([expressões de invocação](expressions.md#invocation-expressions)) ou uma expressão de criação de objeto ([expressões de criação do objeto](expressions.md#object-creation-expressions)) que passa a variável como um parâmetro de saída.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="6bcf4-197">Para uma variável local, uma declaração de variável local ([declarações de variável Local](statements.md#local-variable-declarations)) que inclui um inicializador de variável.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="6bcf4-198">A especificação formal subjacente informais regras acima é descrita em [inicialmente atribuída variáveis](variables.md#initially-assigned-variables), [inicialmente não atribuídos a variáveis](variables.md#initially-unassigned-variables), e [precisas regras para determinar atribuição definitiva](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="6bcf4-199">Os estados de atribuição definitiva de variáveis de instância de um *struct_type* variável são controladas individualmente, bem como coletivamente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="6bcf4-200">Em adicional para as regras acima, as seguintes regras se aplicam a *struct_type* variáveis e suas variáveis de instância:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-200">In additional to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="6bcf4-201">Uma variável de instância é considerada atribuída definitivamente se contendo seu *struct_type* variável é considerada atribuída definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="6bcf4-202">Um *struct_type* variável é considerada atribuída definitivamente se cada uma das suas variáveis de instância é considerada atribuída definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="6bcf4-203">Atribuição definida é um requisito nos seguintes contextos:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="6bcf4-204">Uma variável deve ser definitivamente atribuída em cada local em que seu valor é obtido.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="6bcf4-205">Isso garante que nunca ocorrerem valores indefinidos.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="6bcf4-206">A ocorrência de uma variável em uma expressão é considerada para obter o valor da variável, exceto quando</span><span class="sxs-lookup"><span data-stu-id="6bcf4-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="6bcf4-207">a variável é o operando esquerdo de uma atribuição simples,</span><span class="sxs-lookup"><span data-stu-id="6bcf4-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="6bcf4-208">a variável é passada como um parâmetro de saída, ou</span><span class="sxs-lookup"><span data-stu-id="6bcf4-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="6bcf4-209">a variável é uma *struct_type* variável e ocorre como o operando esquerdo de um acesso de membro.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="6bcf4-210">Uma variável deve ser definitivamente atribuída em cada local em que ele é passado como um parâmetro de referência.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="6bcf4-211">Isso garante que o membro da função que está sendo invocado pode considerar o parâmetro de referência que inicialmente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="6bcf4-212">Todos os parâmetros de saída de um membro da função devem ser definitivamente atribuídos em cada local em que retorna o membro da função (por meio de um `return` instrução ou por meio de atingir o final do corpo de membro da função de execução).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="6bcf4-213">Isso garante que os membros da função não retornam valores indefinidos em parâmetros de saída, permitindo que o compilador considere uma invocação de membro de função que usa uma variável como um parâmetro de saída equivalente a uma atribuição à variável.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="6bcf4-214">O `this` variável de um *struct_type* construtor de instância deve ser definitivamente atribuído em cada local em que esse construtor de instância retorna.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="6bcf4-215">Variáveis atribuídas inicialmente</span><span class="sxs-lookup"><span data-stu-id="6bcf4-215">Initially assigned variables</span></span>

<span data-ttu-id="6bcf4-216">As seguintes categorias de variáveis são classificadas como inicialmente atribuída:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="6bcf4-217">Variáveis estáticas.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-217">Static variables.</span></span>
*  <span data-ttu-id="6bcf4-218">Variáveis de instância de instâncias de classes.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="6bcf4-219">Variáveis de instância de variáveis de struct inicialmente atribuída.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="6bcf4-220">Elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-220">Array elements.</span></span>
*  <span data-ttu-id="6bcf4-221">Parâmetros de valor.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-221">Value parameters.</span></span>
*  <span data-ttu-id="6bcf4-222">Parâmetros de referência.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-222">Reference parameters.</span></span>
*  <span data-ttu-id="6bcf4-223">Variáveis declaradas em uma `catch` cláusula ou um `foreach` instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="6bcf4-224">Variáveis inicialmente não atribuídas</span><span class="sxs-lookup"><span data-stu-id="6bcf4-224">Initially unassigned variables</span></span>

<span data-ttu-id="6bcf4-225">As seguintes categorias de variáveis são classificadas como inicialmente não atribuídas:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="6bcf4-226">Variáveis de instância de struct atribuídas inicialmente variáveis.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="6bcf4-227">Parâmetros de saída, incluindo o `this` variável dos construtores de instância de struct.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="6bcf4-228">Variáveis locais, exceto aqueles declarados em uma `catch` cláusula ou um `foreach` instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="6bcf4-229">Precisas regras para determinar a atribuição definida</span><span class="sxs-lookup"><span data-stu-id="6bcf4-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="6bcf4-230">Para determinar o que cada variável usada é definitivamente atribuído, o compilador deve usar um processo que é equivalente ao descrito nesta seção.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="6bcf4-231">O compilador processa o corpo de cada membro da função que tem uma ou mais variáveis atribuídas inicialmente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="6bcf4-232">Para cada variável inicialmente não atribuída *v*, o compilador determina uma ***estado de atribuição definitiva*** para *v* em cada um dos pontos a seguir no membro da função:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="6bcf4-233">No início de cada instrução</span><span class="sxs-lookup"><span data-stu-id="6bcf4-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="6bcf4-234">No ponto de extremidade ([pontos de extremidade e acessibilidade](statements.md#end-points-and-reachability)) de cada instrução</span><span class="sxs-lookup"><span data-stu-id="6bcf4-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="6bcf4-235">Em cada arco que transfere o controle para outra instrução ou para o ponto de extremidade de uma instrução</span><span class="sxs-lookup"><span data-stu-id="6bcf4-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="6bcf4-236">No início de cada expressão</span><span class="sxs-lookup"><span data-stu-id="6bcf4-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="6bcf4-237">No final de cada expressão</span><span class="sxs-lookup"><span data-stu-id="6bcf4-237">At the end of each expression</span></span>

<span data-ttu-id="6bcf4-238">O estado de atribuição definitiva da *v* pode ser:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="6bcf4-239">Definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-239">Definitely assigned.</span></span> <span data-ttu-id="6bcf4-240">Isso indica que em todos os fluxos de controle possíveis para esse ponto *v* foi atribuído um valor.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="6bcf4-241">Não atribuído definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-241">Not definitely assigned.</span></span> <span data-ttu-id="6bcf4-242">Para o estado de uma variável no final de uma expressão do tipo `bool`, o estado de uma variável que não é atribuída definitivamente maio (mas não necessariamente) se enquadram em um dos seguintes estados de subpropriedades:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="6bcf4-243">Definitivamente atribuído após a expressão verdadeira.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="6bcf4-244">Este estado indica que *v* é atribuída definitivamente se a expressão booliana avaliada como verdadeira, mas não é necessariamente atribuída se a expressão booliana avaliada como false.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="6bcf4-245">Definitivamente atribuído após a expressão de false.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="6bcf4-246">Este estado indica que *v* é atribuída definitivamente se a expressão booliana avaliada como false, mas não é necessariamente atribuída se a expressão booliana avaliada como verdadeira.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="6bcf4-247">As seguintes regras regem como o estado de uma variável *v* é determinado em cada local.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="6bcf4-248">Regras gerais para instruções</span><span class="sxs-lookup"><span data-stu-id="6bcf4-248">General rules for statements</span></span>

*  <span data-ttu-id="6bcf4-249">*v* não está definitivamente atribuída no início do corpo da função membro.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="6bcf4-250">*v* é definitivamente atribuída no início de qualquer instrução inacessível.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="6bcf4-251">O estado de atribuição definitiva da *v* no início de qualquer outra instrução é determinada verificando o estado de atribuição definitiva da *v* em todas as transferências de fluxo de controle que direcionam o início do que instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="6bcf4-252">Se (e somente se) *v* é atribuída definitivamente em todas essas transferências de fluxo de controle, em seguida, *v* é definitivamente atribuída no início da instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="6bcf4-253">O conjunto de transferências de fluxo de controle possíveis é determinado da mesma forma que para verificação de acessibilidade de instrução ([pontos de extremidade e acessibilidade](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="6bcf4-254">O estado de atribuição definitiva da *v* no ponto de extremidade de um bloco `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, ou `switch` é determinado pela verificação do estado de atribuição definitiva de *v* em todas as transferências de fluxo de controle que o ponto de extremidade dessa instrução de destino.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="6bcf4-255">Se *v* é atribuída definitivamente em todas essas transferências de fluxo de controle, em seguida, *v* será definitivamente atribuído no ponto de extremidade da instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="6bcf4-256">Caso contrário, *v* não está definitivamente atribuída no ponto de extremidade da instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="6bcf4-257">O conjunto de transferências de fluxo de controle possíveis é determinado da mesma forma que para verificação de acessibilidade de instrução ([pontos de extremidade e acessibilidade](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="6bcf4-258">Instruções de bloco, verificadas e instruções não verificadas</span><span class="sxs-lookup"><span data-stu-id="6bcf4-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="6bcf4-259">O estado de atribuição definitiva da *v* no controle de transferência para a primeira instrução da lista de instruções no bloco (ou até o ponto final do bloco, se a lista de instrução estiver vazia) é o mesmo que a instrução de atribuição definitiva de *v* antes do bloco `checked`, ou `unchecked` instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="6bcf4-260">Instruções de expressão</span><span class="sxs-lookup"><span data-stu-id="6bcf4-260">Expression statements</span></span>

<span data-ttu-id="6bcf4-261">Para uma instrução de expressão *stmt* que consiste a expressão *expr*:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="6bcf4-262">*v* tem o mesmo estado de atribuição definitiva no início de *expr* assim como no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-263">Se *v* se definitivamente atribuída no final da *expr*, será definitivamente atribuído no ponto de extremidade de *stmt*; caso contrário, ele não está definitivamente atribuído no ponto de extremidade de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="6bcf4-264">Instruções de declaração</span><span class="sxs-lookup"><span data-stu-id="6bcf4-264">Declaration statements</span></span>

*  <span data-ttu-id="6bcf4-265">Se *stmt* é uma instrução de declaração sem inicializadores, em seguida, *v* tem o mesmo estado de atribuição definidas no ponto de extremidade de *stmt* assim como no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-266">Se *stmt* é uma instrução de declaração com inicializadores, em seguida, o estado de atribuição definitiva para *v* é determinado como se *stmt* fosse uma lista de instrução, com uma atribuição instrução de cada declaração com um inicializador (na ordem de declaração).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="6bcf4-267">Se as instruções</span><span class="sxs-lookup"><span data-stu-id="6bcf4-267">If statements</span></span>

<span data-ttu-id="6bcf4-268">Para um `if` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="6bcf4-269">*v* tem o mesmo estado de atribuição definitiva no início de *expr* assim como no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-270">Se *v* é definitivamente atribuída no final da *expr*, em seguida, ele é atribuído definitivamente sobre a transferência de fluxo de controle para *then_stmt* para *else_stmt*  ou para o ponto de extremidade da *stmt* se não houver nenhuma cláusula else.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="6bcf4-271">Se *v* tem o estado "definitivamente atribuído após a expressão verdadeira" no final da *expr*, em seguida, ele é atribuído definitivamente sobre a transferência de fluxo de controle para *then_stmt*e não atribuído definitivamente sobre a transferência de fluxo de controle para o *else_stmt* ou para o ponto de extremidade da *stmt* se não houver nenhuma cláusula else.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="6bcf4-272">Se *v* tem o estado "definitivamente atribuído após a expressão false" no final da *expr*, em seguida, ele é atribuído definitivamente sobre a transferência de fluxo de controle para *else_stmt*e não definitivamente atribuído a transferência de fluxo de controle para *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="6bcf4-273">Ele é atribuído definitivamente no ponto de extremidade de *stmt* somente se ele é atribuído definitivamente no ponto de extremidade de *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="6bcf4-274">Caso contrário, *v* é considerada como não atribuído definitivamente sobre a transferência de fluxo de controle para qualquer um os *then_stmt* ou *else_stmt*, ou para o ponto de extremidade de  *stmt* se não houver nenhuma cláusula else.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="6bcf4-275">Instruções switch</span><span class="sxs-lookup"><span data-stu-id="6bcf4-275">Switch statements</span></span>

<span data-ttu-id="6bcf4-276">Em um `switch` instrução *stmt* com uma expressão de controle *expr*:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="6bcf4-277">O estado de atribuição definitiva da *v* no início da *expr* é o mesmo que o estado de *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-278">O estado de atribuição definitiva da *v* no fluxo de controle de transferência para uma lista de instruções do bloco switch acessível é o mesmo que o estado de atribuição definitiva da *v* no final do *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="6bcf4-279">Enquanto as instruções</span><span class="sxs-lookup"><span data-stu-id="6bcf4-279">While statements</span></span>

<span data-ttu-id="6bcf4-280">Para um `while` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="6bcf4-281">*v* tem o mesmo estado de atribuição definitiva no início de *expr* assim como no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-282">Se *v* é definitivamente atribuída no final da *expr*, em seguida, ele é atribuído definitivamente sobre a transferência de fluxo de controle para *while_body* e para o ponto de extremidade de  *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-283">Se *v* tem o estado "definitivamente atribuído após a expressão verdadeira" no final da *expr*, em seguida, ele é atribuído definitivamente sobre a transferência de fluxo de controle para *while_body*, mas não definitivamente atribuídas no ponto de extremidade de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-284">Se *v* tem o estado "definitivamente atribuído após a expressão false" no final da *expr*, em seguida, ele é atribuído definitivamente sobre a transferência de fluxo de controle para o ponto de extremidade de *stmt* , mas não tiver sido atribuído definitivamente sobre a transferência de fluxo de controle para *while_body*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="6bcf4-285">Siga as instruções</span><span class="sxs-lookup"><span data-stu-id="6bcf4-285">Do statements</span></span>

<span data-ttu-id="6bcf4-286">Para um `do` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="6bcf4-287">*v* tem o mesmo estado de atribuição definitiva sobre a transferência de fluxo de controle do início da *stmt* à *do_body* assim como no início da *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-288">*v* tem o mesmo estado de atribuição definitiva no início de *expr* assim como acontece no ponto de extremidade do *do_body*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="6bcf4-289">Se *v* é definitivamente atribuída no final da *expr*, em seguida, ele é atribuído definitivamente sobre a transferência de fluxo de controle para o ponto de extremidade de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-290">Se *v* tem o estado "definitivamente atribuído após a expressão false" no final da *expr*, em seguida, ele é atribuído definitivamente sobre a transferência de fluxo de controle para o ponto de extremidade de *stmt* .</span><span class="sxs-lookup"><span data-stu-id="6bcf4-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="6bcf4-291">Para instruções</span><span class="sxs-lookup"><span data-stu-id="6bcf4-291">For statements</span></span>

<span data-ttu-id="6bcf4-292">Atribuição definitiva procurando um `for` instrução do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="6bcf4-293">é feito como se a instrução estivesse escrita:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-293">is done as if the statement were written:</span></span>
```csharp
{
    for_initializer ;
    while ( for_condition ) {
        embedded_statement ;
        for_iterator ;
    }
}
```

<span data-ttu-id="6bcf4-294">Se o *for_condition* é omitido do `for` instrução e, em seguida, avaliação de atribuição definitiva continua como se *for_condition* foram substituídos por `true` na expansão acima .</span><span class="sxs-lookup"><span data-stu-id="6bcf4-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="6bcf4-295">Interromper, continuar e as instruções goto</span><span class="sxs-lookup"><span data-stu-id="6bcf4-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="6bcf4-296">O estado de atribuição definitiva da *v* sobre a transferência de fluxo de controle causada por uma `break`, `continue`, ou `goto` instrução é o mesmo que o estado de atribuição definitiva da *v* no início da instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="6bcf4-297">Instruções throw</span><span class="sxs-lookup"><span data-stu-id="6bcf4-297">Throw statements</span></span>

<span data-ttu-id="6bcf4-298">Para uma instrução *stmt* do formulário</span><span class="sxs-lookup"><span data-stu-id="6bcf4-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="6bcf4-299">O estado de atribuição definitiva da *v* no início da *expr* é o mesmo que o estado de atribuição definitiva da *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="6bcf4-300">Instruções de retorno</span><span class="sxs-lookup"><span data-stu-id="6bcf4-300">Return statements</span></span>

<span data-ttu-id="6bcf4-301">Para uma instrução *stmt* do formulário</span><span class="sxs-lookup"><span data-stu-id="6bcf4-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="6bcf4-302">O estado de atribuição definitiva da *v* no início da *expr* é o mesmo que o estado de atribuição definitiva da *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-303">Se *v* é um parâmetro de saída, em seguida, ele deve ser definitivamente atribuído:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="6bcf4-304">after *expr*</span><span class="sxs-lookup"><span data-stu-id="6bcf4-304">after *expr*</span></span>
    * <span data-ttu-id="6bcf4-305">ou no final do `finally` block de um `try` - `finally` ou `try` - `catch` - `finally` que circunscreve o `return` instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="6bcf4-306">Para uma instrução INSERT de instrução do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="6bcf4-307">Se *v* é um parâmetro de saída, em seguida, ele deve ser definitivamente atribuído:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="6bcf4-308">antes de *stmt*</span><span class="sxs-lookup"><span data-stu-id="6bcf4-308">before *stmt*</span></span>
    * <span data-ttu-id="6bcf4-309">ou no final do `finally` block de um `try` - `finally` ou `try` - `catch` - `finally` que circunscreve o `return` instrução.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="6bcf4-310">Instruções try-catch</span><span class="sxs-lookup"><span data-stu-id="6bcf4-310">Try-catch statements</span></span>

<span data-ttu-id="6bcf4-311">Para uma instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="6bcf4-312">O estado de atribuição definitiva da *v* no início da *try_block* é o mesmo que o estado de atribuição definitiva da *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-313">O estado de atribuição definitiva da *v* no início da *catch_block_i* (para qualquer *eu*) é o mesmo que o estado de atribuição definitiva de *v*no início de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-314">O estado de atribuição definitiva da *v* no ponto de extremidade de *stmt* é atribuído definitivamente se (e somente se) *v* definitivamente é atribuído no ponto de extremidade de  *try_block* e cada *catch_block_i* (para cada *eu* de 1 a *n*).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="6bcf4-315">Instruções try-finally</span><span class="sxs-lookup"><span data-stu-id="6bcf4-315">Try-finally statements</span></span>

<span data-ttu-id="6bcf4-316">Para um `try` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="6bcf4-317">O estado de atribuição definitiva da *v* no início da *try_block* é o mesmo que o estado de atribuição definitiva da *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-318">O estado de atribuição definitiva da *v* no início da *finally_block* é o mesmo que o estado de atribuição definitiva da *v* no início do *stmt* .</span><span class="sxs-lookup"><span data-stu-id="6bcf4-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-319">O estado de atribuição definitiva da *v* no ponto de extremidade de *stmt* é atribuído definitivamente se (e somente se) pelo menos uma das seguintes opções for verdadeira:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="6bcf4-320">*v* será definitivamente atribuído no ponto de extremidade de *try_block*</span><span class="sxs-lookup"><span data-stu-id="6bcf4-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="6bcf4-321">*v* será definitivamente atribuído no ponto de extremidade de *finally_block*</span><span class="sxs-lookup"><span data-stu-id="6bcf4-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="6bcf4-322">Se uma transferência de fluxo de controle (por exemplo, uma `goto` instrução) que for feita começa dentro *try_block*e termina fora do *try_block*, em seguida, *v* também é considerado atribuído definitivamente nessa transferência de fluxo de controle se *v* é definitivamente atribuídas no ponto de extremidade de *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="6bcf4-323">(Isso não é um somente se — se *v* definitivamente atribuído por outro motivo nessa transferência de fluxo de controle, em seguida, ela ainda será considerada atribuído definitivamente.)</span><span class="sxs-lookup"><span data-stu-id="6bcf4-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="6bcf4-324">Instruções try-catch-finally</span><span class="sxs-lookup"><span data-stu-id="6bcf4-324">Try-catch-finally statements</span></span>

<span data-ttu-id="6bcf4-325">Análise de atribuição definitiva para um `try` - `catch` - `finally` instrução do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="6bcf4-326">é feito como se fosse a instrução de um `try` - `finally` instrução colocando um `try` - `catch` instrução:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
    try try_block
    catch(...) catch_block_1
    ...
    catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="6bcf4-327">O exemplo a seguir demonstra como os blocos diferentes de um `try` instrução ([a instrução try](statements.md#the-try-statement)) afetam atribuição definitiva.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
    static void F() {
        int i, j;
        try {
            goto LABEL;
            // neither i nor j definitely assigned
            i = 1;
            // i definitely assigned
        }

        catch {
            // neither i nor j definitely assigned
            i = 3;
            // i definitely assigned
        }

        finally {
            // neither i nor j definitely assigned
            j = 5;
            // j definitely assigned
            }
        // i and j definitely assigned
        LABEL:;
        // j definitely assigned

    }
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="6bcf4-328">Instruções de foreach</span><span class="sxs-lookup"><span data-stu-id="6bcf4-328">Foreach statements</span></span>

<span data-ttu-id="6bcf4-329">Para um `foreach` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="6bcf4-330">O estado de atribuição definitiva da *v* no início da *expr* é o mesmo que o estado de *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-331">O estado de atribuição definitiva da *v* sobre a transferência de fluxo de controle para *embedded_statement* ou para o ponto de extremidade de *stmt* é o mesmo que o estado do *v* no final do *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="6bcf4-332">Instruções de uso</span><span class="sxs-lookup"><span data-stu-id="6bcf4-332">Using statements</span></span>

<span data-ttu-id="6bcf4-333">Para um `using` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="6bcf4-334">O estado de atribuição definitiva da *v* no início da *resource_acquisition* é o mesmo que o estado de *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-335">O estado de atribuição definitiva da *v* sobre a transferência de fluxo de controle para *embedded_statement* é o mesmo que o estado de *v* no final do *resource_ aquisição*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="6bcf4-336">Instruções de bloqueio</span><span class="sxs-lookup"><span data-stu-id="6bcf4-336">Lock statements</span></span>

<span data-ttu-id="6bcf4-337">Para um `lock` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="6bcf4-338">O estado de atribuição definitiva da *v* no início da *expr* é o mesmo que o estado de *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-339">O estado de atribuição definitiva da *v* sobre a transferência de fluxo de controle para *embedded_statement* é o mesmo que o estado de *v* no final do *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="6bcf4-340">Instruções yield</span><span class="sxs-lookup"><span data-stu-id="6bcf4-340">Yield statements</span></span>

<span data-ttu-id="6bcf4-341">Para um `yield return` instrução *stmt* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="6bcf4-342">O estado de atribuição definitiva da *v* no início da *expr* é o mesmo que o estado de *v* no início do *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6bcf4-343">O estado de atribuição definitiva da *v* no final da *stmt* é o mesmo que o estado de *v* no final da *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="6bcf4-344">Um `yield break` instrução não tem nenhum efeito sobre o estado de atribuição definitiva.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="6bcf4-345">Regras gerais para expressões simples</span><span class="sxs-lookup"><span data-stu-id="6bcf4-345">General rules for simple expressions</span></span>

<span data-ttu-id="6bcf4-346">A regra a seguir se aplica a esses tipos de expressões: literais ([literais](expressions.md#literals)), os nomes simples ([nomes simples](expressions.md#simple-names)), expressões de acesso de membro ([acesso de membro](expressions.md#member-access)), expressões de acesso de base não indexada ([acesso de Base](expressions.md#base-access)), `typeof` expressões ([o operador typeof](expressions.md#the-typeof-operator)), expressões de valor padrão ([expressões de valor padrão ](expressions.md#default-value-expressions)) e `nameof` expressões ([expressões Nameof](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="6bcf4-347">O estado de atribuição definitiva da *v* no final de uma expressão é o mesmo que o estado de atribuição definitiva da *v* no início da expressão.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="6bcf4-348">Regras gerais para expressões com expressões incorporadas</span><span class="sxs-lookup"><span data-stu-id="6bcf4-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="6bcf4-349">As seguintes regras se aplicam a esses tipos de expressões: expressões entre parênteses ([expressões entre parênteses](expressions.md#parenthesized-expressions)), expressões de acesso de elemento ([acesso de elemento](expressions.md#element-access)) Base acessar expressões com indexação ([acesso de Base](expressions.md#base-access)), o incremento e decréscimo expressões ([incremento de sufixo e operadores de decremento](expressions.md#postfix-increment-and-decrement-operators), [incremento de prefixo e de decremento operadores](expressions.md#prefix-increment-and-decrement-operators)), expressões de conversão ([expressões de conversão](expressions.md#cast-expressions)), unário `+`, `-`, `~`, `*` expressões, binárias `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressões ([operadores aritméticos](expressions.md#arithmetic-operators), [operadores Shift](expressions.md#shift-operators), [operadores de teste de tipo e relacional](expressions.md#relational-and-type-testing-operators) [Operadores lógicos](expressions.md#logical-operators)), composta de expressões de atribuição ([atribuição composta](expressions.md#compound-assignment)), `checked` e `unchecked` expressões ([checked e unchecked operadores](expressions.md#the-checked-and-unchecked-operators)), além de expressões de criação de matriz e o delegado ([o novo operador](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="6bcf4-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="6bcf4-350">Cada uma dessas expressões tem um ou mais subexpressões que incondicionalmente são avaliadas em uma ordem fixa.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="6bcf4-351">Por exemplo, o binário `%` operador avalia o lado esquerdo do operador e, em seguida, o lado direito.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="6bcf4-352">Uma operação de indexação avalia a expressão indexada e, em seguida, avalia cada uma das expressões de índice, em ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="6bcf4-353">Para uma expressão *expr*, que tem subexpressões *e1, e2,..., eN*, avaliadas nesta ordem:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="6bcf4-354">O estado de atribuição definitiva da *v* no início da *e1* é o mesmo que o estado de atribuição definitiva no início da *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="6bcf4-355">O estado de atribuição definitiva da *v* no início da *ei* (*eu* maior do que um) é o mesmo que o estado de atribuição definitiva no final a subexpressão anterior.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="6bcf4-356">O estado de atribuição definitiva da *v* no final da *expr* é o mesmo que o estado de atribuição definitiva do final do *eN*</span><span class="sxs-lookup"><span data-stu-id="6bcf4-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="6bcf4-357">Expressões de invocação e expressões de criação de objeto</span><span class="sxs-lookup"><span data-stu-id="6bcf4-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="6bcf4-358">Para uma expressão de invocação *expr* do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="6bcf4-359">ou uma expressão de criação de objeto do formulário:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="6bcf4-360">Para uma expressão de invocação, o estado de atribuição definitiva da *v* antes de *primary_expression* é o mesmo que o estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6bcf4-361">Para uma expressão de invocação, o estado de atribuição definitiva da *v* antes de *arg1* é o mesmo que o estado de *v* depois *primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="6bcf4-362">Para uma expressão de criação de objeto, o estado de atribuição definitiva da *v* antes de *arg1* é o mesmo que o estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6bcf4-363">Para cada argumento *argi*, o estado de atribuição definitiva da *v* após *argi* é determinado pelas regras de expressão normal, ignorando qualquer `ref` ou `out`modificadores.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="6bcf4-364">Para cada argumento *argi* para qualquer *eu* maior do que um, o estado de atribuição definitiva da *v* antes *argi* é o mesmo que o estado do *v* após anterior *arg*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="6bcf4-365">Se a variável *v* é passado como um `out` argumento (ou seja, um argumento do formulário `out v`) em qualquer um dos argumentos, em seguida, o estado de *v* depois *expr* é atribuída definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="6bcf4-366">Caso contrário, o estado de *v* após *expr* é o mesmo que o estado de *v* depois *argN*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="6bcf4-367">Para inicializadores de matriz ([expressões de criação de matriz](expressions.md#array-creation-expressions)), inicializadores de objeto ([inicializadores de objeto](expressions.md#object-initializers)), inicializadores de coleção ([inicializadores de coleção](expressions.md#collection-initializers)) e inicializadores de objeto anônimos ([expressões de criação de objeto anônimo](expressions.md#anonymous-object-creation-expressions)), o estado de atribuição definitiva é determinado pelo que essas construções são definidas em termos de expansão.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="6bcf4-368">Expressões de atribuição simples</span><span class="sxs-lookup"><span data-stu-id="6bcf4-368">Simple assignment expressions</span></span>

<span data-ttu-id="6bcf4-369">Para uma expressão *expr* do formulário `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="6bcf4-370">O estado de atribuição definitiva da *v* antes de *expr_rhs* é o mesmo que o estado de atribuição definitiva da *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6bcf4-371">O estado de atribuição definitiva da *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="6bcf4-372">Se *w* é a mesma variável como *v*, em seguida, o estado de atribuição definitiva de *v* depois *expr* será definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="6bcf4-373">Caso contrário, se a atribuição ocorre dentro do construtor de instância de um tipo de struct, se *w* é um acesso de propriedade que designa uma propriedade implementada automaticamente *P* na instância que está sendo construída e *v* é o campo oculto de backup de *P*, em seguida, o estado de atribuição definitiva de *v* depois *expr* é definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="6bcf4-374">Caso contrário, o estado de atribuição definitiva da *v* após *expr* é o mesmo que o estado de atribuição definitiva da *v* depois *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="6bcf4-375">& & (AND condicional) expressões</span><span class="sxs-lookup"><span data-stu-id="6bcf4-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="6bcf4-376">Para uma expressão *expr* do formulário `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="6bcf4-377">O estado de atribuição definitiva da *v* antes de *expr_first* é o mesmo que o estado de atribuição definitiva da *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6bcf4-378">O estado de atribuição definitiva da *v* antes de *expr_second* é atribuída definitivamente se o estado de *v* depois *expr_first* é definitivamente atribuído ou "atribuído definitivamente após a expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="6bcf4-379">Caso contrário, ele não está definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="6bcf4-380">O estado de atribuição definitiva da *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6bcf4-381">Se *expr_first* é uma expressão constante com o valor `false`, em seguida, o estado de atribuição definitiva de *v* depois *expr* é o mesmo que a atribuição definida estado de *v* após *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="6bcf4-382">Caso contrário, se o estado de *v* após *expr_first* é definitivamente atribuído, em seguida, o estado de *v* depois *expr* será definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6bcf4-383">Caso contrário, se o estado de *v* após *expr_second* definitivamente atribuído e o estado de *v* depois *expr_first* é "definitivamente atribuído após a expressão false", em seguida, o estado de *v* após *expr* será definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6bcf4-384">Caso contrário, se o estado de *v* após *expr_second* será definitivamente atribuído ou "atribuído definitivamente após a expressão verdadeira", em seguida, o estado de *v* depois  *Expr* é "definitivamente atribuído após a expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="6bcf4-385">Caso contrário, se o estado de *v* após *expr_first* é "definitivamente atribuído após a expressão false" e o estado de *v* depois *expr_second* é "definitivamente atribuído após a expressão false", em seguida, o estado do *v* depois *expr* é "definitivamente atribuído após a expressão false".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="6bcf4-386">Caso contrário, o estado de *v* após *expr* definitivamente não foi atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="6bcf4-387">No exemplo</span><span class="sxs-lookup"><span data-stu-id="6bcf4-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="6bcf4-388">a variável `i` é considerado definitivamente atribuído em uma das instruções inseridas de um `if` instrução, mas não na outra.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="6bcf4-389">No `if` instrução no método `F`, a variável `i` definitivamente atribuído na primeira instrução inserida porque a execução da expressão `(i = y)` sempre precede a execução desta instrução inserida.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="6bcf4-390">Por outro lado, a variável `i` não está definitivamente atribuída na segunda instrução inserida, desde `x >= 0` talvez testou falso, resultando na variável `i` sem atribuição.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="6bcf4-391">|| (OR condicional) expressões</span><span class="sxs-lookup"><span data-stu-id="6bcf4-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="6bcf4-392">Para uma expressão *expr* do formulário `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="6bcf4-393">O estado de atribuição definitiva da *v* antes de *expr_first* é o mesmo que o estado de atribuição definitiva da *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6bcf4-394">O estado de atribuição definitiva da *v* antes de *expr_second* é atribuída definitivamente se o estado de *v* depois *expr_first* é definitivamente atribuído ou "atribuído definitivamente depois expressão false".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="6bcf4-395">Caso contrário, ele não está definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="6bcf4-396">A instrução de atribuição definitiva de *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6bcf4-397">Se *expr_first* é uma expressão constante com o valor `true`, em seguida, o estado de atribuição definitiva de *v* depois *expr* é o mesmo que a atribuição definida estado de *v* após *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="6bcf4-398">Caso contrário, se o estado de *v* após *expr_first* é definitivamente atribuído, em seguida, o estado de *v* depois *expr* será definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6bcf4-399">Caso contrário, se o estado de *v* após *expr_second* definitivamente atribuído e o estado de *v* depois *expr_first* é "definitivamente atribuído após a expressão verdadeira", em seguida, o estado de *v* após *expr* será definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6bcf4-400">Caso contrário, se o estado de *v* após *expr_second* será definitivamente atribuído ou "atribuído definitivamente depois expressão false", em seguida, o estado de *v* após *expr* é "definitivamente atribuído após a expressão false".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="6bcf4-401">Caso contrário, se o estado de *v* após *expr_first* é "definitivamente atribuído após a expressão verdadeira" e o estado de *v* depois *expr_second*é "definitivamente atribuído após a expressão verdadeira", em seguida, o estado da *v* após *expr* é "definitivamente atribuído após a expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="6bcf4-402">Caso contrário, o estado de *v* após *expr* definitivamente não foi atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="6bcf4-403">No exemplo</span><span class="sxs-lookup"><span data-stu-id="6bcf4-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="6bcf4-404">a variável `i` é considerado definitivamente atribuído em uma das instruções inseridas de um `if` instrução, mas não na outra.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="6bcf4-405">No `if` instrução no método `G`, a variável `i` definitivamente atribuído na segunda instrução inserida porque a execução da expressão `(i = y)` sempre precede a execução desta instrução inserida.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="6bcf4-406">Por outro lado, a variável `i` não está definitivamente atribuída na primeira instrução inserida, desde `x >= 0` talvez testou true, resultando na variável `i` sem atribuição.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="6bcf4-407">!</span><span class="sxs-lookup"><span data-stu-id="6bcf4-407">!</span></span> <span data-ttu-id="6bcf4-408">expressões (negação lógica)</span><span class="sxs-lookup"><span data-stu-id="6bcf4-408">(logical negation) expressions</span></span>

<span data-ttu-id="6bcf4-409">Para uma expressão *expr* do formulário `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="6bcf4-410">O estado de atribuição definitiva da *v* antes de *expr_operand* é o mesmo que o estado de atribuição definitiva da *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6bcf4-411">O estado de atribuição definitiva da *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6bcf4-412">Se o estado de *v* após \* expr_operand \* é definitivamente atribuído, em seguida, o estado do *v* após *expr* será definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6bcf4-413">Se o estado de *v* após \* expr_operand \* não está definitivamente atribuída, em seguida, o estado do *v* após *expr* definitivamente não foi atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="6bcf4-414">Se o estado de *v* após \* expr_operand \* é "definitivamente atribuído após a expressão false", em seguida, o estado do *v* após *expr* é "definitivamente atribuída após o verdadeiro expressão".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="6bcf4-415">Se o estado de *v* após \* expr_operand \* é "definitivamente atribuído após a expressão verdadeira", em seguida, o estado do *v* após *expr* é "definitivamente atribuída após o falso expressão".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="6bcf4-416">??</span><span class="sxs-lookup"><span data-stu-id="6bcf4-416">??</span></span> <span data-ttu-id="6bcf4-417">expressões (união de nulo)</span><span class="sxs-lookup"><span data-stu-id="6bcf4-417">(null coalescing) expressions</span></span>

<span data-ttu-id="6bcf4-418">Para uma expressão *expr* do formulário `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="6bcf4-419">O estado de atribuição definitiva da *v* antes de *expr_first* é o mesmo que o estado de atribuição definitiva da *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6bcf4-420">O estado de atribuição definitiva da *v* antes de *expr_second* é o mesmo que o estado de atribuição definitiva da *v* depois *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="6bcf4-421">A instrução de atribuição definitiva de *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6bcf4-422">Se *expr_first* é uma expressão constante ([expressões constantes](expressions.md#constant-expressions)) com valor nulo, em seguida, ao estado de *v* depois *expr* é o mesmo como o estado de *v* após *expr_second*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="6bcf4-423">Caso contrário, o estado de *v* após *expr* é o mesmo que o estado de atribuição definitiva da *v* depois *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="6bcf4-424">?: (condicionais) expressões</span><span class="sxs-lookup"><span data-stu-id="6bcf4-424">?: (conditional) expressions</span></span>

<span data-ttu-id="6bcf4-425">Para uma expressão *expr* do formulário `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="6bcf4-426">O estado de atribuição definitiva da *v* antes de *expr_cond* é o mesmo que o estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6bcf4-427">O estado de atribuição definitiva da *v* antes de *expr_true* é atribuída definitivamente se e somente se uma das opções a seguir contém:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="6bcf4-428">*expr_cond* é uma expressão constante com o valor `false`</span><span class="sxs-lookup"><span data-stu-id="6bcf4-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="6bcf4-429">o estado de *v* após *expr_cond* definitivamente atribuído ou "definitivamente atribuído após a expressão verdadeira".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="6bcf4-430">O estado de atribuição definitiva da *v* antes de *expr_false* é atribuída definitivamente se e somente se uma das opções a seguir contém:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="6bcf4-431">*expr_cond* é uma expressão constante com o valor `true`</span><span class="sxs-lookup"><span data-stu-id="6bcf4-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="6bcf4-432">o estado de *v* após *expr_cond* definitivamente atribuído ou "definitivamente atribuído após a expressão false".</span><span class="sxs-lookup"><span data-stu-id="6bcf4-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="6bcf4-433">O estado de atribuição definitiva da *v* após *expr* é determinado por:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6bcf4-434">Se *expr_cond* é uma expressão constante ([expressões constantes](expressions.md#constant-expressions)) com o valor `true` , em seguida, o estado do *v* depois *expr* é o mesmo que o estado de *v* após *expr_true*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="6bcf4-435">Caso contrário, se *expr_cond* é uma expressão constante ([expressões constantes](expressions.md#constant-expressions)) com o valor `false` , em seguida, o estado do *v* depois *expr* é o mesmo que o estado do *v* depois *expr_false*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="6bcf4-436">Caso contrário, se o estado de *v* após *expr_true* será definitivamente atribuído e o estado de *v* depois *expr_false* é definitivamente atribuído, em seguida, o estado de *v* após *expr* será definitivamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6bcf4-437">Caso contrário, o estado de *v* após *expr* definitivamente não foi atribuído.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="6bcf4-438">Funções anônimas</span><span class="sxs-lookup"><span data-stu-id="6bcf4-438">Anonymous functions</span></span>

<span data-ttu-id="6bcf4-439">Para um *lambda_expression* ou *anonymous_method_expression* *expr* com um corpo (ambos *bloco* ou *expressão* ) *corpo*:</span><span class="sxs-lookup"><span data-stu-id="6bcf4-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="6bcf4-440">O estado de atribuição definitiva de uma variável externa *v* antes de *corpo* é o mesmo que o estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="6bcf4-441">Ou seja, estado de atribuição definitiva de variáveis externas é herdado do contexto da função anônima.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="6bcf4-442">O estado de atribuição definitiva de uma variável externa *v* após *expr* é o mesmo que o estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="6bcf4-443">O exemplo</span><span class="sxs-lookup"><span data-stu-id="6bcf4-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="6bcf4-444">gera um erro de tempo de compilação desde `max` não está definitivamente atribuída no qual a função anônima é declarada.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="6bcf4-445">O exemplo</span><span class="sxs-lookup"><span data-stu-id="6bcf4-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="6bcf4-446">também gera um erro de tempo de compilação desde a atribuição ao `n` na função anônima que não tem nenhum efeito sobre o estado de atribuição definitiva da `n` fora da função anônima.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="6bcf4-447">Referências de variável</span><span class="sxs-lookup"><span data-stu-id="6bcf4-447">Variable references</span></span>

<span data-ttu-id="6bcf4-448">Um *variable_reference* é um *expressão* que é classificado como uma variável.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="6bcf4-449">Um *variable_reference* denota um local de armazenamento que pode ser acessado para buscar o valor atual e para armazenar um novo valor.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="6bcf4-450">Em C e C++, uma *variable_reference* é conhecido como um *lvalue*.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="6bcf4-451">Atomicidade de referências de variáveis</span><span class="sxs-lookup"><span data-stu-id="6bcf4-451">Atomicity of variable references</span></span>

<span data-ttu-id="6bcf4-452">Leituras e gravações dos seguintes tipos de dados são atômicas: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`e tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="6bcf4-453">Além disso, leituras e gravações de tipos de enumeração com um tipo subjacente na lista anterior também são atômicas.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="6bcf4-454">Leituras e gravações de outros tipos, incluindo `long`, `ulong`, `double`, e `decimal`, bem como tipos definidos pelo usuário, não há garantia de ser atômicas.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="6bcf4-455">Além das funções de biblioteca criadas para essa finalidade, há nenhuma garantia de atômica modificar-leitura, como no caso de incremento ou decremento.</span><span class="sxs-lookup"><span data-stu-id="6bcf4-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>


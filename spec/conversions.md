---
ms.openlocfilehash: 4d6d28a3127bc701867afe157aa5496377a06f69
ms.sourcegitcommit: 63d276488c9770a565fd787020783ffc1d2af9d6
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/05/2019
ms.locfileid: "74867998"
---
# <a name="conversions"></a><span data-ttu-id="5b84e-101">Conversões</span><span class="sxs-lookup"><span data-stu-id="5b84e-101">Conversions</span></span>

<span data-ttu-id="5b84e-102">Uma ***conversão*** permite que uma expressão seja tratada como sendo de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="5b84e-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="5b84e-103">Uma conversão pode fazer com que uma expressão de um determinado tipo seja tratada como tendo um tipo diferente, ou pode causar uma expressão sem um tipo para obter um tipo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="5b84e-104">As conversões podem ser ***implícitas*** ou ***explícitas***, e isso determina se uma conversão explícita é necessária.</span><span class="sxs-lookup"><span data-stu-id="5b84e-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="5b84e-105">Por exemplo, a conversão do tipo `int` para o tipo `long` é implícita, portanto, as expressões do tipo `int` podem ser tratadas implicitamente como tipo `long`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="5b84e-106">A conversão oposta, do tipo `long` para o tipo `int`, é explícita e, portanto, é necessária uma conversão explícita.</span><span class="sxs-lookup"><span data-stu-id="5b84e-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="5b84e-107">Algumas conversões são definidas pelo idioma.</span><span class="sxs-lookup"><span data-stu-id="5b84e-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="5b84e-108">Os programas também podem definir suas próprias conversões ([conversões definidas pelo usuário](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="5b84e-109">Conversões implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-109">Implicit conversions</span></span>

<span data-ttu-id="5b84e-110">As conversões a seguir são classificadas como conversões implícitas:</span><span class="sxs-lookup"><span data-stu-id="5b84e-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="5b84e-111">Conversões de identidade</span><span class="sxs-lookup"><span data-stu-id="5b84e-111">Identity conversions</span></span>
*  <span data-ttu-id="5b84e-112">Conversões numéricas implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="5b84e-113">Conversões implícitas de enumeração</span><span class="sxs-lookup"><span data-stu-id="5b84e-113">Implicit enumeration conversions</span></span>
*  <span data-ttu-id="5b84e-114">Conversões de cadeia de caracteres interpoladas implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-114">Implicit interpolated string conversions</span></span>
*  <span data-ttu-id="5b84e-115">Conversões anuláveis implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-115">Implicit nullable conversions</span></span>
*  <span data-ttu-id="5b84e-116">Conversões literais nulas</span><span class="sxs-lookup"><span data-stu-id="5b84e-116">Null literal conversions</span></span>
*  <span data-ttu-id="5b84e-117">Conversões de referência implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-117">Implicit reference conversions</span></span>
*  <span data-ttu-id="5b84e-118">Conversões de Boxing</span><span class="sxs-lookup"><span data-stu-id="5b84e-118">Boxing conversions</span></span>
*  <span data-ttu-id="5b84e-119">Conversões dinâmicas implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-119">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="5b84e-120">Conversões de expressão de constante implícita</span><span class="sxs-lookup"><span data-stu-id="5b84e-120">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="5b84e-121">Conversões implícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="5b84e-121">User-defined implicit conversions</span></span>
*  <span data-ttu-id="5b84e-122">Conversões de função anônimas</span><span class="sxs-lookup"><span data-stu-id="5b84e-122">Anonymous function conversions</span></span>
*  <span data-ttu-id="5b84e-123">Conversões de grupo de métodos</span><span class="sxs-lookup"><span data-stu-id="5b84e-123">Method group conversions</span></span>

<span data-ttu-id="5b84e-124">Conversões implícitas podem ocorrer em várias situações, incluindo invocações de membro de função ([verificação de tempo de compilação da resolução dinâmica de sobrecarga](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), expressões de conversão ([expressões de conversão](expressions.md#cast-expressions)) e atribuições ([operadores de atribuição](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-124">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="5b84e-125">As conversões implícitas predefinidas sempre são bem sucedidos e nunca causam a geração de exceções.</span><span class="sxs-lookup"><span data-stu-id="5b84e-125">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="5b84e-126">Conversões implícitas definidas pelo usuário corretamente criadas também devem apresentar essas características.</span><span class="sxs-lookup"><span data-stu-id="5b84e-126">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="5b84e-127">Para fins de conversão, os tipos `object` e `dynamic` são considerados equivalentes.</span><span class="sxs-lookup"><span data-stu-id="5b84e-127">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="5b84e-128">No entanto, conversões dinâmicas (conversões[dinâmicas implícitas](conversions.md#implicit-dynamic-conversions) e [conversões dinâmicas explícitas](conversions.md#explicit-dynamic-conversions)) se aplicam somente a expressões do tipo `dynamic` ([o tipo dinâmico](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-128">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="5b84e-129">Conversão de identidade</span><span class="sxs-lookup"><span data-stu-id="5b84e-129">Identity conversion</span></span>

<span data-ttu-id="5b84e-130">Uma conversão de identidade converte de qualquer tipo para o mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-130">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="5b84e-131">Essa conversão existe de modo que uma entidade que já tenha um tipo necessário seja considerada para ser conversível para esse tipo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-131">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="5b84e-132">Como `object` e `dynamic` são considerados equivalentes, há uma conversão de identidade entre `object` e `dynamic`e entre os tipos construídos que são os mesmos ao substituir todas as ocorrências de `dynamic` por `object`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-132">Because `object` and `dynamic` are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="5b84e-133">Conversões numéricas implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-133">Implicit numeric conversions</span></span>

<span data-ttu-id="5b84e-134">As conversões numéricas implícitas são:</span><span class="sxs-lookup"><span data-stu-id="5b84e-134">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="5b84e-135">De `sbyte` para `short`, `int`, `long`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-135">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-136">De `byte` para `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-136">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-137">De `short` para `int`, `long`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-137">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-138">De `ushort` para `int`, `uint`, `long`, `ulong`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-138">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-139">De `int` para `long`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-139">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-140">De `uint` para `long`, `ulong`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-140">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-141">De `long` para `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-141">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-142">De `ulong` para `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-142">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-143">De `char` para `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-143">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-144">De `float` a `double`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-144">From `float` to `double`.</span></span>

<span data-ttu-id="5b84e-145">As conversões de `int`, `uint`, `long`ou `ulong` para `float` e de `long` ou `ulong` para `double` podem causar perda de precisão, mas nunca causarão uma perda de magnitude.</span><span class="sxs-lookup"><span data-stu-id="5b84e-145">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="5b84e-146">As outras conversões numéricas implícitas nunca perdem nenhuma informação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-146">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="5b84e-147">Não há conversões implícitas para o tipo de `char`, de modo que os valores dos outros tipos integrais não são convertidos automaticamente para o tipo de `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-147">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="5b84e-148">Conversões implícitas de enumeração</span><span class="sxs-lookup"><span data-stu-id="5b84e-148">Implicit enumeration conversions</span></span>

<span data-ttu-id="5b84e-149">Uma conversão de enumeração implícita permite que o `0` de *decimal_integer_literal* seja convertido em qualquer *enum_type* e em qualquer *nullable_type* cujo tipo subjacente seja um *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-149">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="5b84e-150">No último caso, a conversão é avaliada convertendo para o *enum_type* subjacente e encapsulando o resultado ([tipos anuláveis](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-150">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="5b84e-151">Conversões de cadeia de caracteres interpoladas implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-151">Implicit interpolated string conversions</span></span>

<span data-ttu-id="5b84e-152">Uma conversão de cadeia de caracteres interpolada implícita permite que um *interpolated_string_expression* ([cadeias de caracteres interpoladas](expressions.md#interpolated-strings)) seja convertido em `System.IFormattable` ou `System.FormattableString` (que implementa `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="5b84e-152">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="5b84e-153">Quando essa conversão é aplicada, um valor de cadeia de caracteres não é composto da cadeia de caracteres interpolada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-153">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="5b84e-154">Em vez disso, uma instância de `System.FormattableString` é criada, conforme descrito em [cadeias de caracteres interpoladas](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="5b84e-154">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="5b84e-155">Conversões anuláveis implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-155">Implicit nullable conversions</span></span>

<span data-ttu-id="5b84e-156">Conversões implícitas predefinidas que operam em tipos de valores não anuláveis também podem ser usadas com formulários anuláveis desses tipos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-156">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="5b84e-157">Para cada uma das conversões implícitas e numéricas predefinidas que são convertidas de um tipo de valor não anulável `S` a um tipo de valor não anulável `T`, existem as seguintes conversões anuláveis implícitas:</span><span class="sxs-lookup"><span data-stu-id="5b84e-157">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="5b84e-158">Uma conversão implícita de `S?` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-158">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="5b84e-159">Uma conversão implícita de `S` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-159">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="5b84e-160">A avaliação de uma conversão anulável implícita com base em uma conversão subjacente de `S` para `T` prossegue da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="5b84e-160">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="5b84e-161">Se a conversão anulável for de `S?` para `T?`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-161">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="5b84e-162">Se o valor de origem for nulo (`HasValue` propriedade for false), o resultado será o valor nulo do tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-162">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="5b84e-163">Caso contrário, a conversão é avaliada como um desencapsulamento de `S?` para `S`, seguido pela conversão subjacente de `S` para `T`, seguida por um encapsulamento ([tipos anuláveis](types.md#nullable-types)) de `T` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-163">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="5b84e-164">Se a conversão anulável for de `S` para `T?`, a conversão será avaliada como a conversão subjacente de `S` para `T` seguido por um encapsulamento de `T` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-164">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="5b84e-165">Conversões literais nulas</span><span class="sxs-lookup"><span data-stu-id="5b84e-165">Null literal conversions</span></span>

<span data-ttu-id="5b84e-166">Existe uma conversão implícita do literal `null` para qualquer tipo anulável.</span><span class="sxs-lookup"><span data-stu-id="5b84e-166">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="5b84e-167">Essa conversão produz o valor nulo ([tipos anuláveis](types.md#nullable-types)) do tipo anulável especificado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-167">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="5b84e-168">Conversões de referência implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-168">Implicit reference conversions</span></span>

<span data-ttu-id="5b84e-169">As conversões de referência implícitas são:</span><span class="sxs-lookup"><span data-stu-id="5b84e-169">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="5b84e-170">De qualquer *reference_type* para `object` e `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-170">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="5b84e-171">De qualquer *class_type* `S` a qualquer `T`de *class_type* , desde que `S` seja derivado de `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-171">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="5b84e-172">De qualquer *class_type* `S` a qualquer `T`de *interface_type* , fornecida `S` implementa `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-172">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="5b84e-173">De qualquer *interface_type* `S` a qualquer `T`de *interface_type* , desde que `S` seja derivado de `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-173">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="5b84e-174">De um *array_type* `S` com um tipo de elemento `SE` a um *array_type* `T` com um tipo de elemento `TE`, desde que todas as seguintes opções sejam verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="5b84e-174">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="5b84e-175">`S` e `T` diferem apenas no tipo de elemento.</span><span class="sxs-lookup"><span data-stu-id="5b84e-175">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="5b84e-176">Em outras palavras, `S` e `T` têm o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="5b84e-176">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="5b84e-177">Os `SE` e `TE` são *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="5b84e-177">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="5b84e-178">Existe uma conversão de referência implícita de `SE` para `TE`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-178">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="5b84e-179">De qualquer *array_type* para `System.Array` e as interfaces que ele implementa.</span><span class="sxs-lookup"><span data-stu-id="5b84e-179">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="5b84e-180">De um tipo de matriz unidimensional `S[]` para `System.Collections.Generic.IList<T>` e suas interfaces base, desde que haja uma conversão implícita de identidade ou referência de `S` para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-180">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="5b84e-181">De qualquer *delegate_type* para `System.Delegate` e as interfaces que ele implementa.</span><span class="sxs-lookup"><span data-stu-id="5b84e-181">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="5b84e-182">Do literal nulo para qualquer *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-182">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="5b84e-183">De qualquer *reference_type* a um *reference_type* `T` se ele tiver uma conversão implícita de identidade ou referência em um `T0` de *reference_type* e `T0` tiver uma conversão de identidade para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-183">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="5b84e-184">De qualquer *reference_type* a uma interface ou tipo delegado `T` se ele tiver uma conversão implícita de identidade ou referência para uma interface ou tipo delegado `T0` e `T0` for de variação conversível ([conversão de variância](interfaces.md#variance-conversion)) em `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-184">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="5b84e-185">Conversões implícitas envolvendo parâmetros de tipo que são conhecidos como tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="5b84e-185">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="5b84e-186">Confira [conversões implícitas envolvendo parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters) para obter mais detalhes sobre conversões implícitas envolvendo parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-186">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="5b84e-187">As conversões de referência implícitas são aquelas que são conversões entre *reference_type*s que podem ser comprovadas sempre com sucesso e, portanto, não exigem verificações em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="5b84e-187">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="5b84e-188">As conversões de referência, implícita ou explícita, nunca alteram a identidade referencial do objeto que está sendo convertido.</span><span class="sxs-lookup"><span data-stu-id="5b84e-188">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="5b84e-189">Em outras palavras, embora uma conversão de referência possa alterar o tipo da referência, ela nunca altera o tipo ou o valor do objeto que está sendo referenciado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-189">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="5b84e-190">Conversões de Boxing</span><span class="sxs-lookup"><span data-stu-id="5b84e-190">Boxing conversions</span></span>

<span data-ttu-id="5b84e-191">Uma conversão boxing permite que um *value_type* seja convertido implicitamente em um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="5b84e-191">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="5b84e-192">Existe uma conversão boxing de qualquer *non_nullable_value_type* para `object` e `dynamic`, para `System.ValueType` e para qualquer *interface_type* implementada pelo *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-192">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="5b84e-193">Além disso, um *enum_type* pode ser convertido para o tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-193">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="5b84e-194">Uma conversão boxing existe de um *nullable_type* para um tipo de referência, se e somente se uma conversão boxing existir do *non_nullable_value_type* subjacente para o tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="5b84e-194">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="5b84e-195">Um tipo de valor tem uma conversão boxing em um tipo de interface `I` se ele tiver uma conversão boxing em um tipo de interface `I0` e `I0` tiver uma conversão de identidade para `I`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="5b84e-196">Um tipo de valor tem uma conversão boxing em um tipo de interface `I` se ele tiver uma conversão boxing para uma interface ou tipo delegado `I0` e `I0` for Variance-conversíveis ([conversão de variância](interfaces.md#variance-conversion)) para `I`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-196">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="5b84e-197">Boxing um valor de uma *non_nullable_value_type* consiste em alocar uma instância de objeto e copiar o valor de *value_type* nessa instância.</span><span class="sxs-lookup"><span data-stu-id="5b84e-197">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="5b84e-198">Um struct pode ser encaixado no tipo `System.ValueType`, já que essa é uma classe base para todas as structs ([herança](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-198">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="5b84e-199">Boxing um valor de uma *nullable_type* procede da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="5b84e-199">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="5b84e-200">Se o valor de origem for nulo (`HasValue` propriedade for false), o resultado será uma referência nula do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-200">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="5b84e-201">Caso contrário, o resultado é uma referência a um `T` in a box produzido por desencapsulamento e conversão de código-fonte no valor de origem.</span><span class="sxs-lookup"><span data-stu-id="5b84e-201">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="5b84e-202">As conversões Boxing são descritas em mais detalhes nas [conversões Boxing](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="5b84e-202">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="5b84e-203">Conversões dinâmicas implícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-203">Implicit dynamic conversions</span></span>

<span data-ttu-id="5b84e-204">Existe uma conversão dinâmica implícita de uma expressão do tipo `dynamic` para qualquer tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-204">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="5b84e-205">A conversão é vinculada dinamicamente ([associação dinâmica](expressions.md#dynamic-binding)), o que significa que uma conversão implícita será procurada em tempo de execução do tipo de tempo de execução da expressão para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-205">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="5b84e-206">Se nenhuma conversão for encontrada, uma exceção de tempo de execução será lançada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-206">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="5b84e-207">Observe que essa conversão implícita aparentemente viola o Conselho no início de [conversões implícitas](conversions.md#implicit-conversions) que uma conversão implícita nunca deve causar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="5b84e-207">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="5b84e-208">No entanto, ela não é a conversão em si, mas a *localização* da conversão que causa a exceção.</span><span class="sxs-lookup"><span data-stu-id="5b84e-208">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="5b84e-209">O risco de exceções em tempo de execução é inerente ao uso de associação dinâmica.</span><span class="sxs-lookup"><span data-stu-id="5b84e-209">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="5b84e-210">Se a vinculação dinâmica da conversão não for desejada, a expressão poderá ser convertida primeiro em `object`e, em seguida, para o tipo desejado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-210">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="5b84e-211">O exemplo a seguir ilustra as conversões dinâmicas implícitas:</span><span class="sxs-lookup"><span data-stu-id="5b84e-211">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="5b84e-212">As atribuições para `s2` e `i` empregam conversões dinâmicas implícitas, em que a Associação das operações é suspensa até o tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="5b84e-212">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="5b84e-213">Em tempo de execução, as conversões implícitas são buscadas do tipo de tempo de execução de `d` -- `string`--para o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-213">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="5b84e-214">Uma conversão é encontrada para `string` mas não para `int`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-214">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="5b84e-215">Conversões de expressão de constante implícita</span><span class="sxs-lookup"><span data-stu-id="5b84e-215">Implicit constant expression conversions</span></span>

<span data-ttu-id="5b84e-216">Uma conversão de expressão constante implícita permite as seguintes conversões:</span><span class="sxs-lookup"><span data-stu-id="5b84e-216">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="5b84e-217">Uma *constant_expression* ([expressões constantes](expressions.md#constant-expressions)) do tipo `int` pode ser convertida para o tipo `sbyte`, `byte`, `short`, `ushort`, `uint`ou `ulong`, desde que o valor da *constant_expression* esteja dentro do intervalo do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-217">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="5b84e-218">Uma *constant_expression* do tipo `long` pode ser convertida para o tipo `ulong`, desde que o valor da *constant_expression* não seja negativo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-218">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="5b84e-219">Conversões implícitas envolvendo parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="5b84e-219">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="5b84e-220">Existem as seguintes conversões implícitas para um determinado parâmetro de tipo `T`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-220">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="5b84e-221">De `T` para sua classe base efetiva `C`, de `T` para qualquer classe base de `C`e de `T` para qualquer interface implementada pelo `C`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-221">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="5b84e-222">Em tempo de execução, se `T` for um tipo de valor, a conversão será executada como uma conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="5b84e-222">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="5b84e-223">Caso contrário, a conversão é executada como uma conversão de referência implícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="5b84e-223">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="5b84e-224">De `T` para um tipo de interface `I` no conjunto de interfaces efetivas do `T`e de `T` para qualquer interface base do `I`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-224">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="5b84e-225">Em tempo de execução, se `T` for um tipo de valor, a conversão será executada como uma conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="5b84e-225">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="5b84e-226">Caso contrário, a conversão é executada como uma conversão de referência implícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="5b84e-226">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="5b84e-227">De `T` para um parâmetro de tipo `U`, desde que `T` dependa do `U` ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-227">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="5b84e-228">Em tempo de execução, se `U` for um tipo de valor, `T` e `U` serão necessariamente o mesmo tipo e nenhuma conversão será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-228">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="5b84e-229">Caso contrário, se `T` for um tipo de valor, a conversão será executada como uma conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="5b84e-229">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="5b84e-230">Caso contrário, a conversão é executada como uma conversão de referência implícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="5b84e-230">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="5b84e-231">Do literal nulo para `T`, desde que `T` seja conhecido como um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="5b84e-231">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="5b84e-232">De `T` para um tipo de referência `I` se ele tiver uma conversão implícita para um tipo de referência `S0` e `S0` tiver uma conversão de identidade para `S`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-232">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="5b84e-233">Em tempo de execução, a conversão é executada da mesma maneira que a conversão para `S0`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-233">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="5b84e-234">De `T` para um tipo de interface `I` se ela tiver uma conversão implícita em uma interface ou tipo delegado `I0` e `I0` for de variação conversível em `I` ([conversão de variância](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-234">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="5b84e-235">Em tempo de execução, se `T` for um tipo de valor, a conversão será executada como uma conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="5b84e-235">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="5b84e-236">Caso contrário, a conversão é executada como uma conversão de referência implícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="5b84e-236">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="5b84e-237">Se `T` for conhecido como um tipo de referência ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)), as conversões acima serão todas classificadas como conversões de referência implícita ([conversões de referência implícitas](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-237">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="5b84e-238">Se `T` não for conhecido como um tipo de referência, as conversões acima serão classificadas como conversões Boxing ([conversões Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-238">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="5b84e-239">Conversões implícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="5b84e-239">User-defined implicit conversions</span></span>

<span data-ttu-id="5b84e-240">Uma conversão implícita definida pelo usuário consiste em uma conversão implícita padrão opcional, seguida pela execução de um operador de conversão implícita definido pelo usuário, seguido por outra conversão implícita padrão opcional.</span><span class="sxs-lookup"><span data-stu-id="5b84e-240">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="5b84e-241">As regras exatas para avaliar conversões implícitas definidas pelo usuário são descritas em [processamento de conversões implícitas definidas pelo usuário](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="5b84e-241">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="5b84e-242">Conversões de função anônima e conversões de grupo de métodos</span><span class="sxs-lookup"><span data-stu-id="5b84e-242">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="5b84e-243">Funções anônimas e grupos de métodos não têm tipos próprios, mas podem ser convertidos implicitamente em tipos delegados ou tipos de árvore de expressão.</span><span class="sxs-lookup"><span data-stu-id="5b84e-243">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="5b84e-244">As conversões de função anônimas são descritas mais detalhadamente em conversões de [função anônima](conversions.md#anonymous-function-conversions) e conversões de grupo de métodos em [conversões de grupos de métodos](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="5b84e-244">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="5b84e-245">Conversões explícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-245">Explicit conversions</span></span>

<span data-ttu-id="5b84e-246">As conversões a seguir são classificadas como conversões explícitas:</span><span class="sxs-lookup"><span data-stu-id="5b84e-246">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="5b84e-247">Todas as conversões implícitas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-247">All implicit conversions.</span></span>
*  <span data-ttu-id="5b84e-248">Conversões numéricas explícitas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-248">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="5b84e-249">Conversões de enumeração explícitas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-249">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="5b84e-250">Conversões anuláveis explícitas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-250">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="5b84e-251">Conversões de referência explícita.</span><span class="sxs-lookup"><span data-stu-id="5b84e-251">Explicit reference conversions.</span></span>
*  <span data-ttu-id="5b84e-252">Conversões de interface explícitas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-252">Explicit interface conversions.</span></span>
*  <span data-ttu-id="5b84e-253">Conversões de unboxing.</span><span class="sxs-lookup"><span data-stu-id="5b84e-253">Unboxing conversions.</span></span>
*  <span data-ttu-id="5b84e-254">Conversões dinâmicas explícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-254">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="5b84e-255">Conversões explícitas definidas pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="5b84e-255">User-defined explicit conversions.</span></span>

<span data-ttu-id="5b84e-256">Conversões explícitas podem ocorrer em expressões de conversão ([expressões de conversão](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-256">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="5b84e-257">O conjunto de conversões explícitas inclui todas as conversões implícitas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-257">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="5b84e-258">Isso significa que as expressões de conversão redundantes são permitidas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-258">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="5b84e-259">As conversões explícitas que não são conversões implícitas são conversões que não podem ser comprovadas sempre com sucesso, conversões que são conhecidas por possivelmente perderem informações e conversões em domínios de tipos suficientemente diferentes para mérito explícito anotações.</span><span class="sxs-lookup"><span data-stu-id="5b84e-259">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="5b84e-260">Conversões numéricas explícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-260">Explicit numeric conversions</span></span>

<span data-ttu-id="5b84e-261">As conversões numéricas explícitas são as conversões de um *numeric_type* para outro *numeric_type* para o qual uma conversão numérica implícita ([conversões numéricas implícitas](conversions.md#implicit-numeric-conversions)) ainda não existe:</span><span class="sxs-lookup"><span data-stu-id="5b84e-261">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="5b84e-262">De `sbyte` para `byte`, `ushort`, `uint`, `ulong`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-262">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="5b84e-263">De `byte` para `sbyte` e `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-263">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="5b84e-264">De `short` para `sbyte`, `byte`, `ushort`, `uint`, `ulong`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-264">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="5b84e-265">De `ushort` para `sbyte`, `byte`, `short`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-265">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="5b84e-266">De `int` para `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-266">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="5b84e-267">De `uint` para `sbyte`, `byte`, `short`, `ushort`, `int`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-267">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="5b84e-268">De `long` para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-268">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="5b84e-269">De `ulong` para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-269">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="5b84e-270">De `char` para `sbyte`, `byte`ou `short`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-270">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="5b84e-271">De `float` para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-271">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-272">De `double` para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-272">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-273">De `decimal` para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`ou `double`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-273">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="5b84e-274">Como as conversões explícitas incluem todas as conversões numéricas implícitas e explícitas, sempre é possível converter de qualquer *numeric_type* em qualquer outro *numeric_type* usando uma expressão de conversão ([expressões de conversão](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-274">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="5b84e-275">As conversões numéricas explícitas possivelmente perdem informações ou possivelmente causam a geração de exceções.</span><span class="sxs-lookup"><span data-stu-id="5b84e-275">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="5b84e-276">Uma conversão numérica explícita é processada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="5b84e-276">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="5b84e-277">Para uma conversão de um tipo integral para outro tipo integral, o processamento depende do contexto de verificação de estouro ([os operadores marcados e desmarcados](expressions.md#the-checked-and-unchecked-operators)) nos quais a conversão ocorre:</span><span class="sxs-lookup"><span data-stu-id="5b84e-277">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="5b84e-278">Em um contexto de `checked`, a conversão terá sucesso se o valor do operando de origem estiver dentro do intervalo do tipo de destino, mas lançará uma `System.OverflowException` se o valor do operando de origem estiver fora do intervalo do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-278">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="5b84e-279">Em um contexto de `unchecked`, a conversão sempre é bem sucedido e prossegue da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="5b84e-279">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="5b84e-280">Se o tipo de origem for maior do que o tipo de destino, então o valor de origem será truncado descartando seus bits "extra" mais significativos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-280">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="5b84e-281">O resultado é então tratado como um valor do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-281">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="5b84e-282">Se o tipo de origem for menor do que o tipo de destino, então o valor de origem será estendido por sinal ou por zero para que tenha o mesmo tamanho que o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-282">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="5b84e-283">A extensão por sinal será usada se o tipo de origem tiver sinal; a extensão por zero será usada se o tipo de origem não tiver sinal.</span><span class="sxs-lookup"><span data-stu-id="5b84e-283">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="5b84e-284">O resultado é então tratado como um valor do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-284">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="5b84e-285">Se o tipo de origem tiver o mesmo tamanho que o tipo de destino, então o valor de origem será tratado como um valor do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-285">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="5b84e-286">Para uma conversão de `decimal` para um tipo integral, o valor de origem é arredondado para zero para o valor integral mais próximo, e esse valor integral se torna o resultado da conversão.</span><span class="sxs-lookup"><span data-stu-id="5b84e-286">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="5b84e-287">Se o valor integral resultante estiver fora do intervalo do tipo de destino, um `System.OverflowException` será gerado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-287">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="5b84e-288">Para uma conversão de `float` ou `double` a um tipo integral, o processamento depende do contexto de verificação de estouro ([os operadores marcados e desmarcados](expressions.md#the-checked-and-unchecked-operators)) nos quais a conversão ocorre:</span><span class="sxs-lookup"><span data-stu-id="5b84e-288">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="5b84e-289">Em um contexto de `checked`, a conversão continua da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="5b84e-289">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="5b84e-290">Se o valor do operando for NaN ou infinito, um `System.OverflowException` será lançado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-290">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="5b84e-291">Caso contrário, o operando de origem será arredondado em direção a zero para o valor integral mais próximo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-291">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="5b84e-292">Se esse valor integral estiver dentro do intervalo do tipo de destino, esse valor será o resultado da conversão.</span><span class="sxs-lookup"><span data-stu-id="5b84e-292">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="5b84e-293">Caso contrário, uma `System.OverflowException` será gerada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-293">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="5b84e-294">Em um contexto de `unchecked`, a conversão sempre é bem sucedido e prossegue da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="5b84e-294">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="5b84e-295">Se o valor do operando for NaN ou infinito, o resultado da conversão será um valor não especificado do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-295">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="5b84e-296">Caso contrário, o operando de origem será arredondado em direção a zero para o valor integral mais próximo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-296">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="5b84e-297">Se esse valor integral estiver dentro do intervalo do tipo de destino, esse valor será o resultado da conversão.</span><span class="sxs-lookup"><span data-stu-id="5b84e-297">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="5b84e-298">Caso contrário, o resultado da conversão é um valor não especificado do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-298">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="5b84e-299">Para uma conversão de `double` para `float`, o valor `double` é arredondado para o valor de `float` mais próximo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-299">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="5b84e-300">Se o valor de `double` for muito pequeno para representar como um `float`, o resultado se tornará positivo zero ou negativo zero.</span><span class="sxs-lookup"><span data-stu-id="5b84e-300">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="5b84e-301">Se o valor de `double` for muito grande para representar como um `float`, o resultado se tornará infinito positivo ou infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-301">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="5b84e-302">Se o valor de `double` for NaN, o resultado também será NaN.</span><span class="sxs-lookup"><span data-stu-id="5b84e-302">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="5b84e-303">Para uma conversão de `float` ou `double` para `decimal`, o valor de origem é convertido em `decimal` representação e arredondado para o número mais próximo após a casa decimal 28, se necessário ([o tipo decimal](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-303">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="5b84e-304">Se o valor de origem for muito pequeno para representar como um `decimal`, o resultado se tornará zero.</span><span class="sxs-lookup"><span data-stu-id="5b84e-304">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="5b84e-305">Se o valor de origem for NaN, Infinity ou muito grande para representar como um `decimal`, um `System.OverflowException` será gerado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-305">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="5b84e-306">Para uma conversão de `decimal` para `float` ou `double`, o valor `decimal` é arredondado para o valor `double` ou `float` mais próximo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-306">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="5b84e-307">Embora essa conversão possa perder a precisão, ela nunca faz com que uma exceção seja gerada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-307">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="5b84e-308">Conversões de enumeração explícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-308">Explicit enumeration conversions</span></span>

<span data-ttu-id="5b84e-309">As conversões de enumeração explícitas são:</span><span class="sxs-lookup"><span data-stu-id="5b84e-309">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="5b84e-310">De `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`ou `decimal` a qualquer *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-310">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="5b84e-311">De qualquer *enum_type* para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-311">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="5b84e-312">De qualquer *enum_type* a qualquer outro *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-312">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="5b84e-313">Uma conversão de enumeração explícita entre dois tipos é processada tratando qualquer *enum_type* participante como o tipo subjacente do *enum_type*e, em seguida, executando uma conversão numérica implícita ou explícita entre os tipos resultantes.</span><span class="sxs-lookup"><span data-stu-id="5b84e-313">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="5b84e-314">Por exemplo, dado um *enum_type* `E` com e o tipo subjacente de `int`, uma conversão de `E` para `byte` é processada como uma conversão numérica explícita ([conversões numéricas explícitas](conversions.md#explicit-numeric-conversions)) de `int` para `byte`e uma conversão de `byte` para `E` é processada como uma conversão numérica implícita ([conversões numéricas implícitas](conversions.md#implicit-numeric-conversions)) de `byte` para `int`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-314">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="5b84e-315">Conversões anuláveis explícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-315">Explicit nullable conversions</span></span>

<span data-ttu-id="5b84e-316">As ***conversões anuláveis explícitas*** permitem conversões explícitas predefinidas que operam em tipos de valores não anuláveis para também serem usadas com formulários anuláveis desses tipos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-316">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="5b84e-317">Para cada uma das conversões explícitas predefinidas que são convertidas de um tipo de valor não anulável `S` a um tipo de valor não anulável `T` ([conversão de identidade](conversions.md#identity-conversion), [conversões numéricas implícitas](conversions.md#implicit-numeric-conversions), [conversões implícitas de enumeração](conversions.md#implicit-enumeration-conversions), [conversões numéricas explícitas](conversions.md#explicit-numeric-conversions)e [conversões de enumeração explícitas](conversions.md#explicit-enumeration-conversions)), existem as seguintes conversões anuláveis:</span><span class="sxs-lookup"><span data-stu-id="5b84e-317">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="5b84e-318">Uma conversão explícita de `S?` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-318">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="5b84e-319">Uma conversão explícita de `S` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-319">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="5b84e-320">Uma conversão explícita de `S?` para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-320">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="5b84e-321">A avaliação de uma conversão anulável com base em uma conversão subjacente de `S` para `T` prossegue da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="5b84e-321">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="5b84e-322">Se a conversão anulável for de `S?` para `T?`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-322">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="5b84e-323">Se o valor de origem for nulo (`HasValue` propriedade for false), o resultado será o valor nulo do tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-323">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="5b84e-324">Caso contrário, a conversão é avaliada como um desencapsulamento de `S?` para `S`, seguido pela conversão subjacente de `S` para `T`, seguida por um encapsulamento de `T` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-324">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="5b84e-325">Se a conversão anulável for de `S` para `T?`, a conversão será avaliada como a conversão subjacente de `S` para `T` seguido por um encapsulamento de `T` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-325">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="5b84e-326">Se a conversão anulável for de `S?` para `T`, a conversão será avaliada como um desencapsulamento de `S?` para `S` seguido pela conversão subjacente de `S` para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-326">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="5b84e-327">Observe que uma tentativa de desencapsular um valor anulável gerará uma exceção se o valor for `null`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-327">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="5b84e-328">Conversões de referência explícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-328">Explicit reference conversions</span></span>

<span data-ttu-id="5b84e-329">As conversões de referência explícitas são:</span><span class="sxs-lookup"><span data-stu-id="5b84e-329">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="5b84e-330">De `object` e `dynamic` a qualquer outro *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-330">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="5b84e-331">De qualquer *class_type* `S` a qualquer `T`de *class_type* , desde `S` é uma classe base de `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-331">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="5b84e-332">De qualquer *class_type* `S` a qualquer `T`de *interface_type* , desde que `S` não seja lacrado e fornecido `S` não implementa `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-332">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="5b84e-333">De qualquer *interface_type* `S` a qualquer `T`de *class_type* , desde que `T` não seja lacrado ou fornecido `T` implemente `S`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-333">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="5b84e-334">De qualquer *interface_type* `S` a qualquer `T`de *interface_type* , desde que `S` não seja derivado de `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-334">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="5b84e-335">De um *array_type* `S` com um tipo de elemento `SE` a um *array_type* `T` com um tipo de elemento `TE`, desde que todas as seguintes opções sejam verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="5b84e-335">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="5b84e-336">`S` e `T` diferem apenas no tipo de elemento.</span><span class="sxs-lookup"><span data-stu-id="5b84e-336">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="5b84e-337">Em outras palavras, `S` e `T` têm o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="5b84e-337">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="5b84e-338">Os `SE` e `TE` são *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="5b84e-338">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="5b84e-339">Existe uma conversão de referência explícita de `SE` para `TE`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-339">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="5b84e-340">De `System.Array` e as interfaces que ele implementa para qualquer *array_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-340">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="5b84e-341">De um tipo de matriz unidimensional `S[]` para `System.Collections.Generic.IList<T>` e suas interfaces base, desde que haja uma conversão de referência explícita de `S` para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-341">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="5b84e-342">De `System.Collections.Generic.IList<S>` e suas interfaces base para um tipo de matriz unidimensional `T[]`, desde que haja uma conversão explícita ou de referência de `S` para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-342">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="5b84e-343">De `System.Delegate` e as interfaces que ele implementa para qualquer *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-343">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="5b84e-344">De um tipo de referência para um tipo de referência `T` se ele tiver uma conversão de referência explícita para um tipo de referência `T0` e `T0` tiver uma conversão de identidade `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-344">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="5b84e-345">De um tipo de referência para uma interface ou tipo delegado `T` se ele tiver uma conversão de referência explícita para um tipo de interface ou delegado `T0` e `T0` for de conversível de variação em `T` ou `T` é convertido em variância para `T0` ([conversão de variância](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-345">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="5b84e-346">De `D<S1...Sn>` para `D<T1...Tn>` em que `D<X1...Xn>` é um tipo de delegado genérico, `D<S1...Sn>` não é compatível com ou é idêntico a `D<T1...Tn>`e para cada parâmetro de tipo `Xi` de `D` as seguintes isenções:</span><span class="sxs-lookup"><span data-stu-id="5b84e-346">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="5b84e-347">Se `Xi` for invariável, `Si` será idêntica a `Ti`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-347">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="5b84e-348">Se `Xi` for covariant, haverá uma identidade implícita ou explícita ou conversão de referência de `Si` para `Ti`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-348">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="5b84e-349">Se `Xi` for contravariant, `Si` e `Ti` serão idênticos ou ambos os tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="5b84e-349">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="5b84e-350">Conversões explícitas envolvendo parâmetros de tipo que são conhecidos como tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="5b84e-350">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="5b84e-351">Para obter mais detalhes sobre conversões explícitas envolvendo parâmetros de tipo, consulte [conversões explícitas envolvendo parâmetros de tipo](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="5b84e-351">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="5b84e-352">As conversões de referência explícitas são as conversões entre os tipos de referência que exigem verificações de tempo de execução para garantir que estejam corretos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-352">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="5b84e-353">Para que uma conversão de referência explícita seja realizada com sucesso em tempo de execução, o valor do operando de origem deve ser `null`ou o tipo real do objeto referenciado pelo operando de origem deve ser um tipo que possa ser convertido para o tipo de destino por uma conversão de referência implícita ([conversões de referência implícita](conversions.md#implicit-reference-conversions)) ou conversão de Boxing ([conversões Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-353">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="5b84e-354">Se uma conversão de referência explícita falhar, um `System.InvalidCastException` será gerado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-354">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="5b84e-355">As conversões de referência, implícita ou explícita, nunca alteram a identidade referencial do objeto que está sendo convertido.</span><span class="sxs-lookup"><span data-stu-id="5b84e-355">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="5b84e-356">Em outras palavras, embora uma conversão de referência possa alterar o tipo da referência, ela nunca altera o tipo ou o valor do objeto que está sendo referenciado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-356">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="5b84e-357">Conversões de unboxing</span><span class="sxs-lookup"><span data-stu-id="5b84e-357">Unboxing conversions</span></span>

<span data-ttu-id="5b84e-358">Uma conversão sem Boxing permite que um tipo de referência seja explicitamente convertido em um *value_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-358">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="5b84e-359">Existe uma conversão não Boxing dos tipos `object`, `dynamic` e `System.ValueType` a qualquer *non_nullable_value_type*e de qualquer *interface_type* para qualquer *non_nullable_value_type* que implemente o *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-359">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="5b84e-360">Além disso, o tipo `System.Enum` pode ser desemoldurado para qualquer *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-360">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="5b84e-361">Uma conversão unboxing existe de um tipo de referência para um *nullable_type* se existir uma conversão unboxing do tipo de referência para o *non_nullable_value_type* subjacente do *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-361">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="5b84e-362">Um tipo de valor `S` tem uma conversão unboxing de um tipo de interface `I` se ele tiver uma conversão unboxing de um tipo de interface `I0` e `I0` tiver uma conversão de identidade para `I`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="5b84e-363">Um tipo de valor `S` tem uma conversão unboxing de um tipo de interface `I` se ele tiver uma conversão de unboxing de um tipo de interface ou delegado `I0` e `I0` for de conversível para `I` ou `I` for de variação conversível para `I0` ([conversão de variância](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-363">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="5b84e-364">Uma operação de unboxing consiste na primeira verificação de que a instância do objeto é um valor em caixa do determinado *value_type*e, em seguida, copiar o valor para fora da instância.</span><span class="sxs-lookup"><span data-stu-id="5b84e-364">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="5b84e-365">Unboxing uma referência nula a um *nullable_type* produz o valor nulo do *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-365">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="5b84e-366">Um struct pode ser desemoldurado do tipo `System.ValueType`, pois essa é uma classe base para todas as structs ([herança](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-366">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="5b84e-367">As conversões de unboxing são descritas em detalhes em [conversões unboxing](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="5b84e-367">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="5b84e-368">Conversões dinâmicas explícitas</span><span class="sxs-lookup"><span data-stu-id="5b84e-368">Explicit dynamic conversions</span></span>

<span data-ttu-id="5b84e-369">Existe uma conversão dinâmica explícita de uma expressão do tipo `dynamic` para qualquer tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-369">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="5b84e-370">A conversão é vinculada dinamicamente ([associação dinâmica](expressions.md#dynamic-binding)), o que significa que uma conversão explícita será procurada em tempo de execução do tipo de tempo de execução da expressão para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-370">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="5b84e-371">Se nenhuma conversão for encontrada, uma exceção de tempo de execução será lançada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-371">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="5b84e-372">Se a vinculação dinâmica da conversão não for desejada, a expressão poderá ser convertida primeiro em `object`e, em seguida, para o tipo desejado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-372">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="5b84e-373">Suponha que a seguinte classe seja definida:</span><span class="sxs-lookup"><span data-stu-id="5b84e-373">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="5b84e-374">O exemplo a seguir ilustra as conversões dinâmicas explícitas:</span><span class="sxs-lookup"><span data-stu-id="5b84e-374">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="5b84e-375">A melhor conversão de `o` para `C` é encontrada em tempo de compilação para ser uma conversão de referência explícita.</span><span class="sxs-lookup"><span data-stu-id="5b84e-375">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="5b84e-376">Isso falha em tempo de execução, porque `"1"` não é, na verdade, uma `C`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-376">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="5b84e-377">A conversão de `d` para `C` no entanto, como uma conversão dinâmica explícita, é suspensa para tempo de execução, em que uma conversão definida pelo usuário do tipo de tempo de execução de `d` -- `string`--para `C` é encontrada e é bem sucedido.</span><span class="sxs-lookup"><span data-stu-id="5b84e-377">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="5b84e-378">Conversões explícitas envolvendo parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="5b84e-378">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="5b84e-379">Existem as conversões explícitas a seguir para um determinado parâmetro de tipo `T`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-379">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="5b84e-380">Da classe base em vigor `C` de `T` para `T` e de qualquer classe base de `C` para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-380">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="5b84e-381">Em tempo de execução, se `T` for um tipo de valor, a conversão será executada como uma conversão sem boxing.</span><span class="sxs-lookup"><span data-stu-id="5b84e-381">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="5b84e-382">Caso contrário, a conversão é executada como uma conversão de referência explícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="5b84e-382">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="5b84e-383">De qualquer tipo de interface para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-383">From any interface type to `T`.</span></span> <span data-ttu-id="5b84e-384">Em tempo de execução, se `T` for um tipo de valor, a conversão será executada como uma conversão sem boxing.</span><span class="sxs-lookup"><span data-stu-id="5b84e-384">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="5b84e-385">Caso contrário, a conversão é executada como uma conversão de referência explícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="5b84e-385">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="5b84e-386">De `T` para qualquer *interface_type* `I` fornecida, ainda não há uma conversão implícita de `T` para `I`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-386">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="5b84e-387">Em tempo de execução, se `T` for um tipo de valor, a conversão será executada como uma conversão boxing seguida de uma conversão de referência explícita.</span><span class="sxs-lookup"><span data-stu-id="5b84e-387">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="5b84e-388">Caso contrário, a conversão é executada como uma conversão de referência explícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="5b84e-388">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="5b84e-389">De um parâmetro de tipo `U` para `T`, fornecido `T` depende de `U` ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-389">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="5b84e-390">Em tempo de execução, se `U` for um tipo de valor, `T` e `U` serão necessariamente o mesmo tipo e nenhuma conversão será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-390">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="5b84e-391">Caso contrário, se `T` for um tipo de valor, a conversão será executada como uma conversão não boxing.</span><span class="sxs-lookup"><span data-stu-id="5b84e-391">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="5b84e-392">Caso contrário, a conversão é executada como uma conversão de referência explícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="5b84e-392">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="5b84e-393">Se `T` for conhecido como um tipo de referência, as conversões acima serão todas classificadas como conversões de referência explícita ([conversões de referência explícitas](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-393">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="5b84e-394">Se `T` não for conhecido como um tipo de referência, as conversões acima serão classificadas como conversões não Boxing ([conversões unboxing](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-394">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="5b84e-395">As regras acima não permitem uma conversão explícita direta de um parâmetro de tipo irrestrito para um tipo que não seja de interface, o que pode ser surpreendente.</span><span class="sxs-lookup"><span data-stu-id="5b84e-395">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="5b84e-396">A razão para essa regra é evitar confusão e tornar a semântica dessas conversões clara.</span><span class="sxs-lookup"><span data-stu-id="5b84e-396">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="5b84e-397">Por exemplo, considere a seguinte declaração:</span><span class="sxs-lookup"><span data-stu-id="5b84e-397">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="5b84e-398">Se a conversão explícita direta de `t` para `int` fosse permitida, alguém poderia esperar que `X<int>.F(7)` retornasse `7L`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-398">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="5b84e-399">No entanto, isso não ocorre porque as conversões numéricas padrão só são consideradas quando os tipos são conhecidos como numéricos no tempo de associação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-399">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="5b84e-400">Para tornar a semântica clara, o exemplo acima deve ser escrito em vez disso:</span><span class="sxs-lookup"><span data-stu-id="5b84e-400">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="5b84e-401">Esse código agora será compilado, mas a execução de `X<int>.F(7)` geraria uma exceção em tempo de execução, já que uma `int` em caixa não pode ser convertida diretamente em uma `long`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-401">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="5b84e-402">Conversões explícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="5b84e-402">User-defined explicit conversions</span></span>

<span data-ttu-id="5b84e-403">Uma conversão explícita definida pelo usuário consiste em uma conversão explícita padrão opcional, seguida pela execução de um operador de conversão implícita ou explícita definido pelo usuário, seguido por outra conversão opcional explícita padrão.</span><span class="sxs-lookup"><span data-stu-id="5b84e-403">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="5b84e-404">As regras exatas para avaliar conversões explícitas definidas pelo usuário são descritas em [processamento de conversões explícitas definidas pelo usuário](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="5b84e-404">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="5b84e-405">Conversões padrão</span><span class="sxs-lookup"><span data-stu-id="5b84e-405">Standard conversions</span></span>

<span data-ttu-id="5b84e-406">As conversões padrão são aquelas conversões predefinidas que podem ocorrer como parte de uma conversão definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="5b84e-406">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="5b84e-407">Conversões implícitas padrão</span><span class="sxs-lookup"><span data-stu-id="5b84e-407">Standard implicit conversions</span></span>

<span data-ttu-id="5b84e-408">As conversões implícitas a seguir são classificadas como conversões implícitas padrão:</span><span class="sxs-lookup"><span data-stu-id="5b84e-408">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="5b84e-409">Conversões de identidade ([conversão de identidade](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="5b84e-409">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="5b84e-410">Conversões numéricas implícitas ([conversões numéricas implícitas](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="5b84e-410">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="5b84e-411">Conversões anuláveis implícitas ([conversões anuláveis implícitas](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="5b84e-411">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="5b84e-412">Conversões implícitas de referência ([conversões de referência implícitas](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="5b84e-412">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="5b84e-413">Conversões Boxing ([conversões Boxing](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="5b84e-413">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="5b84e-414">Conversões de expressão de constante implícita ([conversões dinâmicas implícitas](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="5b84e-414">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="5b84e-415">Conversões implícitas envolvendo parâmetros de tipo ([conversões implícitas envolvendo parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="5b84e-415">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="5b84e-416">As conversões implícitas padrão excluem especificamente conversões implícitas definidas pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="5b84e-416">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="5b84e-417">Conversões explícitas padrão</span><span class="sxs-lookup"><span data-stu-id="5b84e-417">Standard explicit conversions</span></span>

<span data-ttu-id="5b84e-418">As conversões explícitas padrão são todas as conversões implícitas padrão mais o subconjunto das conversões explícitas para as quais existe uma conversão implícita padrão oposta.</span><span class="sxs-lookup"><span data-stu-id="5b84e-418">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="5b84e-419">Em outras palavras, se existir uma conversão implícita padrão de um tipo `A` a um tipo `B`, uma conversão explícita padrão existirá do tipo `A` para o tipo `B` e do tipo `B` para o tipo `A`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-419">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="5b84e-420">Conversões definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="5b84e-420">User-defined conversions</span></span>

<span data-ttu-id="5b84e-421">C#permite que as conversões implícitas e explícitas predefinidas sejam aumentadas por ***conversões definidas pelo usuário***.</span><span class="sxs-lookup"><span data-stu-id="5b84e-421">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="5b84e-422">Conversões definidas pelo usuário são introduzidas pela declaração de operadores de conversão ([operadores de conversão](classes.md#conversion-operators)) em tipos de classe e struct.</span><span class="sxs-lookup"><span data-stu-id="5b84e-422">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="5b84e-423">Conversões permitidas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="5b84e-423">Permitted user-defined conversions</span></span>

<span data-ttu-id="5b84e-424">C#permite que apenas determinadas conversões definidas pelo usuário sejam declaradas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-424">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="5b84e-425">Em particular, não é possível redefinir uma conversão implícita ou explícita já existente.</span><span class="sxs-lookup"><span data-stu-id="5b84e-425">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="5b84e-426">Para um determinado tipo de fonte `S` e tipo de destino `T`, se `S` ou `T` forem tipos anuláveis, permita que `S0` e `T0` refiram-se aos seus tipos subjacentes, caso contrário, `S0` e `T0` são iguais a `S` e `T` respectivamente.</span><span class="sxs-lookup"><span data-stu-id="5b84e-426">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="5b84e-427">Uma classe ou estrutura tem permissão para declarar uma conversão de um tipo de origem `S` para um tipo de destino `T` somente se todas as seguintes opções forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="5b84e-427">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="5b84e-428">`S0` e `T0` são tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="5b84e-428">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="5b84e-429">`S0` ou `T0` é o tipo de classe ou struct no qual a declaração do operador ocorre.</span><span class="sxs-lookup"><span data-stu-id="5b84e-429">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="5b84e-430">Nem `S0` nem `T0` é um *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="5b84e-430">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="5b84e-431">Excluindo conversões definidas pelo usuário, uma conversão não existe de `S` para `T` ou de `T` para `S`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-431">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="5b84e-432">As restrições que se aplicam a conversões definidas pelo usuário são discutidas mais detalhadamente nos [operadores de conversão](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="5b84e-432">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="5b84e-433">Operadores de conversão levantados</span><span class="sxs-lookup"><span data-stu-id="5b84e-433">Lifted conversion operators</span></span>

<span data-ttu-id="5b84e-434">Dado um operador de conversão definido pelo usuário que converte de um tipo de valor não anulável `S` para um tipo de valor não anulável `T`, existe um ***operador de conversão levantado*** que converte de `S?` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-434">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="5b84e-435">Esse operador de conversão levantado executa um desencapsulamento de `S?` para `S` seguido pela conversão definida pelo usuário de `S` para `T` seguido por um encapsulamento de `T` para `T?`, exceto que um valor nulo `S?` é convertido diretamente em um `T?`com valor nulo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-435">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="5b84e-436">Um operador de conversão elevado tem a mesma classificação implícita ou explícita que seu operador de conversão subjacente definido pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="5b84e-436">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="5b84e-437">O termo "conversão definida pelo usuário" aplica-se ao uso de operadores de conversão que foram definidos pelo usuário e com elevação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-437">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="5b84e-438">Avaliação de conversões definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="5b84e-438">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="5b84e-439">Uma conversão definida pelo usuário converte um valor de seu tipo, chamado de ***tipo de origem***, para outro tipo, chamado de ***tipo de destino***.</span><span class="sxs-lookup"><span data-stu-id="5b84e-439">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="5b84e-440">Avaliação de um centro de conversão definido pelo usuário para localizar o operador de conversão definido pelo usuário ***mais específico*** para os tipos de origem e destino específicos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-440">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="5b84e-441">Essa determinação é dividida em várias etapas:</span><span class="sxs-lookup"><span data-stu-id="5b84e-441">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="5b84e-442">Localizando o conjunto de classes e structs dos quais operadores de conversão definidos pelo usuário serão considerados.</span><span class="sxs-lookup"><span data-stu-id="5b84e-442">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="5b84e-443">Esse conjunto consiste no tipo de origem e suas classes base, e o tipo de destino e suas classes base (com as suposições implícitas que somente classes e structs podem declarar operadores definidos pelo usuário e que não têm classes base).</span><span class="sxs-lookup"><span data-stu-id="5b84e-443">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="5b84e-444">Para os fins desta etapa, se o tipo de origem ou de destino for um *nullable_type*, seu tipo subjacente será usado em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="5b84e-444">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="5b84e-445">Desse conjunto de tipos, determinando quais operadores de conversão levantados e definidos pelo usuário são aplicáveis.</span><span class="sxs-lookup"><span data-stu-id="5b84e-445">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="5b84e-446">Para que um operador de conversão seja aplicável, deve ser possível executar uma conversão padrão ([conversões padrão](conversions.md#standard-conversions)) do tipo de origem para o tipo de operando do operador e deve ser possível executar uma conversão padrão do tipo de resultado do operador para o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-446">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="5b84e-447">Do conjunto de operadores aplicáveis definidos pelo usuário, determinando qual operador não é ambíguomente o mais específico.</span><span class="sxs-lookup"><span data-stu-id="5b84e-447">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="5b84e-448">Em termos gerais, o operador mais específico é o operador cujo tipo de operando é "mais próximo" do tipo de origem e cujo tipo de resultado é "mais próximo" ao tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-448">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="5b84e-449">Os operadores de conversão definidos pelo usuário são preferenciais em relação aos operadores de conversão levantados.</span><span class="sxs-lookup"><span data-stu-id="5b84e-449">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="5b84e-450">As regras exatas para estabelecer o operador de conversão mais específico definido pelo usuário são definidas nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="5b84e-450">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="5b84e-451">Depois que um operador de conversão definido pelo usuário mais específico tiver sido identificado, a execução real da conversão definida pelo usuário envolverá até três etapas:</span><span class="sxs-lookup"><span data-stu-id="5b84e-451">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="5b84e-452">Primeiro, se necessário, executando uma conversão padrão do tipo de origem para o tipo de operando do operador de conversão definido pelo usuário ou levantado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-452">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="5b84e-453">Em seguida, invocando o operador de conversão definido pelo usuário ou elevação para executar a conversão.</span><span class="sxs-lookup"><span data-stu-id="5b84e-453">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="5b84e-454">Por fim, se necessário, executar uma conversão padrão do tipo de resultado do operador de conversão definido pelo usuário ou de forma elevada para o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-454">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="5b84e-455">A avaliação de uma conversão definida pelo usuário nunca envolve mais de um operador de conversão mais definido pelo usuário ou levantado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-455">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="5b84e-456">Em outras palavras, uma conversão do tipo `S` para o tipo `T` nunca executará primeiro uma conversão definida pelo usuário de `S` em `X` e, em seguida, executará uma conversão definida pelo usuário de `X` para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-456">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="5b84e-457">As definições exatas de avaliação de conversões implícitas ou explícitas definidas pelo usuário são dadas nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="5b84e-457">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="5b84e-458">As definições fazem uso dos seguintes termos:</span><span class="sxs-lookup"><span data-stu-id="5b84e-458">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="5b84e-459">Se uma conversão implícita padrão ([conversões implícitas padrão](conversions.md#standard-implicit-conversions)) existir de um tipo `A` a um tipo `B`, e se nem `A` nem `B` forem *interface_type*s, a `A` será considerada como sendo ***englobeda pelo*** `B`, e `B` será considerado para ***abranger*** `A`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-459">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="5b84e-460">O ***tipo mais abrangente*** em um conjunto de tipos é aquele que abrange todos os outros tipos no conjunto.</span><span class="sxs-lookup"><span data-stu-id="5b84e-460">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="5b84e-461">Se nenhum tipo único abranger todos os outros tipos, o conjunto não terá mais de abranger o tipo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-461">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="5b84e-462">Em termos mais intuitivos, o tipo mais abrangente é o tipo "maior" no conjunto — o tipo para o qual cada um dos outros tipos pode ser convertido implicitamente.</span><span class="sxs-lookup"><span data-stu-id="5b84e-462">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="5b84e-463">O ***tipo mais abrangente*** em um conjunto de tipos é aquele que é abrangedo por todos os outros tipos no conjunto.</span><span class="sxs-lookup"><span data-stu-id="5b84e-463">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="5b84e-464">Se nenhum tipo único for abrangedo por todos os outros tipos, o conjunto não terá o tipo mais abrangedo.</span><span class="sxs-lookup"><span data-stu-id="5b84e-464">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="5b84e-465">Em termos mais intuitivos, o tipo mais abrangente é o tipo "menor" no conjunto — aquele tipo que pode ser convertido implicitamente em cada um dos outros tipos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-465">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="5b84e-466">Processamento de conversões implícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="5b84e-466">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="5b84e-467">Uma conversão implícita definida pelo usuário do tipo `S` para o tipo `T` é processada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="5b84e-467">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="5b84e-468">Determine os tipos `S0` e `T0`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-468">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="5b84e-469">Se `S` ou `T` forem tipos anuláveis, `S0` e `T0` serão os tipos subjacentes, caso contrário `S0` e `T0` serão iguais a `S` e `T`, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="5b84e-469">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="5b84e-470">Localize o conjunto de tipos, `D`, do qual os operadores de conversão definidos pelo usuário serão considerados.</span><span class="sxs-lookup"><span data-stu-id="5b84e-470">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="5b84e-471">Esse conjunto consiste em `S0` (se `S0` for uma classe ou struct), as classes base de `S0` (se `S0` for uma classe) e `T0` (se `T0` for uma classe ou struct).</span><span class="sxs-lookup"><span data-stu-id="5b84e-471">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="5b84e-472">Localize o conjunto de operadores de conversão aplicáveis definidos pelo usuário e com elevação, `U`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-472">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="5b84e-473">Esse conjunto consiste nos operadores de conversão implícitas definidos pelo usuário e levantados declarados pelas classes ou estruturas em `D` que convertem de um tipo que abrange `S` para um tipo que abrange por `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-473">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="5b84e-474">Se `U` estiver vazio, a conversão será indefinida e ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-474">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-475">Localize o tipo de fonte mais específico, `SX`, dos operadores em `U`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-475">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="5b84e-476">Se qualquer um dos operadores em `U` converter de `S`, `SX` será `S`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-476">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="5b84e-477">Caso contrário, `SX` é o tipo mais abrangente no conjunto combinado de tipos de origem dos operadores em `U`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-477">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="5b84e-478">Se não for possível encontrar exatamente um tipo mais abrangente, a conversão será ambígua e ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-478">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-479">Localize o tipo de destino mais específico, `TX`, dos operadores em `U`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-479">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="5b84e-480">Se qualquer um dos operadores em `U` converter em `T`, `TX` será `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-480">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="5b84e-481">Caso contrário, `TX` é o tipo mais abrangente no conjunto combinado de tipos de destino dos operadores em `U`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-481">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="5b84e-482">Se não for possível encontrar exatamente um tipo mais abrangente, a conversão será ambígua e ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-482">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-483">Encontre o operador de conversão mais específico:</span><span class="sxs-lookup"><span data-stu-id="5b84e-483">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="5b84e-484">Se `U` contiver exatamente um operador de conversão definido pelo usuário que converta de `SX` para `TX`, esse será o operador de conversão mais específico.</span><span class="sxs-lookup"><span data-stu-id="5b84e-484">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="5b84e-485">Caso contrário, se `U` contiver exatamente um operador de conversão levantado que converta de `SX` para `TX`, esse será o operador de conversão mais específico.</span><span class="sxs-lookup"><span data-stu-id="5b84e-485">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="5b84e-486">Caso contrário, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-486">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-487">Por fim, aplique a conversão:</span><span class="sxs-lookup"><span data-stu-id="5b84e-487">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="5b84e-488">Se `S` não for `SX`, uma conversão implícita padrão de `S` para `SX` será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-488">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="5b84e-489">O operador de conversão mais específico é invocado para converter de `SX` para `TX`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-489">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="5b84e-490">Se `TX` não for `T`, uma conversão implícita padrão de `TX` para `T` será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-490">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="5b84e-491">Processamento de conversões explícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="5b84e-491">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="5b84e-492">Uma conversão explícita definida pelo usuário do tipo `S` para o tipo `T` é processada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="5b84e-492">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="5b84e-493">Determine os tipos `S0` e `T0`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-493">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="5b84e-494">Se `S` ou `T` forem tipos anuláveis, `S0` e `T0` serão os tipos subjacentes, caso contrário `S0` e `T0` serão iguais a `S` e `T`, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="5b84e-494">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="5b84e-495">Localize o conjunto de tipos, `D`, do qual os operadores de conversão definidos pelo usuário serão considerados.</span><span class="sxs-lookup"><span data-stu-id="5b84e-495">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="5b84e-496">Esse conjunto consiste em `S0` (se `S0` for uma classe ou struct), as classes base de `S0` (se `S0` for uma classe), `T0` (se `T0` for uma classe ou struct) e as classes base de `T0` (se `T0` for uma classe).</span><span class="sxs-lookup"><span data-stu-id="5b84e-496">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="5b84e-497">Localize o conjunto de operadores de conversão aplicáveis definidos pelo usuário e com elevação, `U`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-497">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="5b84e-498">Esse conjunto consiste nos operadores de conversão implícitos ou explícitos definidos pelo usuário, declarados pelas classes ou estruturas em `D` que são convertidos de um tipo que abrange ou abrangedo por `S` a um tipo que abrange ou abrangedo por `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-498">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="5b84e-499">Se `U` estiver vazio, a conversão será indefinida e ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-499">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-500">Localize o tipo de fonte mais específico, `SX`, dos operadores em `U`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-500">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="5b84e-501">Se qualquer um dos operadores em `U` converter de `S`, `SX` será `S`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-501">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="5b84e-502">Caso contrário, se qualquer um dos operadores em `U` converter de tipos que abrangem `S`, `SX` será o tipo mais abrangedo no conjunto combinado de tipos de origem desses operadores.</span><span class="sxs-lookup"><span data-stu-id="5b84e-502">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="5b84e-503">Se nenhum tipo mais abrangedo puder ser encontrado, a conversão será ambígua e ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-503">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="5b84e-504">Caso contrário, `SX` é o tipo mais abrangente no conjunto combinado de tipos de origem dos operadores em `U`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-504">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="5b84e-505">Se não for possível encontrar exatamente um tipo mais abrangente, a conversão será ambígua e ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-505">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-506">Localize o tipo de destino mais específico, `TX`, dos operadores em `U`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-506">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="5b84e-507">Se qualquer um dos operadores em `U` converter em `T`, `TX` será `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-507">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="5b84e-508">Caso contrário, se qualquer um dos operadores em `U` for convertido em tipos que são incluídos por `T`, `TX` será o tipo mais abrangente no conjunto combinado de tipos de destino desses operadores.</span><span class="sxs-lookup"><span data-stu-id="5b84e-508">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="5b84e-509">Se não for possível encontrar exatamente um tipo mais abrangente, a conversão será ambígua e ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-509">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="5b84e-510">Caso contrário, `TX` é o tipo mais abrangente no conjunto combinado de tipos de destino dos operadores em `U`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-510">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="5b84e-511">Se nenhum tipo mais abrangedo puder ser encontrado, a conversão será ambígua e ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-511">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-512">Encontre o operador de conversão mais específico:</span><span class="sxs-lookup"><span data-stu-id="5b84e-512">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="5b84e-513">Se `U` contiver exatamente um operador de conversão definido pelo usuário que converta de `SX` para `TX`, esse será o operador de conversão mais específico.</span><span class="sxs-lookup"><span data-stu-id="5b84e-513">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="5b84e-514">Caso contrário, se `U` contiver exatamente um operador de conversão levantado que converta de `SX` para `TX`, esse será o operador de conversão mais específico.</span><span class="sxs-lookup"><span data-stu-id="5b84e-514">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="5b84e-515">Caso contrário, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-515">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-516">Por fim, aplique a conversão:</span><span class="sxs-lookup"><span data-stu-id="5b84e-516">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="5b84e-517">Se `S` não for `SX`, uma conversão explícita padrão de `S` para `SX` será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-517">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="5b84e-518">O operador de conversão definido pelo usuário mais específico é invocado para converter de `SX` para `TX`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-518">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="5b84e-519">Se `TX` não for `T`, uma conversão explícita padrão de `TX` para `T` será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-519">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="5b84e-520">Conversões de função anônimas</span><span class="sxs-lookup"><span data-stu-id="5b84e-520">Anonymous function conversions</span></span>

<span data-ttu-id="5b84e-521">Uma *anonymous_method_expression* ou *lambda_expression* é classificada como uma função anônima ([expressões de função anônimas](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-521">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="5b84e-522">A expressão não tem um tipo, mas pode ser convertida implicitamente em um tipo de delegado ou tipo de árvore de expressão compatível.</span><span class="sxs-lookup"><span data-stu-id="5b84e-522">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="5b84e-523">Especificamente, uma função anônima `F` é compatível com um tipo delegado `D` fornecido:</span><span class="sxs-lookup"><span data-stu-id="5b84e-523">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="5b84e-524">Se `F` contiver um *anonymous_function_signature*, `D` e `F` terão o mesmo número de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="5b84e-524">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="5b84e-525">Se `F` não contiver um *anonymous_function_signature*, `D` poderá ter zero ou mais parâmetros de qualquer tipo, desde que nenhum parâmetro de `D` tenha o modificador de parâmetro `out`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-525">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="5b84e-526">Se `F` tiver uma lista de parâmetros tipados explicitamente, cada parâmetro em `D` terá o mesmo tipo e modificadores que o parâmetro correspondente no `F`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-526">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="5b84e-527">Se `F` tiver uma lista de parâmetros Tipados implicitamente, `D` não terá parâmetros `ref` ou `out`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-527">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="5b84e-528">Se o corpo de `F` for uma expressão e `D` tiver um tipo de retorno `void` ou `F` for Async e `D` tiver o tipo de retorno `Task`, quando cada parâmetro de `F` receber o tipo do parâmetro correspondente em `D`, o corpo de `F` será uma expressão válida (WRT [Expressions](expressions.md)) que seria permitida como uma *statement_expression* ([instruções Expression](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-528">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="5b84e-529">Se o corpo de `F` for um bloco de instrução e `D` tiver um tipo de retorno `void` ou `F` for Async e `D` tiver o tipo de retorno `Task`, quando cada parâmetro de `F` receber o tipo do parâmetro correspondente em `D`, o corpo de `F` será um bloco de instrução válido ( [blocos](statements.md#blocks)WRT) no qual nenhuma instrução `return` especifica uma expressão.</span><span class="sxs-lookup"><span data-stu-id="5b84e-529">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="5b84e-530">Se o corpo de `F` for uma expressão *e `F` não* for async e `D` tiver um tipo de retorno não void `T`*ou* `F` for Async e `D` tiver um tipo de retorno `Task<T>`, quando cada parâmetro de `F` receber o tipo do parâmetro correspondente em `D`, o corpo de `F` será uma expressão válida (WRT [Expressions](expressions.md)) que é implicitamente conversível em `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-530">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="5b84e-531">Se o corpo de `F` for um bloco de instrução e *`F` não for Async e `D`* tiver um tipo de retorno não nulo `T`, *ou* `F` é Async e `D` tem um tipo de retorno `Task<T>`, em seguida, quando cada parâmetro de `F` recebe o tipo do parâmetro correspondente em `D`, o corpo de `F` é um bloco de instrução válido ( [blocos](statements.md#blocks)WRT) com um ponto de extremidade não acessível no qual cada instrução `return` especifica uma expressão que é implicitamente conversível para `T`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-531">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="5b84e-532">Para fins de brevidade, esta seção usa a forma abreviada para os tipos de tarefa `Task` e `Task<T>` ([funções assíncronas](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-532">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="5b84e-533">Uma expressão lambda `F` é compatível com um tipo de árvore de expressão `Expression<D>` se `F` for compatível com o tipo de delegado `D`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-533">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="5b84e-534">Observe que isso não se aplica a métodos anônimos, somente expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="5b84e-534">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="5b84e-535">Determinadas expressões lambda não podem ser convertidas em tipos de árvore de expressões: mesmo que a conversão *exista*, ela falhará em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-535">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="5b84e-536">Esse é o caso se a expressão lambda:</span><span class="sxs-lookup"><span data-stu-id="5b84e-536">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="5b84e-537">Tem um corpo de *bloco*</span><span class="sxs-lookup"><span data-stu-id="5b84e-537">Has a *block* body</span></span>
*  <span data-ttu-id="5b84e-538">Contém operadores de atribuição simples ou compostos</span><span class="sxs-lookup"><span data-stu-id="5b84e-538">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="5b84e-539">Contém uma expressão vinculada dinamicamente</span><span class="sxs-lookup"><span data-stu-id="5b84e-539">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="5b84e-540">É Async</span><span class="sxs-lookup"><span data-stu-id="5b84e-540">Is async</span></span>

<span data-ttu-id="5b84e-541">Os exemplos a seguir usam um tipo de delegado genérico `Func<A,R>` que representa uma função que usa um argumento do tipo `A` e retorna um valor do tipo `R`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-541">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="5b84e-542">Nas atribuições</span><span class="sxs-lookup"><span data-stu-id="5b84e-542">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="5b84e-543">os tipos de parâmetro e de retorno de cada função anônima são determinados do tipo da variável à qual a função anônima é atribuída.</span><span class="sxs-lookup"><span data-stu-id="5b84e-543">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="5b84e-544">A primeira atribuição converte com êxito a função anônima para o tipo delegado `Func<int,int>` porque, quando `x` recebe o tipo `int`, `x+1` é uma expressão válida que é implicitamente conversível no tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-544">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="5b84e-545">Da mesma forma, a segunda atribuição converte com êxito a função anônima no tipo delegado `Func<int,double>` porque o resultado da `x+1` (do tipo `int`) é implicitamente conversível no tipo `double`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-545">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="5b84e-546">No entanto, a terceira atribuição é um erro de tempo de compilação porque, quando `x` é fornecido `double`de tipo, o resultado de `x+1` (do tipo `double`) não é implicitamente conversível para o tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-546">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="5b84e-547">A quarta atribuição converte com êxito a função Async anônima no tipo delegado `Func<int, Task<int>>` porque o resultado da `x+1` (do tipo `int`) é implicitamente conversível para o tipo de resultado `int` do tipo de tarefa `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-547">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="5b84e-548">As funções anônimas podem influenciar a resolução de sobrecarga e participar da inferência de tipos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-548">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="5b84e-549">Consulte [membros da função](expressions.md#function-members) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="5b84e-549">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="5b84e-550">Avaliação de conversões de função anônima para tipos delegados</span><span class="sxs-lookup"><span data-stu-id="5b84e-550">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="5b84e-551">A conversão de uma função anônima em um tipo delegate produz uma instância delegada que faz referência à função anônima e ao conjunto (possivelmente vazio) de variáveis externas capturadas que estão ativas no momento da avaliação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-551">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="5b84e-552">Quando o delegado é invocado, o corpo da função anônima é executado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-552">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="5b84e-553">O código no corpo é executado usando o conjunto de variáveis externas capturadas referenciadas pelo delegado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-553">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="5b84e-554">A lista de invocação de um delegado produzido por uma função anônima contém uma única entrada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-554">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="5b84e-555">O objeto de destino exato e o método de destino do delegado não são especificados.</span><span class="sxs-lookup"><span data-stu-id="5b84e-555">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="5b84e-556">Em particular, ele não é especificado se o objeto de destino do delegado é `null`, o valor `this` do membro da função delimitadora ou algum outro objeto.</span><span class="sxs-lookup"><span data-stu-id="5b84e-556">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="5b84e-557">Conversões de funções anônimas, semanticamente idênticas com o mesmo conjunto (possivelmente vazio) de instâncias de variáveis externas capturadas para os mesmos tipos delegados, são permitidas (mas não obrigatórias) para retornar a mesma instância de delegado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-557">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="5b84e-558">O termo semanticamente idêntico é usado aqui para significar que a execução das funções anônimas irá, em todos os casos, produzir os mesmos efeitos, considerando os mesmos argumentos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-558">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="5b84e-559">Essa regra permite que um código como o seguinte seja otimizado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-559">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="5b84e-560">Como os dois delegados de função anônimas têm o mesmo conjunto (vazio) de variáveis externas capturadas e, como as funções anônimas são semanticamente idênticas, o compilador tem permissão para fazer com que os delegados se refiram ao mesmo método de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-560">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="5b84e-561">Na verdade, o compilador tem permissão para retornar a mesma instância de delegado de ambas as expressões de função anônimas.</span><span class="sxs-lookup"><span data-stu-id="5b84e-561">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="5b84e-562">Avaliação de conversões de função anônima para tipos de árvore de expressão</span><span class="sxs-lookup"><span data-stu-id="5b84e-562">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="5b84e-563">A conversão de uma função anônima em um tipo de árvore de expressão produz uma árvore de expressão ([tipos de árvore de expressão](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-563">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="5b84e-564">Mais precisamente, a avaliação da conversão da função anônima leva à construção de uma estrutura de objeto que representa a estrutura da própria função anônima.</span><span class="sxs-lookup"><span data-stu-id="5b84e-564">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="5b84e-565">A estrutura precisa da árvore de expressão, bem como o processo exato para criá-la, são definidas para implementação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-565">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="5b84e-566">Exemplo de implementação</span><span class="sxs-lookup"><span data-stu-id="5b84e-566">Implementation example</span></span>

<span data-ttu-id="5b84e-567">Esta seção descreve uma possível implementação de conversões de função anônima em termos de outras C# construções.</span><span class="sxs-lookup"><span data-stu-id="5b84e-567">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="5b84e-568">A implementação descrita aqui se baseia nos mesmos princípios usados pelo compilador da Microsoft C# , mas não é por isso uma implementação obrigatória, nem é a única possível.</span><span class="sxs-lookup"><span data-stu-id="5b84e-568">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="5b84e-569">Ele apenas menciona conversões em árvores de expressão, pois a semântica exata está fora do escopo desta especificação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-569">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="5b84e-570">O restante desta seção fornece vários exemplos de código que contém funções anônimas com características diferentes.</span><span class="sxs-lookup"><span data-stu-id="5b84e-570">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="5b84e-571">Para cada exemplo, é fornecida uma tradução correspondente ao código que usa C# apenas outras construções.</span><span class="sxs-lookup"><span data-stu-id="5b84e-571">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="5b84e-572">Nos exemplos, o identificador `D` é assumido por representar o seguinte tipo de delegado:</span><span class="sxs-lookup"><span data-stu-id="5b84e-572">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="5b84e-573">A forma mais simples de uma função anônima é aquela que captura nenhuma variável externa:</span><span class="sxs-lookup"><span data-stu-id="5b84e-573">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="5b84e-574">Isso pode ser convertido em uma instanciação de delegado que faz referência a um método estático gerado pelo compilador no qual o código da função anônima é colocado:</span><span class="sxs-lookup"><span data-stu-id="5b84e-574">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="5b84e-575">No exemplo a seguir, a função anônima faz referência aos membros da instância de `this`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-575">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="5b84e-576">Isso pode ser convertido em um método de instância gerado pelo compilador que contém o código da função anônima:</span><span class="sxs-lookup"><span data-stu-id="5b84e-576">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="5b84e-577">Neste exemplo, a função anônima captura uma variável local:</span><span class="sxs-lookup"><span data-stu-id="5b84e-577">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="5b84e-578">O tempo de vida da variável local agora deve ser estendido para pelo menos o tempo de vida do delegado da função anônima.</span><span class="sxs-lookup"><span data-stu-id="5b84e-578">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="5b84e-579">Isso pode ser obtido por meio da "guindaste" da variável local em um campo de uma classe gerada pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="5b84e-579">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="5b84e-580">A instanciação da variável local ([instanciação de variáveis locais](expressions.md#instantiation-of-local-variables)) corresponde à criação de uma instância da classe gerada pelo compilador e o acesso à variável local corresponde ao acesso a um campo na instância da classe gerada pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="5b84e-580">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="5b84e-581">Além disso, a função anônima torna-se um método de instância da classe gerada pelo compilador:</span><span class="sxs-lookup"><span data-stu-id="5b84e-581">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="5b84e-582">Por fim, a função anônima a seguir captura `this`, bem como duas variáveis locais com tempos de vida diferentes:</span><span class="sxs-lookup"><span data-stu-id="5b84e-582">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="5b84e-583">Aqui, uma classe gerada pelo compilador é criada para cada bloco de instrução no qual os locais são capturados, de modo que os locais nos diferentes blocos possam ter tempos de vida independentes.</span><span class="sxs-lookup"><span data-stu-id="5b84e-583">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="5b84e-584">Uma instância de `__Locals2`, a classe gerada pelo compilador para o bloco de instrução interna, contém a variável local `z` e um campo que faz referência a uma instância de `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-584">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="5b84e-585">Uma instância de `__Locals1`, a classe gerada pelo compilador para o bloco de instrução externa, contém a variável local `y` e um campo que faz referência `this` do membro da função delimitadora.</span><span class="sxs-lookup"><span data-stu-id="5b84e-585">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="5b84e-586">Com essas estruturas de dados, é possível alcançar todas as variáveis externas capturadas por meio de uma instância do `__Local2`, e o código da função anônima pode, portanto, ser implementado como um método de instância dessa classe.</span><span class="sxs-lookup"><span data-stu-id="5b84e-586">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="5b84e-587">A mesma técnica aplicada aqui para capturar variáveis locais também pode ser usada ao converter funções anônimas em árvores de expressão: referências aos objetos gerados pelo compilador podem ser armazenadas na árvore de expressão e o acesso às variáveis locais pode ser representado como acessos de campo nesses objetos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-587">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="5b84e-588">A vantagem dessa abordagem é que ela permite que as variáveis locais "levantadas" sejam compartilhadas entre delegados e árvores de expressão.</span><span class="sxs-lookup"><span data-stu-id="5b84e-588">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="5b84e-589">Conversões de grupo de métodos</span><span class="sxs-lookup"><span data-stu-id="5b84e-589">Method group conversions</span></span>

<span data-ttu-id="5b84e-590">Uma conversão implícita ([conversões implícitas](conversions.md#implicit-conversions)) existe de um grupo de métodos ([classificações de expressão](expressions.md#expression-classifications)) para um tipo de delegado compatível.</span><span class="sxs-lookup"><span data-stu-id="5b84e-590">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="5b84e-591">Dado um tipo delegado `D` e uma expressão `E` classificada como um grupo de métodos, existe uma conversão implícita de `E` para `D` se `E` contiver pelo menos um método que seja aplicável em seu formato normal ([membro de função aplicável](expressions.md#applicable-function-member)) a uma lista de argumentos construída pelo uso dos tipos de parâmetro e modificadores de `D`, conforme descrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="5b84e-591">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="5b84e-592">O aplicativo de tempo de compilação de uma conversão de um grupo de métodos `E` a um tipo de delegado `D` é descrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="5b84e-592">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="5b84e-593">Observe que a existência de uma conversão implícita de `E` para `D` não garante que o aplicativo de tempo de compilação da conversão terá sucesso sem erros.</span><span class="sxs-lookup"><span data-stu-id="5b84e-593">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="5b84e-594">Um único método `M` é selecionado correspondente a uma invocação de método ([invocações de método](expressions.md#method-invocations)) do formulário `E(A)`, com as seguintes modificações:</span><span class="sxs-lookup"><span data-stu-id="5b84e-594">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="5b84e-595">A lista de argumentos `A` é uma lista de expressões, cada uma classificada como uma variável e com o tipo e o modificador (`ref` ou `out`) do parâmetro correspondente no *formal_parameter_list* de `D`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-595">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="5b84e-596">Os métodos candidatos considerados são apenas os métodos que são aplicáveis em seu formato normal ([membro de função aplicável](expressions.md#applicable-function-member)), não aqueles aplicáveis apenas em sua forma expandida.</span><span class="sxs-lookup"><span data-stu-id="5b84e-596">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="5b84e-597">Se o algoritmo das [invocações de método](expressions.md#method-invocations) produzir um erro, ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-597">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="5b84e-598">Caso contrário, o algoritmo produz um único método melhor `M` ter o mesmo número de parâmetros que `D` e a conversão é considerada como existe.</span><span class="sxs-lookup"><span data-stu-id="5b84e-598">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="5b84e-599">O método selecionado `M` deve ser compatível ([delegar compatibilidade](delegates.md#delegate-compatibility)) com o tipo delegado `D`ou, caso contrário, ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="5b84e-599">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="5b84e-600">Se o método selecionado `M` for um método de instância, a expressão de instância associada a `E` determinará o objeto de destino do delegado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-600">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="5b84e-601">Se o método selecionado M for um método de extensão indicado por meio de um acesso de membro em uma expressão de instância, essa expressão de instância determinará o objeto de destino do delegado.</span><span class="sxs-lookup"><span data-stu-id="5b84e-601">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="5b84e-602">O resultado da conversão é um valor do tipo `D`, ou seja, um delegado recém-criado que se refere ao método selecionado e ao objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-602">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="5b84e-603">Observe que esse processo pode levar à criação de um delegado para um método de extensão, se o algoritmo das [invocações de método](expressions.md#method-invocations) não conseguir encontrar um método de instância, mas tiver êxito no processamento da invocação de `E(A)` como uma invocação de método de extensão ([invocações de método de extensão](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="5b84e-603">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="5b84e-604">Um delegado criado então captura o método de extensão, bem como seu primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="5b84e-604">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="5b84e-605">O exemplo a seguir demonstra as conversões de grupo de métodos:</span><span class="sxs-lookup"><span data-stu-id="5b84e-605">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="5b84e-606">A atribuição para `d1` converte implicitamente o grupo de métodos `F` em um valor do tipo `D1`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-606">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="5b84e-607">A atribuição para `d2` mostra como é possível criar um delegado para um método que tenha tipos de parâmetro menos derivados (contravariant) e um tipo de retorno mais derivado (Covariance).</span><span class="sxs-lookup"><span data-stu-id="5b84e-607">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="5b84e-608">A atribuição para `d3` mostra como nenhuma conversão existe se o método não for aplicável.</span><span class="sxs-lookup"><span data-stu-id="5b84e-608">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="5b84e-609">A atribuição para `d4` mostra como o método deve ser aplicável em seu formato normal.</span><span class="sxs-lookup"><span data-stu-id="5b84e-609">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="5b84e-610">A atribuição para `d5` mostra como os tipos de parâmetro e de retorno do delegado e do método têm permissão para diferir somente para tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="5b84e-610">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="5b84e-611">Assim como acontece com todas as outras conversões implícitas e explícitas, o operador cast pode ser usado para executar explicitamente uma conversão de grupo de métodos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-611">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="5b84e-612">Portanto, o exemplo</span><span class="sxs-lookup"><span data-stu-id="5b84e-612">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="5b84e-613">em vez disso, poderia ser escrito</span><span class="sxs-lookup"><span data-stu-id="5b84e-613">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="5b84e-614">Os grupos de métodos podem influenciar a resolução de sobrecarga e participar da inferência de tipos.</span><span class="sxs-lookup"><span data-stu-id="5b84e-614">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="5b84e-615">Consulte [membros da função](expressions.md#function-members) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="5b84e-615">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="5b84e-616">A avaliação de tempo de execução de uma conversão de grupo de métodos procede da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="5b84e-616">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="5b84e-617">Se o método selecionado em tempo de compilação for um método de instância, ou for um método de extensão que é acessado como um método de instância, o objeto de destino do delegado é determinado da expressão de instância associada ao `E`:</span><span class="sxs-lookup"><span data-stu-id="5b84e-617">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="5b84e-618">A expressão de instância é avaliada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-618">The instance expression is evaluated.</span></span> <span data-ttu-id="5b84e-619">Se essa avaliação causar uma exceção, nenhuma etapa adicional será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-619">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="5b84e-620">Se a expressão de instância for de um *reference_type*, o valor calculado pela expressão de instância se tornará o objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-620">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="5b84e-621">Se o método selecionado for um método de instância e o objeto de destino for `null`, um `System.NullReferenceException` será lançado e nenhuma etapa adicional será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-621">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="5b84e-622">Se a expressão de instância for de um *value_type*, uma operação Boxing ([conversões Boxing](types.md#boxing-conversions)) será executada para converter o valor em um objeto e esse objeto se tornará o objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="5b84e-622">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="5b84e-623">Caso contrário, o método selecionado faz parte de uma chamada de método estático e o objeto de destino do delegado é `null`.</span><span class="sxs-lookup"><span data-stu-id="5b84e-623">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="5b84e-624">Uma nova instância do tipo delegado `D` é alocada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-624">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="5b84e-625">Se não houver memória suficiente disponível para alocar a nova instância, um `System.OutOfMemoryException` será lançado e nenhuma etapa adicional será executada.</span><span class="sxs-lookup"><span data-stu-id="5b84e-625">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="5b84e-626">A nova instância de delegado é inicializada com uma referência ao método que foi determinado em tempo de compilação e uma referência ao objeto de destino calculado acima.</span><span class="sxs-lookup"><span data-stu-id="5b84e-626">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>

---
ms.openlocfilehash: 61eeae6173eaa19f9cf6d6e985f3dc107d4c3ac9
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/25/2019
ms.locfileid: "64488952"
---
# <a name="conversions"></a><span data-ttu-id="7ac45-101">Conversões</span><span class="sxs-lookup"><span data-stu-id="7ac45-101">Conversions</span></span>

<span data-ttu-id="7ac45-102">Um ***conversão*** permite que uma expressão a ser tratada como sendo de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="7ac45-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="7ac45-103">Uma conversão pode causar uma expressão de um tipo específico para ser tratada como tendo um tipo diferente, ou pode fazer com que uma expressão sem um tipo para obter um tipo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="7ac45-104">As conversões podem ser ***implícita*** ou ***explícita***, e isso determina se uma conversão explícita é necessária.</span><span class="sxs-lookup"><span data-stu-id="7ac45-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="7ac45-105">Por exemplo, a conversão do tipo `int` digitar `long` é implícito, portanto, expressões do tipo `int` implicitamente pode ser tratado como tipo `long`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="7ac45-106">A conversão oposta, do tipo `long` digitar `int`, é explícito e, portanto, uma conversão explícita é necessária.</span><span class="sxs-lookup"><span data-stu-id="7ac45-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="7ac45-107">Algumas conversões são definidos pela linguagem.</span><span class="sxs-lookup"><span data-stu-id="7ac45-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="7ac45-108">Programas também podem definir suas próprias conversões ([conversões definidas pelo usuário](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="7ac45-109">Conversões implícitas</span><span class="sxs-lookup"><span data-stu-id="7ac45-109">Implicit conversions</span></span>

<span data-ttu-id="7ac45-110">As conversões a seguir são classificadas como conversões implícitas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="7ac45-111">Conversões de identidade</span><span class="sxs-lookup"><span data-stu-id="7ac45-111">Identity conversions</span></span>
*  <span data-ttu-id="7ac45-112">Conversões numéricas implícitas</span><span class="sxs-lookup"><span data-stu-id="7ac45-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="7ac45-113">Conversões implícitas de enumeração.</span><span class="sxs-lookup"><span data-stu-id="7ac45-113">Implicit enumeration conversions.</span></span>
*  <span data-ttu-id="7ac45-114">Conversões implícitas de permite valor nulas</span><span class="sxs-lookup"><span data-stu-id="7ac45-114">Implicit nullable conversions</span></span>
*  <span data-ttu-id="7ac45-115">Conversões de literais nulas</span><span class="sxs-lookup"><span data-stu-id="7ac45-115">Null literal conversions</span></span>
*  <span data-ttu-id="7ac45-116">Conversões de referência implícita</span><span class="sxs-lookup"><span data-stu-id="7ac45-116">Implicit reference conversions</span></span>
*  <span data-ttu-id="7ac45-117">Conversões boxing</span><span class="sxs-lookup"><span data-stu-id="7ac45-117">Boxing conversions</span></span>
*  <span data-ttu-id="7ac45-118">Conversões implícitas de dinâmicas</span><span class="sxs-lookup"><span data-stu-id="7ac45-118">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="7ac45-119">Conversões implícitas de expressão de constante</span><span class="sxs-lookup"><span data-stu-id="7ac45-119">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="7ac45-120">Conversões implícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="7ac45-120">User-defined implicit conversions</span></span>
*  <span data-ttu-id="7ac45-121">Conversões de função anônima</span><span class="sxs-lookup"><span data-stu-id="7ac45-121">Anonymous function conversions</span></span>
*  <span data-ttu-id="7ac45-122">Conversões de grupo de método</span><span class="sxs-lookup"><span data-stu-id="7ac45-122">Method group conversions</span></span>

<span data-ttu-id="7ac45-123">Conversões implícitas podem ocorrer em uma variedade de situações, incluindo as invocações de função de membro ([verificação de resolução de sobrecarga de dinâmica de tempo de compilação](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), expressões de conversão ([expressões de conversão](expressions.md#cast-expressions)), atribuições e ([operadores de atribuição](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-123">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="7ac45-124">As conversões implícitas predefinidas sempre têm êxito e nunca fazer com que exceções sejam geradas.</span><span class="sxs-lookup"><span data-stu-id="7ac45-124">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="7ac45-125">Projetado corretamente conversões implícitas definidas pelo usuário devem apresentar as seguintes características.</span><span class="sxs-lookup"><span data-stu-id="7ac45-125">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="7ac45-126">Para fins de conversão, os tipos `object` e `dynamic` são considerados equivalentes.</span><span class="sxs-lookup"><span data-stu-id="7ac45-126">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="7ac45-127">No entanto, conversões dinâmicas ([conversões implícitas de dinâmicas](conversions.md#implicit-dynamic-conversions) e [conversões explícitas de dinâmicas](conversions.md#explicit-dynamic-conversions)) se aplicam somente a expressões do tipo `dynamic` ([tipo dinâmico](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-127">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="7ac45-128">Conversão de identidade</span><span class="sxs-lookup"><span data-stu-id="7ac45-128">Identity conversion</span></span>

<span data-ttu-id="7ac45-129">Converte uma conversão de identidade de qualquer tipo para o mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-129">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="7ac45-130">Essa conversão existe, de modo que uma entidade que já tem um tipo necessário pode ser dito para poder ser convertido para esse tipo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-130">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="7ac45-131">Como o objeto e dinâmicas são considerados equivalentes não há uma conversão de identidade entre `object` e `dynamic`e entre os tipos construídos são iguais ao substituir todas as ocorrências de `dynamic` com `object`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-131">Because object and dynamic are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="7ac45-132">Conversões numéricas implícitas</span><span class="sxs-lookup"><span data-stu-id="7ac45-132">Implicit numeric conversions</span></span>

<span data-ttu-id="7ac45-133">As conversões numéricas implícitas são:</span><span class="sxs-lookup"><span data-stu-id="7ac45-133">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="7ac45-134">Partir `sbyte` à `short`, `int`, `long`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-134">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-135">Partir `byte` à `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-135">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-136">Partir `short` à `int`, `long`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-136">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-137">Partir `ushort` à `int`, `uint`, `long`, `ulong`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-137">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-138">Partir `int` à `long`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-138">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-139">Partir `uint` à `long`, `ulong`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-139">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-140">Partir `long` à `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-140">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-141">Partir `ulong` à `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-141">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-142">Partir `char` à `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-142">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-143">Partir `float` para `double`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-143">From `float` to `double`.</span></span>

<span data-ttu-id="7ac45-144">Conversões de `int`, `uint`, `long`, ou `ulong` para `float` e do `long` ou `ulong` para `double` pode causar perda de precisão, mas nunca será causa uma perda de magnitude.</span><span class="sxs-lookup"><span data-stu-id="7ac45-144">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="7ac45-145">As outras conversões numéricas implícitas nunca perdem todas as informações.</span><span class="sxs-lookup"><span data-stu-id="7ac45-145">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="7ac45-146">Não há nenhuma conversão implícita para o `char` de tipo, portanto, os valores dos outros tipos integrais não são automaticamente convertidos a `char` tipo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-146">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="7ac45-147">Conversões implícitas de enumeração</span><span class="sxs-lookup"><span data-stu-id="7ac45-147">Implicit enumeration conversions</span></span>

<span data-ttu-id="7ac45-148">Permite que uma conversão implícita de enumeração de *decimal_integer_literal* `0` a ser convertido em qualquer *enum_type* e para qualquer *nullable_type* cujo o tipo subjacente é um *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-148">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="7ac45-149">No último caso a conversão é avaliada, convertendo para subjacente *enum_type* e o resultado de encapsulamento ([tipos anuláveis](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-149">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="7ac45-150">Conversões implícitas de cadeia de caracteres interpolada</span><span class="sxs-lookup"><span data-stu-id="7ac45-150">Implicit interpolated string conversions</span></span>

<span data-ttu-id="7ac45-151">Implícito de autorizações de conversão de cadeia de caracteres interpolada uma *interpolated_string_expression* ([cadeias de caracteres interpoladas](expressions.md#interpolated-strings)) a ser convertido em `System.IFormattable` ou `System.FormattableString` (que implementa `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="7ac45-151">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="7ac45-152">Quando essa conversão é aplicada a um valor de cadeia de caracteres não é composto da cadeia de caracteres interpolada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-152">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="7ac45-153">Em vez disso, uma instância do `System.FormattableString` é criada, conforme descrito em [cadeias de caracteres interpoladas](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="7ac45-153">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="7ac45-154">Conversões implícitas de permite valor nulas</span><span class="sxs-lookup"><span data-stu-id="7ac45-154">Implicit nullable conversions</span></span>

<span data-ttu-id="7ac45-155">Conversões implícitas predefinidas que operam em tipos de valor não anulável também podem ser usadas com os formulários que permitem valor nulos desses tipos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-155">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="7ac45-156">Para cada identidade implícitas predefinida e conversões numéricas convertem de um tipo de valor não anulável `S` para um tipo de valor não anulável `T`, existem as seguintes conversões implícitas que permitem valor nulas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-156">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="7ac45-157">Uma conversão implícita da `S?` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-157">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="7ac45-158">Uma conversão implícita da `S` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-158">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="7ac45-159">Avaliação de uma conversão implícita de permite valor nula com base em uma conversão subjacente de `S` para `T` procede da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7ac45-159">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="7ac45-160">Se a conversão que permitem valor nula é de `S?` para `T?`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-160">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="7ac45-161">Se o valor de origem é nulo (`HasValue` propriedade é false), o resultado é o valor nulo do tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-161">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="7ac45-162">Caso contrário, a conversão será avaliada como um desempacotamento do `S?` para `S`, seguido pela conversão de base `S` ao `T`, seguido por um encapsulamento ([tipos anuláveis](types.md#nullable-types)) de `T` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-162">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="7ac45-163">Se a conversão que permitem valor nula é de `S` para `T?`, a conversão é avaliada como a conversão subjacente do `S` à `T` seguido por um encapsulamento de `T` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-163">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="7ac45-164">Conversões de literais nulas</span><span class="sxs-lookup"><span data-stu-id="7ac45-164">Null literal conversions</span></span>

<span data-ttu-id="7ac45-165">Existe uma conversão implícita do `null` literal a qualquer tipo que permite valor nulo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-165">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="7ac45-166">Essa conversão produz o valor nulo ([tipos anuláveis](types.md#nullable-types)) do tipo que permite valor nulo fornecido.</span><span class="sxs-lookup"><span data-stu-id="7ac45-166">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="7ac45-167">Conversões de referência implícita</span><span class="sxs-lookup"><span data-stu-id="7ac45-167">Implicit reference conversions</span></span>

<span data-ttu-id="7ac45-168">As conversões de referência implícita são:</span><span class="sxs-lookup"><span data-stu-id="7ac45-168">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="7ac45-169">De qualquer *reference_type* à `object` e `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-169">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="7ac45-170">De qualquer *class_type* `S` a qualquer *class_type* `T`, fornecido `S` é derivado de `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-170">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="7ac45-171">De qualquer *class_type* `S` a qualquer *interface_type* `T`, fornecido `S` implementa `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-171">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="7ac45-172">De qualquer *interface_type* `S` a qualquer *interface_type* `T`, fornecido `S` é derivado de `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-172">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="7ac45-173">De um *array_type* `S` com um tipo de elemento `SE` para um *array_type* `T` com um tipo de elemento `TE`, desde que todos os itens a seguir forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="7ac45-173">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="7ac45-174">`S` e `T` diferem apenas no tipo de elemento.</span><span class="sxs-lookup"><span data-stu-id="7ac45-174">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="7ac45-175">Em outras palavras, `S` e `T` têm o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="7ac45-175">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="7ac45-176">Ambos `SE` e `TE` são *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="7ac45-176">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="7ac45-177">Existe uma conversão de referência implícita da `SE` para `TE`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-177">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="7ac45-178">De qualquer *array_type* para `System.Array` e as interfaces que ele implementa.</span><span class="sxs-lookup"><span data-stu-id="7ac45-178">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="7ac45-179">De um tipo de matriz unidimensional `S[]` à `System.Collections.Generic.IList<T>` e suas interfaces base, fornecidos o que há uma conversão implícita de identidade ou referência de `S` para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-179">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="7ac45-180">De qualquer *delegate_type* para `System.Delegate` e as interfaces que ele implementa.</span><span class="sxs-lookup"><span data-stu-id="7ac45-180">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="7ac45-181">De que o literal nulo para qualquer *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-181">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="7ac45-182">De qualquer *reference_type* para um *reference_type* `T` se ele tem uma conversão implícita de identidade ou uma referência a um *reference_type* `T0` e `T0` tem uma conversão de identidade para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-182">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="7ac45-183">De qualquer *reference_type* a um tipo de interface ou delegado `T` se ele tem uma conversão implícita de identidade ou uma referência a um tipo de interface ou delegado `T0` e `T0` é convertido por variância ([ Conversão de variância](interfaces.md#variance-conversion)) para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-183">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="7ac45-184">Conversões implícitas que envolvem parâmetros de tipo que são conhecidos como tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="7ac45-184">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="7ac45-185">Ver [conversões implícitas que envolvem parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters) para obter mais detalhes sobre as conversões implícitas que envolvem parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-185">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="7ac45-186">As conversões implícitas de referência são conversões entre *reference_type*s que podem ser comprovados por sempre têm êxito e, portanto, não exigem nenhuma verificação em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="7ac45-186">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="7ac45-187">Conversões de referência, implícitas ou explícitas, nunca altere a identidade referencial do objeto que está sendo convertido.</span><span class="sxs-lookup"><span data-stu-id="7ac45-187">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="7ac45-188">Em outras palavras, enquanto uma conversão de referência pode alterar o tipo de referência, ele nunca muda o tipo ou o valor do objeto que está sendo referenciado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-188">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="7ac45-189">Conversões boxing</span><span class="sxs-lookup"><span data-stu-id="7ac45-189">Boxing conversions</span></span>

<span data-ttu-id="7ac45-190">Permite que uma conversão boxing um *value_type* a ser convertido implicitamente em um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="7ac45-190">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="7ac45-191">Uma conversão boxing existe em qualquer *non_nullable_value_type* para `object` e `dynamic`, para `System.ValueType` e para qualquer *interface_type* implementado pelo *non_ nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-191">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="7ac45-192">Além de uma *enum_type* pode ser convertido no tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-192">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="7ac45-193">Há uma conversão boxing de uma *nullable_type* a um tipo de referência, se e somente se uma conversão boxing existe da subjacente *non_nullable_value_type* para o tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="7ac45-193">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="7ac45-194">Um tipo de valor tem uma conversão de boxing para um tipo de interface `I` se ele tem uma conversão de boxing para um tipo de interface `I0` e `I0` tem uma conversão de identidade para `I`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-194">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="7ac45-195">Um tipo de valor tem uma conversão de boxing para um tipo de interface `I` se ele tem uma conversão boxing para um tipo de interface ou delegado `I0` e `I0` é convertido por variância ([conversão de variância](interfaces.md#variance-conversion)) para `I`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="7ac45-196">Conversão boxing de um valor de uma *non_nullable_value_type* consiste de alocar uma instância do objeto e copiando o *value_type* valor para essa instância.</span><span class="sxs-lookup"><span data-stu-id="7ac45-196">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="7ac45-197">Um struct pode ser convertido no tipo `System.ValueType`, já que é uma classe base para todos os structs ([herança](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-197">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="7ac45-198">Conversão boxing de um valor de uma *nullable_type* procede da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7ac45-198">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="7ac45-199">Se o valor de origem é nulo (`HasValue` propriedade é false), o resultado é uma referência nula do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-199">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="7ac45-200">Caso contrário, o resultado é uma referência a um demarcado `T` produzidos por desempacotamento e conversão boxing o valor de origem.</span><span class="sxs-lookup"><span data-stu-id="7ac45-200">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="7ac45-201">Conversões boxing serão descritas detalhadamente em [conversões Boxing](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="7ac45-201">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="7ac45-202">Conversões implícitas de dinâmicas</span><span class="sxs-lookup"><span data-stu-id="7ac45-202">Implicit dynamic conversions</span></span>

<span data-ttu-id="7ac45-203">Uma conversão implícita de dinâmica existe a partir de uma expressão do tipo `dynamic` a qualquer tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-203">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="7ac45-204">A conversão é associada dinamicamente ([vinculação dinâmica](expressions.md#dynamic-binding)), o que significa que uma conversão implícita será procurada em tempo de execução do tipo da expressão em tempo de execução `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-204">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="7ac45-205">Se nenhuma conversão for encontrada, uma exceção de tempo de execução é gerada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-205">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="7ac45-206">Observe que essa conversão implícita aparentemente viola o aviso no início da [conversões implícitas](conversions.md#implicit-conversions) que uma conversão implícita nunca deve causar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="7ac45-206">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="7ac45-207">No entanto não é a conversão em si, mas o *Localizando* da conversão que faz com que a exceção.</span><span class="sxs-lookup"><span data-stu-id="7ac45-207">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="7ac45-208">O risco de exceções de tempo de execução é inerente no uso de associação dinâmica.</span><span class="sxs-lookup"><span data-stu-id="7ac45-208">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="7ac45-209">Se a associação dinâmica da conversão não for desejada, a expressão pode ser convertida pela primeira vez para `object`e, em seguida, para o tipo desejado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-209">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="7ac45-210">O exemplo a seguir ilustra as conversões implícitas dinâmicas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-210">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="7ac45-211">As atribuições para `s2` e `i` ambos empregam conversões implícitas de dinâmicas, onde a associação das operações é suspenso até que o tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="7ac45-211">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="7ac45-212">Em tempo de execução, as conversões implícitas são buscadas do tipo de tempo de execução da `d`  --  `string` – para o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-212">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="7ac45-213">Uma conversão for encontrada para `string` , mas não ao `int`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-213">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="7ac45-214">Conversões implícitas de expressão de constante</span><span class="sxs-lookup"><span data-stu-id="7ac45-214">Implicit constant expression conversions</span></span>

<span data-ttu-id="7ac45-215">Uma conversão implícita de expressão de constante permite que as conversões a seguir:</span><span class="sxs-lookup"><span data-stu-id="7ac45-215">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="7ac45-216">Um *constant_expression* ([expressões constantes](expressions.md#constant-expressions)) do tipo `int` pode ser convertido no tipo `sbyte`, `byte`, `short`, `ushort`, `uint`, ou `ulong`, o valor de fornecido a *constant_expression* está dentro do intervalo do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-216">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="7ac45-217">Um *constant_expression* do tipo `long` pode ser convertido no tipo `ulong`, fornecido o valor da *constant_expression* não é negativo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-217">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="7ac45-218">Conversões implícitas que envolvem parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="7ac45-218">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="7ac45-219">As seguintes conversões implícitas existem para um parâmetro de tipo em questão `T`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-219">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="7ac45-220">Da `T` à sua classe base efetivo `C`, do `T` a qualquer classe base do `C`e de `T` a qualquer interface implementada por `C`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-220">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="7ac45-221">No tempo de execução, se `T` é um tipo de valor, a conversão é executada como uma conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="7ac45-221">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="7ac45-222">Caso contrário, a conversão é executada como uma conversão de referência implícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="7ac45-222">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="7ac45-223">Da `T` para um tipo de interface `I` na `T`interface eficiente conjunto e de `T` a qualquer interface base de `I`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-223">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="7ac45-224">No tempo de execução, se `T` é um tipo de valor, a conversão é executada como uma conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="7ac45-224">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="7ac45-225">Caso contrário, a conversão é executada como uma conversão de referência implícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="7ac45-225">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="7ac45-226">Partir `T` para um parâmetro de tipo `U`, fornecida `T` depende `U` ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-226">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="7ac45-227">No tempo de execução, se `U` é um tipo de valor, em seguida, `T` e `U` são necessariamente do mesmo tipo e nenhuma conversão é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-227">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="7ac45-228">Caso contrário, se `T` é um tipo de valor, a conversão é executada como uma conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="7ac45-228">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="7ac45-229">Caso contrário, a conversão é executada como uma conversão de referência implícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="7ac45-229">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="7ac45-230">De que o literal nulo para `T`, fornecida `T` é conhecido por ser um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="7ac45-230">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="7ac45-231">Partir `T` para um tipo de referência `I` se ele tem uma conversão implícita para um tipo de referência `S0` e `S0` tem uma conversão de identidade para `S`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-231">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="7ac45-232">Em tempo de execução, a conversão é executada da mesma maneira que a conversão em `S0`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-232">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="7ac45-233">Partir `T` para um tipo de interface `I` se ele tem uma conversão implícita para um tipo de interface ou delegado `I0` e `I0` é convertido por variância para `I` ([conversão de variância](interfaces.md#variance-conversion) ).</span><span class="sxs-lookup"><span data-stu-id="7ac45-233">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="7ac45-234">No tempo de execução, se `T` é um tipo de valor, a conversão é executada como uma conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="7ac45-234">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="7ac45-235">Caso contrário, a conversão é executada como uma conversão de referência implícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="7ac45-235">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="7ac45-236">Se `T` é conhecido por ser um tipo de referência ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)), as conversões acima são classificadas como conversões de referência implícita ([conversões de referência implícita](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-236">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="7ac45-237">Se `T` não for conhecido como um tipo de referência, as conversões acima são classificadas como conversões boxing ([conversões Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-237">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="7ac45-238">Conversões implícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="7ac45-238">User-defined implicit conversions</span></span>

<span data-ttu-id="7ac45-239">Uma conversão implícita definidas pelo usuário consiste em uma opcional padrão conversão implícita, seguida pela execução de um operador de conversão implícita definidas pelo usuário, seguido por outra opcional padrão conversão implícita.</span><span class="sxs-lookup"><span data-stu-id="7ac45-239">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="7ac45-240">As regras exatas para avaliar as conversões implícitas definidas pelo usuário são descritas em [processamento de conversões implícitas definidas pelo usuário](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="7ac45-240">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="7ac45-241">Conversões de função anônima e conversões de grupo de método</span><span class="sxs-lookup"><span data-stu-id="7ac45-241">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="7ac45-242">Funções anônimas e grupos de métodos não têm tipos de em e de si mesmo, mas podem ser convertidos implicitamente para delegar a tipos ou tipos de árvore de expressão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-242">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="7ac45-243">Conversões de função anônima são descritas mais detalhadamente [conversões de função anônima](conversions.md#anonymous-function-conversions) e conversões de grupo de método em [conversões de grupo de método](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="7ac45-243">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="7ac45-244">Conversões explícitas</span><span class="sxs-lookup"><span data-stu-id="7ac45-244">Explicit conversions</span></span>

<span data-ttu-id="7ac45-245">As conversões a seguir são classificadas como conversões explícitas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-245">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="7ac45-246">Todas as conversões implícitas.</span><span class="sxs-lookup"><span data-stu-id="7ac45-246">All implicit conversions.</span></span>
*  <span data-ttu-id="7ac45-247">Conversões numéricas explícitas.</span><span class="sxs-lookup"><span data-stu-id="7ac45-247">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="7ac45-248">Conversões explícitas de enumeração.</span><span class="sxs-lookup"><span data-stu-id="7ac45-248">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="7ac45-249">Conversões explícitas de permite valor nulas.</span><span class="sxs-lookup"><span data-stu-id="7ac45-249">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="7ac45-250">Conversões de referência explícita.</span><span class="sxs-lookup"><span data-stu-id="7ac45-250">Explicit reference conversions.</span></span>
*  <span data-ttu-id="7ac45-251">Conversões explícitas de interface.</span><span class="sxs-lookup"><span data-stu-id="7ac45-251">Explicit interface conversions.</span></span>
*  <span data-ttu-id="7ac45-252">Conversões de conversão unboxing.</span><span class="sxs-lookup"><span data-stu-id="7ac45-252">Unboxing conversions.</span></span>
*  <span data-ttu-id="7ac45-253">Conversões explícitas de dinâmicas</span><span class="sxs-lookup"><span data-stu-id="7ac45-253">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="7ac45-254">Conversões explícitas definidas pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="7ac45-254">User-defined explicit conversions.</span></span>

<span data-ttu-id="7ac45-255">Conversões explícitas podem ocorrer em expressões de conversão ([expressões de conversão](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-255">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="7ac45-256">O conjunto de conversões explícitas inclui todas as conversões implícitas.</span><span class="sxs-lookup"><span data-stu-id="7ac45-256">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="7ac45-257">Isso significa que as expressões de conversão redundantes são permitidas.</span><span class="sxs-lookup"><span data-stu-id="7ac45-257">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="7ac45-258">As conversões explícitas que não são as conversões implícitas são conversões que não podem ser comprovadas sempre tenha êxito, conversões que são conhecidas como possivelmente perder informações e conversões entre domínios de tipos diferentes o suficiente para mérito explícito notação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-258">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="7ac45-259">Conversões numéricas explícitas</span><span class="sxs-lookup"><span data-stu-id="7ac45-259">Explicit numeric conversions</span></span>

<span data-ttu-id="7ac45-260">Conversões numéricas explícitas são as conversões de um *numeric_type* para outra *numeric_type* para o qual uma conversão numérica implícita ([conversões numéricas implícitas](conversions.md#implicit-numeric-conversions)) ainda não existir:</span><span class="sxs-lookup"><span data-stu-id="7ac45-260">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="7ac45-261">Partir `sbyte` à `byte`, `ushort`, `uint`, `ulong`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-261">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="7ac45-262">Partir `byte` à `sbyte` e `char`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-262">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="7ac45-263">Partir `short` à `sbyte`, `byte`, `ushort`, `uint`, `ulong`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-263">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="7ac45-264">Partir `ushort` à `sbyte`, `byte`, `short`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-264">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="7ac45-265">Partir `int` à `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-265">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="7ac45-266">Partir `uint` à `sbyte`, `byte`, `short`, `ushort`, `int`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-266">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="7ac45-267">Partir `long` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-267">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="7ac45-268">Partir `ulong` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-268">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="7ac45-269">Partir `char` à `sbyte`, `byte`, ou `short`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-269">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="7ac45-270">Partir `float` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-270">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-271">Partir `double` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-271">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-272">Partir `decimal` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, ou `double`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-272">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="7ac45-273">Como as conversões explícitas incluem todas as conversões numéricas implícitas e explícitas, sempre é possível converter de qualquer *numeric_type* a qualquer outra *numeric_type* usando um (expressão de conversão [Expressões de conversão](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-273">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="7ac45-274">Conversões numéricas explícitas, possivelmente, perder informações ou possivelmente fazer com que exceções sejam geradas.</span><span class="sxs-lookup"><span data-stu-id="7ac45-274">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="7ac45-275">Uma conversão numérica explícita é processada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7ac45-275">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="7ac45-276">Para uma conversão de um tipo integral em outro tipo integral, o processamento depende do contexto de verificação de estouro ([os operadores marcados e desmarcados](expressions.md#the-checked-and-unchecked-operators)) em que a conversão usa coloque:</span><span class="sxs-lookup"><span data-stu-id="7ac45-276">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="7ac45-277">Em um `checked` contexto, a conversão for bem-sucedida se o valor do operando de origem está dentro do intervalo do tipo de destino, mas gera um `System.OverflowException` se o valor do operando de origem está fora do intervalo do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-277">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="7ac45-278">Em um `unchecked` contexto, a conversão sempre terá êxito e procede da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="7ac45-278">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="7ac45-279">Se o tipo de origem for maior do que o tipo de destino, então o valor de origem será truncado descartando seus bits "extra" mais significativos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-279">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="7ac45-280">O resultado é então tratado como um valor do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-280">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="7ac45-281">Se o tipo de origem for menor do que o tipo de destino, então o valor de origem será estendido por sinal ou por zero para que tenha o mesmo tamanho que o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-281">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="7ac45-282">A extensão por sinal será usada se o tipo de origem tiver sinal; a extensão por zero será usada se o tipo de origem não tiver sinal.</span><span class="sxs-lookup"><span data-stu-id="7ac45-282">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="7ac45-283">O resultado é então tratado como um valor do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-283">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="7ac45-284">Se o tipo de origem tiver o mesmo tamanho que o tipo de destino, então o valor de origem será tratado como um valor do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-284">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="7ac45-285">Para uma conversão de `decimal` para um tipo integral, o valor de origem será arredondado para zero para o valor inteiro mais próximo, e esse valor integral torna-se o resultado da conversão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-285">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="7ac45-286">Se o valor integral resultante estiver fora do intervalo do tipo de destino, um `System.OverflowException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-286">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="7ac45-287">Para uma conversão de `float` ou `double` para um tipo integral, o processamento depende do contexto de verificação de estouro ([os operadores marcados e desmarcados](expressions.md#the-checked-and-unchecked-operators)) em que a conversão usa coloque:</span><span class="sxs-lookup"><span data-stu-id="7ac45-287">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="7ac45-288">Em um `checked` contexto, a conversão ocorre da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7ac45-288">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="7ac45-289">Se o valor do operando for NaN ou infinito, um `System.OverflowException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-289">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="7ac45-290">Caso contrário, o operando de origem será arredondado para zero para o valor inteiro mais próximo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-290">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="7ac45-291">Se esse valor integral é dentro do intervalo de tipo de destino, em seguida, esse valor é o resultado da conversão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-291">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="7ac45-292">Caso contrário, uma `System.OverflowException` será gerada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-292">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="7ac45-293">Em um `unchecked` contexto, a conversão sempre terá êxito e procede da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="7ac45-293">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="7ac45-294">Se o valor do operando é NaN ou infinito, o resultado da conversão é um valor não especificado do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-294">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="7ac45-295">Caso contrário, o operando de origem será arredondado para zero para o valor inteiro mais próximo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-295">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="7ac45-296">Se esse valor integral é dentro do intervalo de tipo de destino, em seguida, esse valor é o resultado da conversão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-296">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="7ac45-297">Caso contrário, o resultado da conversão é um valor não especificado do tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-297">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="7ac45-298">Para uma conversão de `double` à `float`, o `double` valor é arredondado para mais próximo `float` valor.</span><span class="sxs-lookup"><span data-stu-id="7ac45-298">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="7ac45-299">Se o `double` valor for muito pequeno para ser representado como um `float`, o resultado se torna zero positivo ou negativo de zero.</span><span class="sxs-lookup"><span data-stu-id="7ac45-299">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="7ac45-300">Se o `double` valor é muito grande para ser representado como um `float`, o resultado se torna o infinito positivo ou negativo infinito.</span><span class="sxs-lookup"><span data-stu-id="7ac45-300">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="7ac45-301">Se o `double` valor é NaN, o resultado também é NaN.</span><span class="sxs-lookup"><span data-stu-id="7ac45-301">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="7ac45-302">Para uma conversão de `float` ou `double` à `decimal`, o valor de origem é convertido em `decimal` representação e arredondado para o próximo número após a 28ª casa decimal, se necessário ([o tipo decimal](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-302">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="7ac45-303">Se o valor de origem é muito pequeno para ser representado como um `decimal`, o resultado será zero.</span><span class="sxs-lookup"><span data-stu-id="7ac45-303">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="7ac45-304">Se o valor de origem for NaN, infinito, ou muito grande para ser representado como uma `decimal`, um `System.OverflowException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-304">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="7ac45-305">Para uma conversão de `decimal` à `float` ou `double`, o `decimal` valor é arredondado para mais próximo `double` ou `float` valor.</span><span class="sxs-lookup"><span data-stu-id="7ac45-305">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="7ac45-306">Embora essa conversão pode perder a precisão, ele nunca faz com que uma exceção seja lançada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-306">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="7ac45-307">Conversões explícitas de enumeração</span><span class="sxs-lookup"><span data-stu-id="7ac45-307">Explicit enumeration conversions</span></span>

<span data-ttu-id="7ac45-308">As conversões de enumeração explícita são:</span><span class="sxs-lookup"><span data-stu-id="7ac45-308">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="7ac45-309">Partir `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, ou `decimal` para qualquer *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-309">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="7ac45-310">De qualquer *enum_type* à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-310">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="7ac45-311">De qualquer *enum_type* a qualquer outra *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-311">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="7ac45-312">Uma conversão explícita de enumeração entre dois tipos é processada, tratando qualquer participando *enum_type* como o tipo subjacente de que *enum_type*e, em seguida, executar uma implícita ou explícita conversão numérica entre os tipos resultantes.</span><span class="sxs-lookup"><span data-stu-id="7ac45-312">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="7ac45-313">Por exemplo, dada uma *enum_type* `E` com e o tipo subjacente de `int`, uma conversão de `E` para `byte` é processado como uma conversão numérica explícita ([explícita conversões numéricas](conversions.md#explicit-numeric-conversions)) da `int` à `byte`e uma conversão de `byte` para `E` é processado como uma conversão numérica implícita ([conversões numéricas implícitas](conversions.md#implicit-numeric-conversions)) partir `byte` para `int`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-313">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="7ac45-314">Conversões explícitas de permite valor nulas</span><span class="sxs-lookup"><span data-stu-id="7ac45-314">Explicit nullable conversions</span></span>

<span data-ttu-id="7ac45-315">***Conversões explícitas de anuláveis*** predefinidos de permitir conversões explícitas que operam em tipos de valor não anulável para também ser usados com formulários que permitem valor nulos desses tipos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-315">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="7ac45-316">Para cada uma das conversões explícitas predefinidas que convertem de um tipo de valor não anulável `S` para um tipo de valor não anulável `T` ([conversão de identidade](conversions.md#identity-conversion), [conversões numéricas implícitas](conversions.md#implicit-numeric-conversions), [Conversões implícitas de enumeração](conversions.md#implicit-enumeration-conversions), [conversões numéricas explícitas](conversions.md#explicit-numeric-conversions), e [conversões explícitas de enumeração](conversions.md#explicit-enumeration-conversions)), o seguinte Existem conversões que permitem valor nulas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-316">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="7ac45-317">Uma conversão explícita de `S?` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-317">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="7ac45-318">Uma conversão explícita de `S` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-318">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="7ac45-319">Uma conversão explícita de `S?` para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-319">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="7ac45-320">Avaliação de uma conversão que permitem valor nula com base em uma conversão subjacente de `S` para `T` procede da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7ac45-320">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="7ac45-321">Se a conversão que permitem valor nula é de `S?` para `T?`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-321">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="7ac45-322">Se o valor de origem é nulo (`HasValue` propriedade é false), o resultado é o valor nulo do tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-322">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="7ac45-323">Caso contrário, a conversão será avaliada como um desempacotamento do `S?` para `S`, seguido pela conversão de subjacente `S` ao `T`, seguido por um encapsulamento de `T` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-323">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="7ac45-324">Se a conversão que permitem valor nula é de `S` para `T?`, a conversão é avaliada como a conversão subjacente do `S` à `T` seguido por um encapsulamento de `T` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-324">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="7ac45-325">Se a conversão que permitem valor nula é de `S?` para `T`, a conversão será avaliada como um desempacotamento do `S?` à `S` seguido pela conversão de subjacente `S` para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-325">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="7ac45-326">Observe que uma tentativa de decodificar um valor anulável lançará uma exceção se o valor for `null`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-326">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="7ac45-327">Conversões de referência explícita</span><span class="sxs-lookup"><span data-stu-id="7ac45-327">Explicit reference conversions</span></span>

<span data-ttu-id="7ac45-328">As conversões de referência explícita são:</span><span class="sxs-lookup"><span data-stu-id="7ac45-328">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="7ac45-329">Partir `object` e `dynamic` a qualquer outra *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-329">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="7ac45-330">De qualquer *class_type* `S` a qualquer *class_type* `T`, fornecido `S` é uma classe base de `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-330">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="7ac45-331">De qualquer *class_type* `S` a qualquer *interface_type* `T`, fornecido `S` não é selado e fornecidos `S` não implementa `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-331">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="7ac45-332">De qualquer *interface_type* `S` a qualquer *class_type* `T`, fornecido `T` não está lacrado ou fornecida `T` implementa `S`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-332">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="7ac45-333">De qualquer *interface_type* `S` a qualquer *interface_type* `T`, fornecido `S` não é derivado de `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-333">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="7ac45-334">De um *array_type* `S` com um tipo de elemento `SE` para um *array_type* `T` com um tipo de elemento `TE`, desde que todos os itens a seguir forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="7ac45-334">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="7ac45-335">`S` e `T` diferem apenas no tipo de elemento.</span><span class="sxs-lookup"><span data-stu-id="7ac45-335">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="7ac45-336">Em outras palavras, `S` e `T` têm o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="7ac45-336">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="7ac45-337">Ambos `SE` e `TE` são *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="7ac45-337">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="7ac45-338">Existe uma conversão de referência explícita de `SE` para `TE`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-338">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="7ac45-339">Partir `System.Array` e as interfaces que ele implementa a qualquer *array_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-339">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="7ac45-340">De um tipo de matriz unidimensional `S[]` à `System.Collections.Generic.IList<T>` e suas interfaces base, fornecidos que há uma conversão de referência explícita do `S` para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-340">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="7ac45-341">Partir `System.Collections.Generic.IList<S>` e sua base de interfaces para um tipo de matriz unidimensional `T[]`, desde que haja uma conversão explícita de identidade ou referência de `S` para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-341">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="7ac45-342">Partir `System.Delegate` e as interfaces que ele implementa a qualquer *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-342">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="7ac45-343">De um tipo de referência para um tipo de referência `T` se ele tem uma conversão de referência explícita para um tipo de referência `T0` e `T0` tem uma conversão de identidade `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-343">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="7ac45-344">De um tipo de referência a um tipo de interface ou delegado `T` se ele tem uma conversão de referência explícita a um tipo de interface ou delegado `T0` e qualquer `T0` é convertido por variância para `T` ou `T` é convertido por variância para `T0` ([conversão de variância](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-344">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="7ac45-345">Do `D<S1...Sn>` para `D<T1...Tn>` onde `D<X1...Xn>` é um tipo de delegado genérico `D<S1...Sn>` não é compatível com ou idêntico ao `D<T1...Tn>`e para cada parâmetro de tipo `Xi` de `D` mantém a seguir:</span><span class="sxs-lookup"><span data-stu-id="7ac45-345">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="7ac45-346">Se `Xi` é invariante, em seguida, `Si` é idêntico ao `Ti`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-346">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="7ac45-347">Se `Xi` é covariante, em seguida, há uma conversão de identidade ou uma referência implícita ou explícita de `Si` para `Ti`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-347">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="7ac45-348">Se `Xi` é contravariante, em seguida, `Si` e `Ti` são idênticos ou os dois tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="7ac45-348">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="7ac45-349">Conversões explícitas que envolvem parâmetros de tipo que são conhecidos como tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="7ac45-349">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="7ac45-350">Para obter mais detalhes sobre as conversões explícitas que envolvem parâmetros de tipo, consulte [conversões explícitas que envolvem parâmetros de tipo](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="7ac45-350">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="7ac45-351">As conversões de referência explícita são conversões entre tipos de referência que exigem verificações de tempo de execução para garantir que eles estão corretos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-351">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="7ac45-352">Para uma conversão de referência explícita seja bem-sucedida em tempo de execução, o valor do operando de origem deve ser `null`, ou o tipo real do objeto referenciado pelo operando de origem deve ser um tipo que pode ser convertido para o tipo de destino por uma referência implícita conversão ([conversões de referência implícita](conversions.md#implicit-reference-conversions)) ou conversão boxing ([conversões Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-352">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="7ac45-353">Se uma conversão de referência explícita falhar, um `System.InvalidCastException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-353">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="7ac45-354">Conversões de referência, implícitas ou explícitas, nunca altere a identidade referencial do objeto que está sendo convertido.</span><span class="sxs-lookup"><span data-stu-id="7ac45-354">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="7ac45-355">Em outras palavras, enquanto uma conversão de referência pode alterar o tipo de referência, ele nunca muda o tipo ou o valor do objeto que está sendo referenciado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-355">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="7ac45-356">Conversões de conversão unboxing</span><span class="sxs-lookup"><span data-stu-id="7ac45-356">Unboxing conversions</span></span>

<span data-ttu-id="7ac45-357">Uma conversão unboxing permite que um tipo de referência a ser convertido explicitamente em um *value_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-357">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="7ac45-358">Uma conversão unboxing existe entre os tipos `object`, `dynamic` e `System.ValueType` a qualquer *non_nullable_value_type*e de qualquer *interface_type* para qualquer *non_ nullable_value_type* que implementa o *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-358">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="7ac45-359">Além disso digite `System.Enum` podem ser desconvertidos para qualquer *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-359">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="7ac45-360">Uma conversão unboxing existe a partir de um tipo de referência para um *nullable_type* se uma conversão unboxing existir do tipo de referência subjacente *non_nullable_value_type* do  *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-360">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="7ac45-361">Um tipo de valor `S` tem uma conversão unboxing de um tipo de interface `I` se ele tem uma conversão unboxing de um tipo de interface `I0` e `I0` tem uma conversão de identidade para `I`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-361">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="7ac45-362">Um tipo de valor `S` tem uma conversão unboxing de um tipo de interface `I` se ele tem uma conversão unboxing de um tipo de interface ou delegado `I0` e qualquer um dos `I0` é convertido por variância para `I` ou `I`é convertido por variância para `I0` ([conversão de variância](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="7ac45-363">Uma operação de conversão unboxing consiste em verificar primeiro que a instância do objeto é um valor demarcado da determinada *value_type*e, em seguida, copiar o valor para a instância.</span><span class="sxs-lookup"><span data-stu-id="7ac45-363">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="7ac45-364">Unboxing de uma referência nula para um *nullable_type* produz o valor null da *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-364">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="7ac45-365">Um struct pode ser não demarcado do tipo `System.ValueType`, já que é uma classe base para todos os structs ([herança](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-365">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="7ac45-366">Conversões de conversão unboxing são descritas mais detalhadamente em [conversões de conversão Unboxing](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="7ac45-366">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="7ac45-367">Conversões explícitas de dinâmicas</span><span class="sxs-lookup"><span data-stu-id="7ac45-367">Explicit dynamic conversions</span></span>

<span data-ttu-id="7ac45-368">Existe uma conversão de dinâmica explícita de uma expressão do tipo `dynamic` a qualquer tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-368">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="7ac45-369">A conversão é associada dinamicamente ([vinculação dinâmica](expressions.md#dynamic-binding)), o que significa que uma conversão explícita será procurada em tempo de execução do tipo da expressão em tempo de execução `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-369">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="7ac45-370">Se nenhuma conversão for encontrada, uma exceção de tempo de execução é gerada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-370">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="7ac45-371">Se a associação dinâmica da conversão não for desejada, a expressão pode ser convertida pela primeira vez para `object`e, em seguida, para o tipo desejado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-371">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="7ac45-372">Suponha que a seguinte classe é definida:</span><span class="sxs-lookup"><span data-stu-id="7ac45-372">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="7ac45-373">O exemplo a seguir ilustra as conversões explícitas de dinâmicas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-373">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="7ac45-374">Melhor conversão de `o` para `C` for encontrado em tempo de compilação para ser uma conversão de referência explícita.</span><span class="sxs-lookup"><span data-stu-id="7ac45-374">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="7ac45-375">Isso falhará em tempo de execução, porque `"1"` não é na verdade um `C`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-375">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="7ac45-376">A conversão de `d` para `C` no entanto, como uma conversão explícita dinâmica, é suspenso para tempo de execução, onde um usuário definido a conversão do tipo de tempo de execução `d`  --  `string` – ao `C` for encontrado, e é bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="7ac45-376">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="7ac45-377">Conversões explícitas que envolvem parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="7ac45-377">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="7ac45-378">As conversões explícitas a seguir existem para um parâmetro de tipo determinado `T`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-378">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="7ac45-379">Da classe base efetiva `C` dos `T` para `T` e de qualquer classe base da `C` para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-379">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="7ac45-380">No tempo de execução, se `T` é um tipo de valor, a conversão é executada como uma conversão unboxing.</span><span class="sxs-lookup"><span data-stu-id="7ac45-380">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="7ac45-381">Caso contrário, a conversão é executada como uma conversão de referência explícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="7ac45-381">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="7ac45-382">De qualquer tipo de interface para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-382">From any interface type to `T`.</span></span> <span data-ttu-id="7ac45-383">No tempo de execução, se `T` é um tipo de valor, a conversão é executada como uma conversão unboxing.</span><span class="sxs-lookup"><span data-stu-id="7ac45-383">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="7ac45-384">Caso contrário, a conversão é executada como uma conversão de referência explícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="7ac45-384">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="7ac45-385">Partir `T` a qualquer *interface_type* `I` fornecido já não existe uma conversão implícita de `T` para `I`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-385">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="7ac45-386">No tempo de execução, se `T` é um tipo de valor, a conversão é executada como uma conversão boxing seguida por uma conversão de referência explícita.</span><span class="sxs-lookup"><span data-stu-id="7ac45-386">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="7ac45-387">Caso contrário, a conversão é executada como uma conversão de referência explícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="7ac45-387">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="7ac45-388">De um parâmetro de tipo `U` à `T`, fornecida `T` depende `U` ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-388">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="7ac45-389">No tempo de execução, se `U` é um tipo de valor, em seguida, `T` e `U` são necessariamente do mesmo tipo e nenhuma conversão é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-389">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="7ac45-390">Caso contrário, se `T` é um tipo de valor, a conversão é executada como uma conversão unboxing.</span><span class="sxs-lookup"><span data-stu-id="7ac45-390">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="7ac45-391">Caso contrário, a conversão é executada como uma conversão de referência explícita ou conversão de identidade.</span><span class="sxs-lookup"><span data-stu-id="7ac45-391">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="7ac45-392">Se `T` é conhecido por ser um tipo de referência, as conversões acima são todos classificadas como conversões de referência explícita ([conversões de referência explícita](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-392">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="7ac45-393">Se `T` não for conhecido como um tipo de referência, as conversões acima são classificadas como conversões unboxing ([conversões de conversão Unboxing](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-393">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="7ac45-394">As regras acima não é possível fazer uma conversão explícita direta de um parâmetro de tipo sem restrição para um tipo sem interface, que pode ser surpreendente.</span><span class="sxs-lookup"><span data-stu-id="7ac45-394">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="7ac45-395">O motivo para essa regra é para evitar confusão e fazer a semântica de tais conversões claras.</span><span class="sxs-lookup"><span data-stu-id="7ac45-395">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="7ac45-396">Por exemplo, considere a seguinte declaração:</span><span class="sxs-lookup"><span data-stu-id="7ac45-396">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="7ac45-397">Se a conversão explícita direta `t` à `int` eram permitidas, seria possível com facilidade que `X<int>.F(7)` retornaria `7L`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-397">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="7ac45-398">No entanto, ele seria não, porque as conversões numéricas padrão são consideradas apenas quando os tipos são conhecidos como numéricos em tempo de associação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-398">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="7ac45-399">Para fazer a semântica clear, o exemplo acima deve ser escrito:</span><span class="sxs-lookup"><span data-stu-id="7ac45-399">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="7ac45-400">Esse código será compilado agora em execução, mas `X<int>.F(7)` , em seguida, gerará uma exceção em tempo de execução, desde um demarcado `int` não podem ser convertidos diretamente em um `long`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-400">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="7ac45-401">Conversões explícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="7ac45-401">User-defined explicit conversions</span></span>

<span data-ttu-id="7ac45-402">Uma conversão explícita definida pelo usuário consiste em uma opcional padrão conversão explícita, seguida pela execução de um operador de conversão implícita ou explícita definida pelo usuário, seguido por outra opcional padrão conversão explícita.</span><span class="sxs-lookup"><span data-stu-id="7ac45-402">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="7ac45-403">As regras exatas para avaliar as conversões explícitas definidas pelo usuário são descritas em [processamento de conversões explícitas definidas pelo usuário](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="7ac45-403">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="7ac45-404">Conversões padrão</span><span class="sxs-lookup"><span data-stu-id="7ac45-404">Standard conversions</span></span>

<span data-ttu-id="7ac45-405">As conversões padrão são as conversões predefinidas que podem ocorrer como parte de uma conversão definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="7ac45-405">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="7ac45-406">Conversões implícitas padrão</span><span class="sxs-lookup"><span data-stu-id="7ac45-406">Standard implicit conversions</span></span>

<span data-ttu-id="7ac45-407">As seguintes conversões implícitas são classificadas como conversões implícitas padrão:</span><span class="sxs-lookup"><span data-stu-id="7ac45-407">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="7ac45-408">Conversões de identidade ([conversão de identidade](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="7ac45-408">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="7ac45-409">Conversões numéricas implícitas ([conversões numéricas implícitas](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="7ac45-409">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="7ac45-410">Conversões implícitas de permite valor nulas ([conversões implícitas de anuláveis](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="7ac45-410">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="7ac45-411">Conversões de referência implícita ([conversões de referência implícita](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="7ac45-411">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="7ac45-412">Conversões boxing ([conversões Boxing](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="7ac45-412">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="7ac45-413">Conversões implícitas de expressão de constante ([conversões implícitas de dinâmicas](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="7ac45-413">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="7ac45-414">Conversões implícitas que envolvem parâmetros de tipo ([conversões implícitas que envolvem parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="7ac45-414">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="7ac45-415">As conversões implícitas padrão excluem especificamente conversões implícitas definidas pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="7ac45-415">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="7ac45-416">Conversões explícitas padrão</span><span class="sxs-lookup"><span data-stu-id="7ac45-416">Standard explicit conversions</span></span>

<span data-ttu-id="7ac45-417">As conversões explícitas padrão são todas as conversões implícitas standard mais o subconjunto de conversões explícitas para o qual existe uma conversão implícita de padrão oposta.</span><span class="sxs-lookup"><span data-stu-id="7ac45-417">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="7ac45-418">Em outras palavras, se um padrão implícito existe conversão de um tipo `A` para um tipo de `B`, em seguida, existe uma conversão explícita padrão do tipo `A` digitar `B` e do tipo `B` para o tipo `A`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-418">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="7ac45-419">Conversões definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="7ac45-419">User-defined conversions</span></span>

<span data-ttu-id="7ac45-420">C# permite que as conversões implícitas e explícitas predefinidas ser aprimorados pelos ***conversões definidas pelo usuário***.</span><span class="sxs-lookup"><span data-stu-id="7ac45-420">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="7ac45-421">Conversões definidas pelo usuário são introduzidas com a declaração de operadores de conversão ([operadores de conversão](classes.md#conversion-operators)) em tipos de classe e struct.</span><span class="sxs-lookup"><span data-stu-id="7ac45-421">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="7ac45-422">Permitidas conversões definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="7ac45-422">Permitted user-defined conversions</span></span>

<span data-ttu-id="7ac45-423">O c# permite que somente certas conversões definidas pelo usuário deve ser declarado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-423">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="7ac45-424">Em particular, não é possível redefinir uma conversão implícita ou explícita já existente.</span><span class="sxs-lookup"><span data-stu-id="7ac45-424">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="7ac45-425">Para um tipo de origem especificado `S` e o tipo de destino `T`, se `S` ou `T` são tipos que permitem valor nulos, deixe `S0` e `T0` consulte seus tipos base, caso contrário `S0` e `T0` são igual a `S` e `T` , respectivamente.</span><span class="sxs-lookup"><span data-stu-id="7ac45-425">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="7ac45-426">Uma classe ou struct é permitida para declarar uma conversão de um tipo de fonte `S` para um tipo de destino `T` somente se todos os itens a seguir forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="7ac45-426">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="7ac45-427">`S0` e `T0` são de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="7ac45-427">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="7ac45-428">Tanto `S0` ou `T0` é o tipo de classe ou struct em que a declaração do operador ocorre.</span><span class="sxs-lookup"><span data-stu-id="7ac45-428">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="7ac45-429">Nem `S0` nem `T0` é um *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="7ac45-429">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="7ac45-430">Excluindo conversões definidas pelo usuário, uma conversão não existe na `S` à `T` ou do `T` para `S`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-430">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="7ac45-431">As restrições que se aplicam a conversões definidas pelo usuário são discutidas mais detalhadamente em [operadores de conversão](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="7ac45-431">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="7ac45-432">Operadores de conversão cancelada</span><span class="sxs-lookup"><span data-stu-id="7ac45-432">Lifted conversion operators</span></span>

<span data-ttu-id="7ac45-433">Dado um operador de conversão definida pelo usuário que converte de um tipo de valor não anulável `S` para um tipo de valor não anulável `T`, um ***levantado o operador de conversão*** existe que converte do `S?` para `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-433">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="7ac45-434">Este operador de conversão elevadas executa um desempacotamento do `S?` para `S` seguido pela conversão definida pelo usuário de `S` à `T` seguido por um encapsulamento de `T` para `T?`, exceto que um valor nulo Valued `S?` converte diretamente para um valor nulo com valor de `T?`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-434">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="7ac45-435">Um operador de conversão elevadas tem a mesma classificação implícita ou explícita como seu operador de conversão definida pelo usuário subjacente.</span><span class="sxs-lookup"><span data-stu-id="7ac45-435">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="7ac45-436">O termo "conversão definida pelo usuário" aplica-se ao uso de ambos definidos pelo usuário e retiradas operadores de conversão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-436">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="7ac45-437">Avaliação das conversões definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="7ac45-437">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="7ac45-438">Uma conversão definida pelo usuário converte um valor de seu tipo, chamado de ***tipo de fonte***, em outro tipo, chamado a ***tipo de destino***.</span><span class="sxs-lookup"><span data-stu-id="7ac45-438">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="7ac45-439">Centros de avaliação de uma conversão definida pelo usuário sobre como localizar o ***mais específica*** operador de conversão definida pelo usuário para os tipos de origem e de destino específicos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-439">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="7ac45-440">Essa determinação é dividida em várias etapas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-440">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="7ac45-441">Localizando o conjunto de classes e estruturas do qual os operadores de conversão definida pelo usuário serão considerados.</span><span class="sxs-lookup"><span data-stu-id="7ac45-441">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="7ac45-442">Este conjunto consiste o tipo de origem e suas classes base e o tipo de destino e suas classes base (com as suposições implícitas somente classes e structs podem declarar operadores definidos pelo usuário e que tipos de classe não têm nenhuma classe base).</span><span class="sxs-lookup"><span data-stu-id="7ac45-442">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="7ac45-443">Para os fins desta etapa, se o tipo de origem ou destino é um *nullable_type*, seu tipo subjacente é usado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="7ac45-443">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="7ac45-444">Desse conjunto de tipos, determinando que definidas pelo usuário e retiradas operadores de conversão são aplicáveis.</span><span class="sxs-lookup"><span data-stu-id="7ac45-444">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="7ac45-445">Para um operador de conversão seja aplicável, deve ser possível executar uma conversão padrão ([conversões padrão](conversions.md#standard-conversions)) do tipo de fonte ao operando tipo de operador e ele deve ser possível executar uma conversão padrão tipo do resultado do operador para o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-445">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="7ac45-446">O conjunto de aplicáveis operadores definidos pelo usuário, determinar qual operador sem ambiguidade o mais específico.</span><span class="sxs-lookup"><span data-stu-id="7ac45-446">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="7ac45-447">Em termos gerais, o operador mais específico é o operador cujo tipo de operando é "mais próximo" para o tipo de fonte e cujo tipo de resultado é "mais próximo" para o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-447">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="7ac45-448">Operadores de conversão definida pelo usuário têm preferência sobre os operadores de conversão cancelada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-448">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="7ac45-449">As regras exatas para estabelecer o operador de conversão definida pelo usuário mais específico são definidas nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="7ac45-449">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="7ac45-450">Depois que um operador de conversão definida pelo usuário mais específico tiver sido identificado, a execução real da conversão definida pelo usuário envolve até três etapas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-450">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="7ac45-451">Primeiro, se necessário, executar uma conversão padrão do tipo de fonte para o tipo de operando do operador de conversão definida pelo usuário ou cancelada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-451">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="7ac45-452">Em seguida, chamando o operador de conversão definida pelo usuário ou elevadas para executar a conversão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-452">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="7ac45-453">Por fim, se necessário, executar uma conversão padrão do tipo de resultado do operador de conversão definida pelo usuário ou cancelada para o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-453">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="7ac45-454">Avaliação de uma conversão definida pelo usuário nunca envolve mais de um operador de conversão definida pelo usuário ou cancelada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-454">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="7ac45-455">Em outras palavras, uma conversão de tipo `S` digitar `T` nunca primeiro executará uma conversão definida pelo usuário de `S` à `X` e, em seguida, executar uma conversão definida pelo usuário de `X` para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-455">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="7ac45-456">Definições exatas de avaliação das conversões implícitas ou explícitas definidas pelo usuário são fornecidas nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="7ac45-456">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="7ac45-457">Verifique as definições de usar os seguintes termos:</span><span class="sxs-lookup"><span data-stu-id="7ac45-457">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="7ac45-458">Se uma conversão implícita padrão ([padrão conversões implícitas](conversions.md#standard-implicit-conversions)) existe a partir de um tipo `A` em um tipo `B`e caso nem `A` nem `B` são *interface_type*s, em seguida, `A` será considerada ***abrangida pela*** `B`, e `B` será considerada ***abranger*** `A`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-458">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="7ac45-459">O ***mais abrangente de tipo*** em um conjunto de tipos é o um tipo que abrange todos os outros tipos no conjunto.</span><span class="sxs-lookup"><span data-stu-id="7ac45-459">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="7ac45-460">Se nenhum tipo abrange todos os outros tipos, o conjunto não tem nenhum tipo mais abrangente.</span><span class="sxs-lookup"><span data-stu-id="7ac45-460">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="7ac45-461">Em termos mais intuitivos, o tipo mais abrangente é o tipo "maior" no conjunto — o um tipo ao qual cada um dos outros tipos pode ser convertida implicitamente.</span><span class="sxs-lookup"><span data-stu-id="7ac45-461">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="7ac45-462">O ***englobados mais tipo*** em um conjunto de tipos é o tipo de um determinado contido por todos os outros tipos no conjunto.</span><span class="sxs-lookup"><span data-stu-id="7ac45-462">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="7ac45-463">Se nenhum tipo é abrangido pela todos os outros tipos, o conjunto tem não mais englobados tipo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-463">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="7ac45-464">Em termos mais intuitivos, o tipo mais contido é o tipo "menor" no conjunto — o um tipo que pode ser convertido implicitamente em cada um dos outros tipos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-464">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="7ac45-465">Processamento de conversões implícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="7ac45-465">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="7ac45-466">Uma conversão implícita definidas pelo usuário do tipo `S` digitar `T` é processado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7ac45-466">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="7ac45-467">Determinar os tipos `S0` e `T0`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-467">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="7ac45-468">Se `S` ou `T` são tipos anuláveis, `S0` e `T0` são seus tipos base, caso contrário `S0` e `T0` são iguais ao `S` e `T` , respectivamente.</span><span class="sxs-lookup"><span data-stu-id="7ac45-468">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="7ac45-469">Localize o conjunto de tipos, `D`, do qual a conversão definida pelo usuário serão considerados operadores.</span><span class="sxs-lookup"><span data-stu-id="7ac45-469">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="7ac45-470">Este conjunto consiste `S0` (se `S0` é uma classe ou struct), as classes base `S0` (se `S0` é uma classe), e `T0` (se `T0` é uma classe ou struct).</span><span class="sxs-lookup"><span data-stu-id="7ac45-470">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="7ac45-471">Localizar o conjunto de operadores de conversão definida pelo usuário e elevadas aplicável, `U`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-471">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="7ac45-472">Este conjunto consiste nos operadores de conversão implícita elevadas e definidas pelo usuário declarados pelo classes ou structs em `D` que converter de um tipo que abranja `S` a um tipo abrangido pela `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-472">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="7ac45-473">Se `U` está vazio, a conversão é indefinida e ocorrer um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-473">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-474">Localizar o tipo de origem mais específico `SX`, os operadores em `U`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-474">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="7ac45-475">Se qualquer um dos operadores `U` converter `S`, em seguida, `SX` é `S`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-475">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="7ac45-476">Caso contrário, `SX` é o tipo mais contido no conjunto combinado de tipos de fonte dos operadores na `U`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-476">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="7ac45-477">Se exatamente um mais englobados tipo não for encontrado, em seguida, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-477">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-478">Localizar o tipo de destino mais específico, `TX`, os operadores em `U`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-478">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="7ac45-479">Se qualquer um dos operadores `U` converter `T`, em seguida, `TX` é `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-479">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="7ac45-480">Caso contrário, `TX` é o tipo mais abrangente no conjunto combinado de tipos de destino dos operadores na `U`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-480">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="7ac45-481">Se não for encontrado exatamente um tipo mais abrangente, em seguida, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-481">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-482">Localize o operador de conversão mais específico:</span><span class="sxs-lookup"><span data-stu-id="7ac45-482">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="7ac45-483">Se `U` contém exatamente um operador de conversão definida pelo usuário que converte do `SX` para `TX`, em seguida, este é o operador de conversão mais específico.</span><span class="sxs-lookup"><span data-stu-id="7ac45-483">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="7ac45-484">Caso contrário, se `U` contém exatamente um operador de conversão elevadas que converte do `SX` para `TX`, em seguida, este é o operador de conversão mais específico.</span><span class="sxs-lookup"><span data-stu-id="7ac45-484">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="7ac45-485">Caso contrário, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-485">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-486">Por fim, aplique a conversão:</span><span class="sxs-lookup"><span data-stu-id="7ac45-486">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="7ac45-487">Se `S` não é `SX`, em seguida, uma conversão implícita padrão de `S` para `SX` é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-487">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="7ac45-488">O operador de conversão mais específico é invocado para converter `SX` para `TX`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-488">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="7ac45-489">Se `TX` não é `T`, em seguida, uma conversão implícita padrão de `TX` para `T` é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-489">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="7ac45-490">Processamento de conversões explícitas definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="7ac45-490">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="7ac45-491">Uma conversão explícita definida pelo usuário do tipo `S` digitar `T` é processado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7ac45-491">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="7ac45-492">Determinar os tipos `S0` e `T0`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-492">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="7ac45-493">Se `S` ou `T` são tipos anuláveis, `S0` e `T0` são seus tipos base, caso contrário `S0` e `T0` são iguais ao `S` e `T` , respectivamente.</span><span class="sxs-lookup"><span data-stu-id="7ac45-493">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="7ac45-494">Localize o conjunto de tipos, `D`, do qual a conversão definida pelo usuário serão considerados operadores.</span><span class="sxs-lookup"><span data-stu-id="7ac45-494">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="7ac45-495">Este conjunto consiste `S0` (se `S0` é uma classe ou struct), as classes base `S0` (se `S0` é uma classe), `T0` (se `T0` é uma classe ou struct) e as classes base `T0` (se `T0`é uma classe).</span><span class="sxs-lookup"><span data-stu-id="7ac45-495">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="7ac45-496">Localizar o conjunto de operadores de conversão definida pelo usuário e elevadas aplicável, `U`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-496">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="7ac45-497">Este conjunto consiste nas definidas pelo usuário e elevadas implícita ou operadores de conversão explícita declarado pelo classes ou estruturas nos `D` que converter de um tipo que abranja ou abrangida pela `S` para um tipo que abranja ou abrangida pela `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-497">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="7ac45-498">Se `U` está vazio, a conversão é indefinida e ocorrer um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-498">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-499">Localizar o tipo de origem mais específico `SX`, os operadores em `U`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-499">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="7ac45-500">Se qualquer um dos operadores `U` converter `S`, em seguida, `SX` é `S`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-500">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="7ac45-501">Caso contrário, se qualquer um dos operadores `U` converter de tipos que englobam `S`, em seguida, `SX` é o tipo mais contido no conjunto combinado de tipos de fonte desses operadores.</span><span class="sxs-lookup"><span data-stu-id="7ac45-501">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="7ac45-502">Se nenhuma maioria englobados tipo pode ser encontrado, em seguida, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-502">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="7ac45-503">Caso contrário, `SX` é o tipo mais abrangente no conjunto combinado de tipos de fonte dos operadores na `U`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-503">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="7ac45-504">Se não for encontrado exatamente um tipo mais abrangente, em seguida, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-504">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-505">Localizar o tipo de destino mais específico, `TX`, os operadores em `U`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-505">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="7ac45-506">Se qualquer um dos operadores `U` converter `T`, em seguida, `TX` é `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-506">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="7ac45-507">Caso contrário, se qualquer um dos operadores na `U` converter em tipos que são englobados por `T`, em seguida, `TX` é o tipo mais abrangente no conjunto combinado de tipos de destino desses operadores.</span><span class="sxs-lookup"><span data-stu-id="7ac45-507">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="7ac45-508">Se não for encontrado exatamente um tipo mais abrangente, em seguida, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-508">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="7ac45-509">Caso contrário, `TX` é o tipo mais contido no conjunto combinado de tipos de destino dos operadores na `U`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-509">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="7ac45-510">Se nenhuma maioria englobados tipo pode ser encontrado, em seguida, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-510">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-511">Localize o operador de conversão mais específico:</span><span class="sxs-lookup"><span data-stu-id="7ac45-511">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="7ac45-512">Se `U` contém exatamente um operador de conversão definida pelo usuário que converte do `SX` para `TX`, em seguida, este é o operador de conversão mais específico.</span><span class="sxs-lookup"><span data-stu-id="7ac45-512">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="7ac45-513">Caso contrário, se `U` contém exatamente um operador de conversão elevadas que converte do `SX` para `TX`, em seguida, este é o operador de conversão mais específico.</span><span class="sxs-lookup"><span data-stu-id="7ac45-513">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="7ac45-514">Caso contrário, a conversão é ambígua e ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-514">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-515">Por fim, aplique a conversão:</span><span class="sxs-lookup"><span data-stu-id="7ac45-515">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="7ac45-516">Se `S` não é `SX`, em seguida, uma conversão explícita padrão de `S` para `SX` é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-516">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="7ac45-517">O operador de conversão definida pelo usuário mais específico é invocado para converter `SX` para `TX`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-517">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="7ac45-518">Se `TX` não é `T`, em seguida, uma conversão explícita padrão de `TX` para `T` é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-518">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="7ac45-519">Conversões de função anônima</span><span class="sxs-lookup"><span data-stu-id="7ac45-519">Anonymous function conversions</span></span>

<span data-ttu-id="7ac45-520">Uma *anonymous_method_expression* ou *lambda_expression* é classificado como uma função anônima ([expressões de função anônima](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-520">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="7ac45-521">A expressão não tem um tipo, mas pode ser convertida implicitamente em um tipo de delegado compatível ou tipo de árvore de expressão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-521">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="7ac45-522">Especificamente, uma função anônima `F` é compatível com um tipo de delegado `D` fornecido:</span><span class="sxs-lookup"><span data-stu-id="7ac45-522">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="7ac45-523">Se `F` contém uma *anonymous_function_signature*, em seguida, `D` e `F` têm o mesmo número de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="7ac45-523">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="7ac45-524">Se `F` não contém um *anonymous_function_signature*, em seguida, `D` pode ter zero ou mais parâmetros de qualquer tipo, desde que nenhum parâmetro de `D` tem o `out` modificador de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7ac45-524">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="7ac45-525">Se `F` tem uma lista de parâmetros de tipo explícito, cada parâmetro na `D` tem o mesmo tipo e modificadores de parâmetro correspondente no `F`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-525">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="7ac45-526">Se `F` tem uma lista de parâmetro de tipo implícito `D` não tem nenhum `ref` ou `out` parâmetros.</span><span class="sxs-lookup"><span data-stu-id="7ac45-526">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="7ac45-527">Se o corpo da `F` for uma expressão e `D` tem um `void` tipo de retorno ou `F` é assíncrono e `D` tem o tipo de retorno `Task`, em seguida, quando cada parâmetro de `F` está considerando o tipo dos o parâmetro correspondente em `D`, o corpo da `F` é uma expressão válida (wrt [expressões](expressions.md)) que seria permitido como um *statement_expression* ([Instruções de expressão](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-527">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="7ac45-528">Se o corpo da `F` é um bloco de instrução e `D` tem um `void` tipo de retorno ou `F` é assíncrono e `D` tem o tipo de retorno `Task`, em seguida, quando cada parâmetro de `F` está considerando o tipo de o parâmetro correspondente na `D`, o corpo da `F` é um bloco de instruções válido (wrt [blocos](statements.md#blocks)) no qual nenhum `return` declaração especifica uma expressão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-528">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="7ac45-529">Se o corpo da `F` é uma expressão, e *qualquer* `F` é não assíncronas e `D` tem um tipo de retorno não nulo `T`, *ou* `F` é assíncrono e `D` tem um tipo de retorno `Task<T>`, em seguida, quando cada parâmetro do `F` recebe o tipo do parâmetro correspondente na `D`, o corpo da `F` é uma expressão válida (wrt [ Expressões](expressions.md)) que é implicitamente conversível para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-529">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="7ac45-530">Se o corpo da `F` é um bloco de instrução, e *qualquer* `F` é não assíncronas e `D` tem um tipo de retorno não nulo `T`, *ou* `F` é assíncrono e `D` tem um tipo de retorno `Task<T>`, em seguida, quando cada parâmetro do `F` recebe o tipo do parâmetro correspondente na `D`, o corpo da `F` é um bloco de instruções válido (wrt [blocos ](statements.md#blocks)) com um ponto de extremidade não pode ser acessado na qual cada `return` declaração especifica uma expressão que é implicitamente conversível para `T`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-530">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="7ac45-531">Para fins de brevidade, esta seção usa a forma abreviada para os tipos de tarefa `Task` e `Task<T>` ([funções assíncronas](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-531">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="7ac45-532">Uma expressão lambda `F` é compatível com um tipo de árvore de expressão `Expression<D>` se `F` é compatível com o tipo de delegado `D`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-532">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="7ac45-533">Observe que isso não se aplica aos métodos anônimos, somente as expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="7ac45-533">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="7ac45-534">Determinadas expressões lambda não podem ser convertidos em tipos de árvore de expressão: Mesmo que a conversão *existe*, ele falhará em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-534">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="7ac45-535">Isso é o caso se a expressão lambda:</span><span class="sxs-lookup"><span data-stu-id="7ac45-535">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="7ac45-536">Tem um *bloco* corpo</span><span class="sxs-lookup"><span data-stu-id="7ac45-536">Has a *block* body</span></span>
*  <span data-ttu-id="7ac45-537">Contém os operadores de atribuição simples ou composta</span><span class="sxs-lookup"><span data-stu-id="7ac45-537">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="7ac45-538">Contém uma expressão associada dinamicamente</span><span class="sxs-lookup"><span data-stu-id="7ac45-538">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="7ac45-539">É assíncrono</span><span class="sxs-lookup"><span data-stu-id="7ac45-539">Is async</span></span>

<span data-ttu-id="7ac45-540">Os exemplos a seguir usam um tipo de delegado genérico `Func<A,R>` que representa uma função que usa um argumento do tipo `A` e retorna um valor do tipo `R`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-540">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="7ac45-541">Nas atribuições</span><span class="sxs-lookup"><span data-stu-id="7ac45-541">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="7ac45-542">os parâmetro e tipos de retorno de cada função anônima são determinados pelo tipo da variável à qual a função anônima é atribuída.</span><span class="sxs-lookup"><span data-stu-id="7ac45-542">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="7ac45-543">A primeira atribuição converte com êxito a função anônima para o tipo de delegado `Func<int,int>` porque, quando `x` recebe o tipo `int`, `x+1` é uma expressão válida que é implicitamente conversível para o tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-543">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="7ac45-544">Da mesma forma, a segunda atribuição converte com êxito a função anônima para o tipo de delegado `Func<int,double>` porque o resultado da `x+1` (do tipo `int`) é implicitamente conversível para o tipo `double`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-544">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="7ac45-545">No entanto, a atribuição de terceiro é um erro de tempo de compilação porque, quando `x` recebe o tipo `double`, o resultado da `x+1` (do tipo `double`) não é implicitamente conversível para o tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-545">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="7ac45-546">A atribuição de quarta converte com êxito a função assíncrona anônimo para o tipo de delegado `Func<int, Task<int>>` porque o resultado da `x+1` (do tipo `int`) é implicitamente conversível para o tipo de resultado `int` do tipo de tarefa `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-546">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="7ac45-547">Funções anônimas podem influenciar a resolução de sobrecarga e participar de inferência de tipo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-547">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="7ac45-548">Ver [membros de função](expressions.md#function-members) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="7ac45-548">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="7ac45-549">Avaliação de conversões de função anônima para tipos de delegado</span><span class="sxs-lookup"><span data-stu-id="7ac45-549">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="7ac45-550">Conversão de uma função anônima para um tipo de delegado produz uma instância de delegado que faz referência a função anônima e o conjunto (possivelmente vazio) de variáveis externas capturadas que estão ativas no momento da avaliação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-550">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="7ac45-551">Quando o delegado é invocado, o corpo da função anônima que é executado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-551">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="7ac45-552">O código no corpo é executado usando o conjunto de variáveis externas capturadas referenciado pelo delegado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-552">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="7ac45-553">A lista de invocação de um delegado produzido a partir de uma função anônima contém uma única entrada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-553">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="7ac45-554">O objeto de destino exato e o método de destino do delegado são especificados.</span><span class="sxs-lookup"><span data-stu-id="7ac45-554">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="7ac45-555">Em particular, ele é não especificado se o objeto de destino do delegado é `null`, o `this` valor o membro da função delimitadora ou algum outro objeto.</span><span class="sxs-lookup"><span data-stu-id="7ac45-555">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="7ac45-556">Conversões de funções anônimas semanticamente idênticas com o mesmo conjunto (possivelmente vazia) de instâncias capturadas de variável externas para os mesmos tipos de delegado são permitidas (mas não obrigatório) para retornar a mesma instância do delegado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-556">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="7ac45-557">O termo semanticamente idêntico é usado aqui para indicar que a execução das funções anônimas, em todos os casos, produzirá os mesmos efeitos considerando os mesmos argumentos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-557">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="7ac45-558">Essa regra permite o código a seguir para ser otimizada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-558">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="7ac45-559">Como os dois delegados de função anônima têm as mesmas (vazio) das variáveis externas capturadas e, como as funções anônimas são semanticamente idênticas, o compilador tem permissão para ter os delegados se referem ao mesmo método de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-559">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="7ac45-560">Na verdade, o compilador tem permissão para retornar a instância do representante mesmo de ambas as expressões de função anônima.</span><span class="sxs-lookup"><span data-stu-id="7ac45-560">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="7ac45-561">Avaliação de conversões de função anônima para tipos de árvore de expressão</span><span class="sxs-lookup"><span data-stu-id="7ac45-561">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="7ac45-562">Conversão de uma função anônima para um tipo de árvore de expressão produz uma árvore de expressão ([tipos de árvore de expressão](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-562">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="7ac45-563">Mais precisamente, a avaliação da conversão de função anônima leva a construção de uma estrutura de objeto que representa a estrutura da função anônima em si.</span><span class="sxs-lookup"><span data-stu-id="7ac45-563">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="7ac45-564">A estrutura exata da árvore de expressão, bem como o processo exato para criá-lo, são definido pela implementação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-564">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="7ac45-565">Exemplo de implementação</span><span class="sxs-lookup"><span data-stu-id="7ac45-565">Implementation example</span></span>

<span data-ttu-id="7ac45-566">Esta seção descreve uma possível implementação de conversões de função anônima em termos de outras construções de linguagem c#.</span><span class="sxs-lookup"><span data-stu-id="7ac45-566">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="7ac45-567">A implementação descrita aqui baseia-se os mesmos princípios usados pelo compilador Microsoft c#, mas ele não é uma implementação obrigatória e não é o único possível.</span><span class="sxs-lookup"><span data-stu-id="7ac45-567">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="7ac45-568">Resumidamente, ela menciona conversões em árvores de expressão, conforme sua semântica exata está fora do escopo desta especificação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-568">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="7ac45-569">O restante desta seção fornece vários exemplos de código que contém funções anônimas com características diferentes.</span><span class="sxs-lookup"><span data-stu-id="7ac45-569">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="7ac45-570">Para cada exemplo, uma tradução correspondente ao código que usa somente outros constructos de c# é fornecida.</span><span class="sxs-lookup"><span data-stu-id="7ac45-570">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="7ac45-571">Nos exemplos, o identificador `D` será considerado por representam o seguinte tipo de delegado:</span><span class="sxs-lookup"><span data-stu-id="7ac45-571">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="7ac45-572">A forma mais simples de uma função anônima é aquele que captura sem variáveis externas:</span><span class="sxs-lookup"><span data-stu-id="7ac45-572">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="7ac45-573">Isso pode ser convertido para uma instanciação de delegado que faz referência a um método estático de gerado pelo compilador em que o código da função anônima é colocado:</span><span class="sxs-lookup"><span data-stu-id="7ac45-573">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="7ac45-574">No exemplo a seguir, a função anônima faz referência a membros de instância de `this`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-574">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="7ac45-575">Isso pode ser convertido para um método de instância gerado pelo compilador que contém o código da função anônimo:</span><span class="sxs-lookup"><span data-stu-id="7ac45-575">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="7ac45-576">Neste exemplo, a função anônima captura uma variável local:</span><span class="sxs-lookup"><span data-stu-id="7ac45-576">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="7ac45-577">O tempo de vida da variável local deve ser estendido para pelo menos o tempo de vida do delegado de função anônima.</span><span class="sxs-lookup"><span data-stu-id="7ac45-577">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="7ac45-578">Isso pode ser obtido por "elevação" da variável local em um campo de uma classe gerada pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="7ac45-578">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="7ac45-579">Instanciação de variável local ([instanciação de variáveis locais](expressions.md#instantiation-of-local-variables)), em seguida, corresponde à criação de uma instância da classe gerada pelo compilador e acessar a variável local corresponde ao acesso a um campo na instância do a classe gerada pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="7ac45-579">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="7ac45-580">Além disso, a função anônima se torna um método de instância da classe gerada pelo compilador:</span><span class="sxs-lookup"><span data-stu-id="7ac45-580">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="7ac45-581">Por fim, a anônimo função a seguir capturas `this` , bem como duas variáveis locais com tempos de vida diferentes:</span><span class="sxs-lookup"><span data-stu-id="7ac45-581">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="7ac45-582">Aqui, uma classe gerada pelo compilador é criada para cada instrução bloquear em quais locais são capturadas, de modo que os locais nos blocos diferentes podem ter tempos de vida independentes.</span><span class="sxs-lookup"><span data-stu-id="7ac45-582">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="7ac45-583">Uma instância do `__Locals2`, a classe gerada pelo compilador para o bloco de instrução interna, contém a variável local `z` e um campo que faz referência a uma instância de `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-583">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="7ac45-584">Uma instância do `__Locals1`, a classe gerada pelo compilador para o bloco de instrução externa, contém a variável local `y` e um campo que faz referência a `this` do membro da função delimitadora.</span><span class="sxs-lookup"><span data-stu-id="7ac45-584">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="7ac45-585">Com essas estruturas de dados, é possível alcançar todas capturadas variáveis externas através de uma instância de `__Local2`, e o código da função anônimo, portanto, pode ser implementado como um método de instância dessa classe.</span><span class="sxs-lookup"><span data-stu-id="7ac45-585">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="7ac45-586">A mesma técnica aqui aplicada para capturar as variáveis locais também pode ser usada ao converter funções anônimas em árvores de expressão: Referências aos objetos gerados pelo compilador que podem ser armazenadas na árvore de expressão, e o acesso às variáveis locais pode ser representado como campo acessa nesses objetos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-586">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="7ac45-587">A vantagem dessa abordagem é que ele permite que as variáveis locais "canceladas" ser compartilhado entre delegados e árvores de expressão.</span><span class="sxs-lookup"><span data-stu-id="7ac45-587">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="7ac45-588">Conversões de grupo de método</span><span class="sxs-lookup"><span data-stu-id="7ac45-588">Method group conversions</span></span>

<span data-ttu-id="7ac45-589">Uma conversão implícita ([conversões implícitas](conversions.md#implicit-conversions)) existe a partir de um grupo de métodos ([classificações de expressão](expressions.md#expression-classifications)) para um tipo de delegado compatível.</span><span class="sxs-lookup"><span data-stu-id="7ac45-589">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="7ac45-590">Dado um tipo de delegado `D` e uma expressão `E` que é classificado como um grupo de métodos, existe uma conversão implícita de `E` à `D` se `E` contém pelo menos um método que é aplicável em sua forma normal ( [Membro da função aplicáveis](expressions.md#applicable-function-member)) para uma lista de argumentos construído pelo uso dos tipos de parâmetro e modificadores de `D`, conforme descrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="7ac45-590">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="7ac45-591">O aplicativo de tempo de compilação de uma conversão de um grupo de métodos `E` para um tipo delegado `D` é descrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="7ac45-591">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="7ac45-592">Observe que a existência de uma conversão implícita da `E` para `D` não garante que o aplicativo de tempo de compilação da conversão será bem-sucedida sem erro.</span><span class="sxs-lookup"><span data-stu-id="7ac45-592">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="7ac45-593">Um único método `M` está selecionado correspondente a uma invocação de método ([invocações de método](expressions.md#method-invocations)) do formulário `E(A)`, com as seguintes modificações:</span><span class="sxs-lookup"><span data-stu-id="7ac45-593">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="7ac45-594">A lista de argumentos `A` é uma lista de expressões, cada classificadas como uma variável e com o tipo e o modificador (`ref` ou `out`) do parâmetro correspondente no *formal_parameter_list* de `D`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-594">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="7ac45-595">Os métodos de candidato considerados são somente os métodos que são aplicáveis em sua forma normal ([membro da função aplicável](expressions.md#applicable-function-member)), não os aplicável apenas em seus formulários expandidos.</span><span class="sxs-lookup"><span data-stu-id="7ac45-595">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="7ac45-596">Se o algoritmo de [invocações de método](expressions.md#method-invocations) produz um erro, em seguida, ocorre um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-596">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="7ac45-597">Caso contrário, o algoritmo produz um único método melhor `M` tendo o mesmo número de parâmetros como `D` e a conversão é considerada de existir.</span><span class="sxs-lookup"><span data-stu-id="7ac45-597">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="7ac45-598">O método selecionado `M` devem ser compatíveis ([compatibilidade de delegado](delegates.md#delegate-compatibility)) com o tipo de delegado `D`, ou caso contrário, ocorrerá um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="7ac45-598">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="7ac45-599">Se o método selecionado `M` é um método de instância, a expressão de instância associada `E` determina o objeto de destino do delegado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-599">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="7ac45-600">Se o método selecionado M é um método de extensão que é indicado por meio de um acesso de membro em uma expressão de instância, essa expressão instância determina o objeto de destino do delegado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-600">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="7ac45-601">O resultado da conversão é um valor do tipo `D`, ou seja, um delegado criado recentemente que se refere ao objeto de método e de destino selecionado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-601">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="7ac45-602">Observe que esse processo pode levar à criação de um delegado para um método de extensão, se o algoritmo de [invocações de método](expressions.md#method-invocations) não consegue encontrar um método de instância, mas tem êxito no processamento de invocação de `E(A)` como uma extensão invocação de método ([invocações de método de extensão](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="7ac45-602">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="7ac45-603">Um delegado que foi criado, portanto, captura o método de extensão, bem como seu primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="7ac45-603">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="7ac45-604">O exemplo a seguir demonstra conversões de grupo de método:</span><span class="sxs-lookup"><span data-stu-id="7ac45-604">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="7ac45-605">A atribuição ao `d1` converte implicitamente o grupo de métodos `F` em um valor do tipo `D1`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-605">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="7ac45-606">A atribuição ao `d2` mostra como é possível criar um delegado para um método que tem tipos de parâmetro menos derivados (contravariant) e uma mais derivado (covariante) tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="7ac45-606">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="7ac45-607">A atribuição ao `d3` mostra como não existe conversão se o método não é aplicável.</span><span class="sxs-lookup"><span data-stu-id="7ac45-607">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="7ac45-608">A atribuição ao `d4` mostra como o método deve ser aplicável em sua forma normal.</span><span class="sxs-lookup"><span data-stu-id="7ac45-608">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="7ac45-609">A atribuição ao `d5` mostra como parâmetro e tipos de retorno do método e delegado têm permissão para diferem somente para tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="7ac45-609">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="7ac45-610">Assim como acontece com todas as outras conversões implícitas e explícitas, o operador de conversão pode ser usado para explicitamente executar uma conversão de grupo de método.</span><span class="sxs-lookup"><span data-stu-id="7ac45-610">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="7ac45-611">Portanto, o exemplo</span><span class="sxs-lookup"><span data-stu-id="7ac45-611">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="7ac45-612">em vez disso, poderia ser escrito</span><span class="sxs-lookup"><span data-stu-id="7ac45-612">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="7ac45-613">Grupos de método podem influenciar a resolução de sobrecarga e participar de inferência de tipo.</span><span class="sxs-lookup"><span data-stu-id="7ac45-613">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="7ac45-614">Ver [membros de função](expressions.md#function-members) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="7ac45-614">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="7ac45-615">A avaliação do tempo de execução de uma conversão de grupo de método procede da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7ac45-615">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="7ac45-616">Se o método selecionado em tempo de compilação é um método de instância ou é um método de extensão que pode é acessado como um método de instância, o objeto de destino do delegado é determinado da expressão de instância associado `E`:</span><span class="sxs-lookup"><span data-stu-id="7ac45-616">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="7ac45-617">A expressão de instância é avaliada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-617">The instance expression is evaluated.</span></span> <span data-ttu-id="7ac45-618">Se essa avaliação causa uma exceção, nenhuma outra etapa é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-618">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="7ac45-619">Se a expressão de instância é de um *reference_type*, o valor calculado pela expressão instância torna-se o objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-619">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="7ac45-620">Se o método selecionado é um método de instância e é o objeto de destino `null`, um `System.NullReferenceException` é lançada e nenhuma outra etapa é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-620">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="7ac45-621">Se a expressão de instância é de um *value_type*, uma operação de conversão boxing ([conversões Boxing](types.md#boxing-conversions)) é executada para converter o valor a um objeto, e esse objeto se torna o objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="7ac45-621">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="7ac45-622">Caso contrário, o método selecionado faz parte de uma chamada de método estático e o objeto de destino do delegado é `null`.</span><span class="sxs-lookup"><span data-stu-id="7ac45-622">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="7ac45-623">Uma nova instância do tipo de delegado `D` é alocado.</span><span class="sxs-lookup"><span data-stu-id="7ac45-623">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="7ac45-624">Se não houver memória suficiente disponível para alocar a nova instância, um `System.OutOfMemoryException` é lançada e nenhuma outra etapa é executada.</span><span class="sxs-lookup"><span data-stu-id="7ac45-624">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="7ac45-625">A nova instância de delegado é inicializada com uma referência para o método que foi determinada em tempo de compilação e uma referência ao objeto de destino é calculado acima.</span><span class="sxs-lookup"><span data-stu-id="7ac45-625">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>

---
ms.openlocfilehash: 088c4a77cecde490c556c44c239a3496f896582e
ms.sourcegitcommit: 4ddf18d000734c1b6d0a48127bf338086fc3f2c3
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/05/2019
ms.locfileid: "73616133"
---
# <a name="types"></a><span data-ttu-id="01721-101">Tipos</span><span class="sxs-lookup"><span data-stu-id="01721-101">Types</span></span>

<span data-ttu-id="01721-102">Os tipos de C# idioma são divididos em duas categorias principais: ***tipos de valor*** e tipos de ***referência***.</span><span class="sxs-lookup"><span data-stu-id="01721-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="01721-103">Os tipos de valor e de referência podem ser ***tipos genéricos***, que usam um ou mais ***parâmetros de tipo***.</span><span class="sxs-lookup"><span data-stu-id="01721-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="01721-104">Os parâmetros de tipo podem designar tipos de valor e de referência.</span><span class="sxs-lookup"><span data-stu-id="01721-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="01721-105">A categoria final dos tipos, ponteiros, está disponível somente em código não seguro.</span><span class="sxs-lookup"><span data-stu-id="01721-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="01721-106">Isso é abordado mais detalhadamente em [tipos de ponteiro](unsafe-code.md#pointer-types).</span><span class="sxs-lookup"><span data-stu-id="01721-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="01721-107">Tipos de valor diferem dos tipos de referência, pois as variáveis dos tipos de valor contêm diretamente seus dados, enquanto as variáveis dos tipos de referência armazenam ***referências*** a seus dados, o último é conhecido como ***objetos***.</span><span class="sxs-lookup"><span data-stu-id="01721-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="01721-108">Com os tipos de referência, é possível que duas variáveis referenciem o mesmo objeto e, assim, possíveis para operações em uma variável afetem o objeto referenciado pela outra variável.</span><span class="sxs-lookup"><span data-stu-id="01721-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="01721-109">Com tipos de valor, as variáveis têm sua própria cópia dos dados e não é possível que as operações em um afetem a outra.</span><span class="sxs-lookup"><span data-stu-id="01721-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="01721-110">C#o sistema de tipos do é unificado, de modo que um valor de qualquer tipo possa ser tratado como um objeto.</span><span class="sxs-lookup"><span data-stu-id="01721-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="01721-111">Cada tipo no C#, direta ou indiretamente, deriva do tipo de classe `object`, e `object` é a classe base definitiva de todos os tipos.</span><span class="sxs-lookup"><span data-stu-id="01721-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="01721-112">Os valores de tipos de referência são tratados como objetos simplesmente exibindo os valores como tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="01721-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="01721-113">Os valores dos tipos de valor são tratados como objetos executando as operações boxing e unboxing ([boxing e unboxing](types.md#boxing-and-unboxing)).</span><span class="sxs-lookup"><span data-stu-id="01721-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="01721-114">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="01721-114">Value types</span></span>

<span data-ttu-id="01721-115">Um tipo de valor é um tipo de struct ou um tipo de enumeração.</span><span class="sxs-lookup"><span data-stu-id="01721-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="01721-116">C#fornece um conjunto de tipos de struct predefinidos chamados de ***tipos simples***.</span><span class="sxs-lookup"><span data-stu-id="01721-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="01721-117">Os tipos simples são identificados por meio de palavras reservadas.</span><span class="sxs-lookup"><span data-stu-id="01721-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="01721-118">Ao contrário de uma variável de um tipo de referência, uma variável de um tipo de valor pode conter o valor `null` somente se o tipo de valor for um tipo anulável.</span><span class="sxs-lookup"><span data-stu-id="01721-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="01721-119">Para cada tipo de valor não anulável, há um tipo de valor anulável correspondente, indicando o mesmo conjunto de valores, mais o valor `null`.</span><span class="sxs-lookup"><span data-stu-id="01721-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="01721-120">A atribuição a uma variável de um tipo de valor cria uma cópia do valor que está sendo atribuído.</span><span class="sxs-lookup"><span data-stu-id="01721-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="01721-121">Isso difere da atribuição a uma variável de um tipo de referência, que copia a referência, mas não o objeto identificado pela referência.</span><span class="sxs-lookup"><span data-stu-id="01721-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="01721-122">O tipo System. ValueType</span><span class="sxs-lookup"><span data-stu-id="01721-122">The System.ValueType type</span></span>

<span data-ttu-id="01721-123">Todos os tipos de valor herdam implicitamente da classe `System.ValueType`, que, por sua vez, herda da classe `object`.</span><span class="sxs-lookup"><span data-stu-id="01721-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="01721-124">Não é possível que qualquer tipo seja derivado de um tipo de valor, e tipos de valor são, portanto, lacrados implicitamente ([classes lacradas](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="01721-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="01721-125">Observe que `System.ValueType` não é, em si, um *value_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="01721-126">Em vez disso, é um *class_type* do qual todos os *value_type*são derivados automaticamente.</span><span class="sxs-lookup"><span data-stu-id="01721-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="01721-127">Construtores padrão</span><span class="sxs-lookup"><span data-stu-id="01721-127">Default constructors</span></span>

<span data-ttu-id="01721-128">Todos os tipos de valor declaram implicitamente um construtor de instância sem parâmetros público chamado ***construtor padrão***.</span><span class="sxs-lookup"><span data-stu-id="01721-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="01721-129">O construtor padrão retorna uma instância inicializada em zero conhecida como o ***valor padrão*** para o tipo de valor:</span><span class="sxs-lookup"><span data-stu-id="01721-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="01721-130">Para todos os *Simple_Type*s, o valor padrão é o valor produzido por um padrão de bit de todos os zeros:</span><span class="sxs-lookup"><span data-stu-id="01721-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="01721-131">Para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`e `ulong`, o valor padrão é `0`.</span><span class="sxs-lookup"><span data-stu-id="01721-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="01721-132">Por `char`, o valor padrão é `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="01721-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="01721-133">Por `float`, o valor padrão é `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="01721-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="01721-134">Por `double`, o valor padrão é `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="01721-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="01721-135">Por `decimal`, o valor padrão é `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="01721-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="01721-136">Por `bool`, o valor padrão é `false`.</span><span class="sxs-lookup"><span data-stu-id="01721-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="01721-137">Para um `E`*enum_type* , o valor padrão é `0`, convertido para o tipo `E`.</span><span class="sxs-lookup"><span data-stu-id="01721-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="01721-138">Para um *struct_type*, o valor padrão é o valor produzido pela configuração de todos os campos de tipo de valor para seu valor padrão e todos os campos de tipo de referência como `null`.</span><span class="sxs-lookup"><span data-stu-id="01721-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="01721-139">Para um *nullable_type* , o valor padrão é uma instância para a qual a propriedade `HasValue` é false e a propriedade `Value` é indefinida.</span><span class="sxs-lookup"><span data-stu-id="01721-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="01721-140">O valor padrão também é conhecido como o ***valor nulo*** do tipo anulável.</span><span class="sxs-lookup"><span data-stu-id="01721-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="01721-141">Como qualquer outro construtor de instância, o construtor padrão de um tipo de valor é invocado usando o operador de `new`.</span><span class="sxs-lookup"><span data-stu-id="01721-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="01721-142">Por motivos de eficiência, esse requisito não tem como objetivo realmente fazer com que a implementação gere uma chamada de construtor.</span><span class="sxs-lookup"><span data-stu-id="01721-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="01721-143">No exemplo a seguir, as variáveis `i` e `j` são inicializadas como zero.</span><span class="sxs-lookup"><span data-stu-id="01721-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="01721-144">Como cada tipo de valor implicitamente tem um construtor de instância sem parâmetros público, não é possível que um tipo de struct contenha uma declaração explícita de um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="01721-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="01721-145">No entanto, um tipo struct é permitido para declarar construtores de instância com parâmetros ([construtores](structs.md#constructors)).</span><span class="sxs-lookup"><span data-stu-id="01721-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="01721-146">Tipos struct</span><span class="sxs-lookup"><span data-stu-id="01721-146">Struct types</span></span>

<span data-ttu-id="01721-147">Um tipo de struct é um tipo de valor que pode declarar constantes, campos, métodos, propriedades, indexadores, operadores, construtores de instância, construtores estáticos e tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="01721-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="01721-148">A declaração de tipos de struct é descrita em [declarações de struct](structs.md#struct-declarations).</span><span class="sxs-lookup"><span data-stu-id="01721-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="01721-149">Tipos simples</span><span class="sxs-lookup"><span data-stu-id="01721-149">Simple types</span></span>

<span data-ttu-id="01721-150">C#fornece um conjunto de tipos de struct predefinidos chamados de ***tipos simples***.</span><span class="sxs-lookup"><span data-stu-id="01721-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="01721-151">Os tipos simples são identificados por meio de palavras reservadas, mas essas palavras reservadas são simplesmente aliases para tipos de struct predefinidos no namespace `System`, conforme descrito na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="01721-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="01721-152">__Palavra reservada__</span><span class="sxs-lookup"><span data-stu-id="01721-152">__Reserved word__</span></span> | <span data-ttu-id="01721-153">__Tipo com alias__</span><span class="sxs-lookup"><span data-stu-id="01721-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="01721-154">Como um tipo simples é alias de um tipo struct, cada tipo simples tem membros.</span><span class="sxs-lookup"><span data-stu-id="01721-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="01721-155">Por exemplo, `int` tem os membros declarados em `System.Int32` e os membros herdados de `System.Object`, e as instruções a seguir são permitidas:</span><span class="sxs-lookup"><span data-stu-id="01721-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="01721-156">Os tipos simples diferem de outros tipos de struct, pois permitem determinadas operações adicionais:</span><span class="sxs-lookup"><span data-stu-id="01721-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="01721-157">Os tipos mais simples permitem que os valores sejam criados escrevendo *literais* ([literais](lexical-structure.md#literals)).</span><span class="sxs-lookup"><span data-stu-id="01721-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="01721-158">Por exemplo, `123` é um literal do tipo `int` e `'a'` é um literal do tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="01721-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="01721-159">C#Não faz nenhuma provisão para literais de tipos struct em geral, e valores não padrão de outros tipos struct são, por fim, sempre criados por meio de construtores de instância desses tipos struct.</span><span class="sxs-lookup"><span data-stu-id="01721-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="01721-160">Quando os operandos de uma expressão são todas constantes de tipo simples, é possível que o compilador avalie a expressão em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="01721-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="01721-161">Essa expressão é conhecida como *constant_expression* ([expressões constantes](expressions.md#constant-expressions)).</span><span class="sxs-lookup"><span data-stu-id="01721-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="01721-162">As expressões que envolvem operadores definidos por outros tipos de struct não são consideradas expressões constantes.</span><span class="sxs-lookup"><span data-stu-id="01721-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="01721-163">Por meio de declarações `const` é possível declarar constantes dos tipos simples ([constantes](classes.md#constants)).</span><span class="sxs-lookup"><span data-stu-id="01721-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="01721-164">Não é possível ter constantes de outros tipos de struct, mas um efeito semelhante é fornecido por `static readonly` campos.</span><span class="sxs-lookup"><span data-stu-id="01721-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="01721-165">As conversões que envolvem tipos simples podem participar da avaliação de operadores de conversão definidos por outros tipos de struct, mas um operador de conversão definido pelo usuário nunca pode participar da avaliação de outro operador definido pelo usuário ([avaliação de conversões definidas pelo usuário](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="01721-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="01721-166">Tipos integrais</span><span class="sxs-lookup"><span data-stu-id="01721-166">Integral types</span></span>

<span data-ttu-id="01721-167">C#dá suporte a nove tipos integrais: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`e `char`.</span><span class="sxs-lookup"><span data-stu-id="01721-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="01721-168">Os tipos integrais têm os seguintes tamanhos e intervalos de valores:</span><span class="sxs-lookup"><span data-stu-id="01721-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="01721-169">O tipo de `sbyte` representa inteiros de 8 bits assinados com valores entre-128 e 127.</span><span class="sxs-lookup"><span data-stu-id="01721-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="01721-170">O tipo de `byte` representa inteiros de 8 bits não assinados com valores entre 0 e 255.</span><span class="sxs-lookup"><span data-stu-id="01721-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="01721-171">O tipo de `short` representa inteiros de 16 bits assinados com valores entre-32768 e 32767.</span><span class="sxs-lookup"><span data-stu-id="01721-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="01721-172">O tipo de `ushort` representa inteiros de 16 bits não assinados com valores entre 0 e 65535.</span><span class="sxs-lookup"><span data-stu-id="01721-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="01721-173">O tipo de `int` representa números inteiros de 32 bits assinados com valores entre-2147483648 e 2147483647.</span><span class="sxs-lookup"><span data-stu-id="01721-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="01721-174">O tipo de `uint` representa inteiros de 32 bits sem sinal com valores entre 0 e 4294967295.</span><span class="sxs-lookup"><span data-stu-id="01721-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="01721-175">O tipo de `long` representa números inteiros de 64 bits assinados com valores entre-9.223.372.036.854.775.808 e 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="01721-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="01721-176">O tipo de `ulong` representa inteiros de 64 bits sem sinal com valores entre 0 e 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="01721-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="01721-177">O tipo de `char` representa inteiros de 16 bits não assinados com valores entre 0 e 65535.</span><span class="sxs-lookup"><span data-stu-id="01721-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="01721-178">O conjunto de valores possíveis para o tipo `char` corresponde ao conjunto de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="01721-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="01721-179">Embora `char` tenha a mesma representação que `ushort`, nem todas as operações permitidas em um tipo são permitidas no outro.</span><span class="sxs-lookup"><span data-stu-id="01721-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="01721-180">Os operadores unários e binários de tipo integral sempre operam com precisão de 32 bits assinada, precisão de 32 bits sem sinal, precisão de 64 bits assinada ou precisão de 64 bits não assinado:</span><span class="sxs-lookup"><span data-stu-id="01721-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="01721-181">Para os operadores unários `+` e `~`, o operando é convertido no tipo `T`, onde `T` é o primeiro de `int`, `uint`, `long`e `ulong` que pode representar totalmente todos os valores possíveis do operando.</span><span class="sxs-lookup"><span data-stu-id="01721-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="01721-182">Em seguida, a operação é executada usando a precisão do tipo `T`e o tipo do resultado é `T`.</span><span class="sxs-lookup"><span data-stu-id="01721-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="01721-183">Para o operador de `-` unário, o operando é convertido no tipo `T`, em que `T` é o primeiro de `int` e `long` que pode representar totalmente todos os valores possíveis do operando.</span><span class="sxs-lookup"><span data-stu-id="01721-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="01721-184">Em seguida, a operação é executada usando a precisão do tipo `T`e o tipo do resultado é `T`.</span><span class="sxs-lookup"><span data-stu-id="01721-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="01721-185">O operador unário `-` não pode ser aplicado a operandos do tipo `ulong`.</span><span class="sxs-lookup"><span data-stu-id="01721-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="01721-186">Para os operadores binários `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`e `<=` , os operandos são convertidos no tipo `T`, em que `T` é o primeiro de `int`, `uint`, `long`e `ulong` que pode representar totalmente todos os valores possíveis de ambos os operandos.</span><span class="sxs-lookup"><span data-stu-id="01721-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="01721-187">Em seguida, a operação é executada usando a precisão do tipo `T`e o tipo do resultado é `T` (ou `bool` para os operadores relacionais).</span><span class="sxs-lookup"><span data-stu-id="01721-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="01721-188">Não é permitido que um operando seja do tipo `long` e o outro seja do tipo `ulong` com os operadores binários.</span><span class="sxs-lookup"><span data-stu-id="01721-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="01721-189">Para os operadores binários `<<` e `>>`, o operando esquerdo é convertido para o tipo `T`, em que `T` é o primeiro de `int`, `uint`, `long`e `ulong` que pode representar totalmente todos os valores possíveis do operando.</span><span class="sxs-lookup"><span data-stu-id="01721-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="01721-190">Em seguida, a operação é executada usando a precisão do tipo `T`e o tipo do resultado é `T`.</span><span class="sxs-lookup"><span data-stu-id="01721-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="01721-191">O tipo de `char` é classificado como um tipo integral, mas difere dos outros tipos integrais de duas maneiras:</span><span class="sxs-lookup"><span data-stu-id="01721-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="01721-192">Não há conversões implícitas de outros tipos para o tipo de `char`.</span><span class="sxs-lookup"><span data-stu-id="01721-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="01721-193">Em particular, embora os tipos `sbyte`, `byte`e `ushort` tenham intervalos de valores que são totalmente representáveis usando o tipo de `char`, conversões implícitas de `sbyte`, `byte`ou `ushort` para `char` não existem.</span><span class="sxs-lookup"><span data-stu-id="01721-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="01721-194">As constantes do tipo `char` devem ser gravadas como *character_literal*s ou como *integer_literal*s em combinação com uma conversão para o tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="01721-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="01721-195">Por exemplo, `(char)10` é o mesmo que `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="01721-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="01721-196">Os operadores e as instruções `checked` e `unchecked` são usados para controlar a verificação de estouro para operações aritméticas de tipo integral e conversões ([os operadores marcados e desmarcados](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="01721-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="01721-197">Em um contexto de `checked`, um estouro produz um erro de tempo de compilação ou faz com que uma `System.OverflowException` seja gerada.</span><span class="sxs-lookup"><span data-stu-id="01721-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="01721-198">Em um contexto de `unchecked`, os estouros são ignorados e quaisquer bits de ordem superior que não caibam no tipo de destino são descartados.</span><span class="sxs-lookup"><span data-stu-id="01721-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="01721-199">Tipos de ponto flutuante</span><span class="sxs-lookup"><span data-stu-id="01721-199">Floating point types</span></span>

<span data-ttu-id="01721-200">C#dá suporte a dois tipos de ponto flutuante: `float` e `double`.</span><span class="sxs-lookup"><span data-stu-id="01721-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="01721-201">Os tipos `float` e `double` são representados usando os formatos IEEE 754 de precisão simples de 32 bits e de 64 bits, que fornecem os seguintes conjuntos de valores:</span><span class="sxs-lookup"><span data-stu-id="01721-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="01721-202">Zero positivo e zero negativo.</span><span class="sxs-lookup"><span data-stu-id="01721-202">Positive zero and negative zero.</span></span> <span data-ttu-id="01721-203">Na maioria das situações, zero positivo e zero negativo se comportam de forma idêntica ao valor zero simples, mas determinadas operações distinguem entre os dois ([operador de divisão](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="01721-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="01721-204">Infinity positivo e infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="01721-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="01721-205">Os infinitos são produzidos por operações como a divisão de um número diferente de zero por zero.</span><span class="sxs-lookup"><span data-stu-id="01721-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="01721-206">Por exemplo, `1.0 / 0.0` produz infinito positivo e `-1.0 / 0.0` produz infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="01721-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="01721-207">O valor ***não-a-numérico*** , geralmente abreviado como NaN.</span><span class="sxs-lookup"><span data-stu-id="01721-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="01721-208">NaNs são produzidos por operações de ponto flutuante inválidas, como a divisão zero por zero.</span><span class="sxs-lookup"><span data-stu-id="01721-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="01721-209">O conjunto finito de valores diferentes de zero do formulário `s * m * 2^e`, em que `s` é 1 ou-1, e `m` e `e` são determinados pelo tipo de ponto flutuante específico: para `float`, `0 < m < 2^24` e `-149 <= e <= 104`e, para `double`, `0 < m < 2^53` e `-1075 <= e <= 970`.</span><span class="sxs-lookup"><span data-stu-id="01721-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `-1075 <= e <= 970`.</span></span> <span data-ttu-id="01721-210">Números de ponto flutuante desnormalizados são considerados valores não zero válidos.</span><span class="sxs-lookup"><span data-stu-id="01721-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="01721-211">O tipo de `float` pode representar valores que variam de aproximadamente `1.5 * 10^-45` para `3.4 * 10^38` com uma precisão de 7 dígitos.</span><span class="sxs-lookup"><span data-stu-id="01721-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="01721-212">O tipo de `double` pode representar valores que variam de aproximadamente `5.0 * 10^-324` para `1.7 × 10^308` com uma precisão de 15-16 dígitos.</span><span class="sxs-lookup"><span data-stu-id="01721-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="01721-213">Se um dos operandos de um operador binário for de um tipo de ponto flutuante, o outro operando deverá ser de um tipo integral ou de um tipo de ponto flutuante, e a operação será avaliada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="01721-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="01721-214">Se um dos operandos for de um tipo integral, esse operando será convertido no tipo de ponto flutuante do outro operando.</span><span class="sxs-lookup"><span data-stu-id="01721-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="01721-215">Em seguida, se qualquer um dos operandos for do tipo `double`, o outro operando será convertido em `double`, a operação será executada usando pelo menos `double` intervalo e precisão, e o tipo do resultado será `double` (ou `bool` para os operadores relacionais).</span><span class="sxs-lookup"><span data-stu-id="01721-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="01721-216">Caso contrário, a operação é executada usando pelo menos `float` intervalo e precisão, e o tipo do resultado é `float` (ou `bool` para os operadores relacionais).</span><span class="sxs-lookup"><span data-stu-id="01721-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="01721-217">Os operadores de ponto flutuante, incluindo os operadores de atribuição, nunca produzem exceções.</span><span class="sxs-lookup"><span data-stu-id="01721-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="01721-218">Em vez disso, em situações excepcionais, as operações de ponto flutuante produzem zero, infinito ou NaN, conforme descrito abaixo:</span><span class="sxs-lookup"><span data-stu-id="01721-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="01721-219">Se o resultado de uma operação de ponto flutuante for muito pequeno para o formato de destino, o resultado da operação se tornará positivo zero ou negativo zero.</span><span class="sxs-lookup"><span data-stu-id="01721-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="01721-220">Se o resultado de uma operação de ponto flutuante for muito grande para o formato de destino, o resultado da operação se tornará infinito positivo ou infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="01721-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="01721-221">Se uma operação de ponto flutuante for inválida, o resultado da operação se tornará NaN.</span><span class="sxs-lookup"><span data-stu-id="01721-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="01721-222">Se um ou ambos os operandos de uma operação de ponto flutuante forem NaN, o resultado da operação se tornará NaN.</span><span class="sxs-lookup"><span data-stu-id="01721-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="01721-223">As operações de ponto flutuante podem ser executadas com precisão mais alta do que o tipo de resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="01721-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="01721-224">Por exemplo, algumas arquiteturas de hardware dão suporte a um tipo de ponto flutuante "estendido" ou "longo Duplo" com maior intervalo e precisão do que o tipo de `double` e executam implicitamente todas as operações de ponto flutuante usando esse tipo de precisão mais alto.</span><span class="sxs-lookup"><span data-stu-id="01721-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="01721-225">Somente o custo excessivo no desempenho pode ser feito por tais arquiteturas de hardware para executar operações de ponto flutuante com menos precisão e, em vez de exigir uma implementação para perder o desempenho C# e a precisão, permite um tipo de precisão mais alto a ser usado para todas as operações de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="01721-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="01721-226">Além de fornecer resultados mais precisos, isso raramente tem efeitos mensuráveis.</span><span class="sxs-lookup"><span data-stu-id="01721-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="01721-227">No entanto, em expressões do formulário `x * y / z`, em que a multiplicação produz um resultado que está fora do intervalo de `double`, mas a divisão subsequente traz o resultado temporário de volta para o intervalo de `double`, o fato de que a expressão é avaliada em um o formato de intervalo superior pode fazer com que um resultado finito seja produzido em vez de um infinito.</span><span class="sxs-lookup"><span data-stu-id="01721-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="01721-228">O tipo decimal</span><span class="sxs-lookup"><span data-stu-id="01721-228">The decimal type</span></span>

<span data-ttu-id="01721-229">O tipo `decimal` é um tipo de dados de 128 bits adequado para cálculos financeiros e monetários.</span><span class="sxs-lookup"><span data-stu-id="01721-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="01721-230">O tipo de `decimal` pode representar valores que variam de `1.0 * 10^-28` para aproximadamente `7.9 * 10^28` com 28-29 dígitos significativos.</span><span class="sxs-lookup"><span data-stu-id="01721-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="01721-231">O conjunto finito de valores do tipo `decimal` estão no formato `(-1)^s * c * 10^-e`, em que o sinal `s` é 0 ou 1, o coeficiente `c` é fornecido por `0 <= *c* < 2^96`e a `e` de escala é tal `0 <= e <= 28`. O tipo de `decimal` não dá suporte a zeros assinados, infinitos ou NaN.</span><span class="sxs-lookup"><span data-stu-id="01721-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="01721-232">Uma `decimal` é representada como um inteiro de 96 bits dimensionado por uma potência de dez.</span><span class="sxs-lookup"><span data-stu-id="01721-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="01721-233">Para `decimal`s com um valor absoluto menor que `1.0m`, o valor é exato para a casa de 28 casas decimais, mas não há mais.</span><span class="sxs-lookup"><span data-stu-id="01721-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="01721-234">Para `decimal`s com um valor absoluto maior ou igual a `1.0m`, o valor é exato para 28 ou 29 dígitos.</span><span class="sxs-lookup"><span data-stu-id="01721-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="01721-235">Ao contrário dos tipos de dados `float` e `double`, números fracionários decimais, como 0,1, podem ser representados exatamente na representação de `decimal`.</span><span class="sxs-lookup"><span data-stu-id="01721-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="01721-236">Nas representações de `float` e `double`, esses números geralmente são frações infinitas, tornando essas representações mais propensas a erros de arredondamento.</span><span class="sxs-lookup"><span data-stu-id="01721-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="01721-237">Se um dos operandos de um operador binário for do tipo `decimal`, o outro operando deverá ser de um tipo integral ou do tipo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="01721-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="01721-238">Se um operando de tipo integral estiver presente, ele será convertido em `decimal` antes de a operação ser executada.</span><span class="sxs-lookup"><span data-stu-id="01721-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="01721-239">O resultado de uma operação em valores do tipo `decimal` é que isso resultaria no cálculo de um resultado exato (preservando a escala, conforme definido para cada operador) e, em seguida, arredondando para se ajustar à representação.</span><span class="sxs-lookup"><span data-stu-id="01721-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="01721-240">Os resultados são arredondados para o valor representável mais próximo e, quando um resultado é igualmente próximo a dois valores representáveis, para o valor que tem um número par na posição de dígito menos significativa (isso é conhecido como "arredondamento do banco").</span><span class="sxs-lookup"><span data-stu-id="01721-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="01721-241">Um resultado zero sempre tem um sinal de 0 e uma escala de 0.</span><span class="sxs-lookup"><span data-stu-id="01721-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="01721-242">Se uma operação aritmética decimal produzir um valor menor ou igual a `5 * 10^-29` em valor absoluto, o resultado da operação se tornará zero.</span><span class="sxs-lookup"><span data-stu-id="01721-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="01721-243">Se uma `decimal` operação aritmética produzir um resultado muito grande para o formato de `decimal`, uma `System.OverflowException` será lançada.</span><span class="sxs-lookup"><span data-stu-id="01721-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="01721-244">O tipo de `decimal` tem maior precisão, mas um intervalo menor do que os tipos de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="01721-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="01721-245">Assim, as conversões dos tipos de ponto flutuante para `decimal` podem produzir exceções de estouro, e as conversões de `decimal` para os tipos de ponto flutuante podem causar perda de precisão.</span><span class="sxs-lookup"><span data-stu-id="01721-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="01721-246">Por esses motivos, não existem conversões implícitas entre os tipos de ponto flutuante e `decimal`e sem conversões explícitas, não é possível misturar os operandos de ponto flutuante e `decimal` na mesma expressão.</span><span class="sxs-lookup"><span data-stu-id="01721-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="01721-247">O tipo bool</span><span class="sxs-lookup"><span data-stu-id="01721-247">The bool type</span></span>

<span data-ttu-id="01721-248">O tipo de `bool` representa quantidades lógicas boolianas.</span><span class="sxs-lookup"><span data-stu-id="01721-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="01721-249">Os valores possíveis do tipo `bool` são `true` e `false`.</span><span class="sxs-lookup"><span data-stu-id="01721-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="01721-250">Não existem conversões padrão entre `bool` e outros tipos.</span><span class="sxs-lookup"><span data-stu-id="01721-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="01721-251">Em particular, o tipo de `bool` é distinto e separado dos tipos integrais, e um valor de `bool` não pode ser usado no lugar de um valor integral e vice-versa.</span><span class="sxs-lookup"><span data-stu-id="01721-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="01721-252">Nas linguagens C C++ e, um valor integral zero ou de ponto flutuante, ou um ponteiro nulo pode ser convertido para o valor booliano `false`e um valor de ponto flutuante ou integral diferente de zero, ou um ponteiro não nulo pode ser convertido para o valor booliano `true`.</span><span class="sxs-lookup"><span data-stu-id="01721-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="01721-253">No C#, essas conversões são realizadas comparando explicitamente um valor integral ou de ponto flutuante para zero ou comparando explicitamente uma referência de objeto para `null`.</span><span class="sxs-lookup"><span data-stu-id="01721-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="01721-254">Tipos de enumeração</span><span class="sxs-lookup"><span data-stu-id="01721-254">Enumeration types</span></span>

<span data-ttu-id="01721-255">Um tipo de enumeração é um tipo distinto com constantes nomeadas.</span><span class="sxs-lookup"><span data-stu-id="01721-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="01721-256">Cada tipo de enumeração tem um tipo subjacente, que deve ser `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` ou `ulong`.</span><span class="sxs-lookup"><span data-stu-id="01721-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="01721-257">O conjunto de valores do tipo de enumeração é o mesmo que o conjunto de valores do tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="01721-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="01721-258">Os valores do tipo de enumeração não são restritos aos valores das constantes nomeadas.</span><span class="sxs-lookup"><span data-stu-id="01721-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="01721-259">Os tipos de enumeração são definidos por meio de declarações de enumeração ([declarações enum](enums.md#enum-declarations)).</span><span class="sxs-lookup"><span data-stu-id="01721-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="01721-260">Tipos que permitem valor nulo</span><span class="sxs-lookup"><span data-stu-id="01721-260">Nullable types</span></span>

<span data-ttu-id="01721-261">Um tipo anulável pode representar todos os valores de seu ***tipo subjacente*** , além de um valor nulo adicional.</span><span class="sxs-lookup"><span data-stu-id="01721-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="01721-262">Um tipo anulável é gravado `T?`, em que `T` é o tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="01721-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="01721-263">Essa sintaxe é abreviada para `System.Nullable<T>`e os dois formulários podem ser usados de forma intercambiável.</span><span class="sxs-lookup"><span data-stu-id="01721-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="01721-264">Um ***tipo de valor não anulável por*** outro lado é qualquer tipo de valor diferente de `System.Nullable<T>` e sua `T?` abreviada (para qualquer `T`), além de qualquer parâmetro de tipo restrito a ser um tipo de valor não anulável (ou seja, qualquer parâmetro de tipo com um `struct` restrição).</span><span class="sxs-lookup"><span data-stu-id="01721-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="01721-265">O tipo de `System.Nullable<T>` especifica a restrição de tipo de valor para `T` ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)), o que significa que o tipo subjacente de um tipo anulável pode ser qualquer tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="01721-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="01721-266">O tipo subjacente de um tipo anulável não pode ser um tipo anulável ou um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="01721-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="01721-267">Por exemplo, `int??` e `string?` são tipos inválidos.</span><span class="sxs-lookup"><span data-stu-id="01721-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="01721-268">Uma instância de um tipo anulável `T?` tem duas propriedades públicas somente leitura:</span><span class="sxs-lookup"><span data-stu-id="01721-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="01721-269">Uma propriedade `HasValue` do tipo `bool`</span><span class="sxs-lookup"><span data-stu-id="01721-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="01721-270">Uma propriedade `Value` do tipo `T`</span><span class="sxs-lookup"><span data-stu-id="01721-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="01721-271">Uma instância para a qual `HasValue` é true é considerada não nula.</span><span class="sxs-lookup"><span data-stu-id="01721-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="01721-272">Uma instância não nula contém um valor conhecido e `Value` retorna esse valor.</span><span class="sxs-lookup"><span data-stu-id="01721-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="01721-273">Uma instância para a qual `HasValue` é falsa é indicada como NULL.</span><span class="sxs-lookup"><span data-stu-id="01721-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="01721-274">Uma instância nula tem um valor indefinido.</span><span class="sxs-lookup"><span data-stu-id="01721-274">A null instance has an undefined value.</span></span> <span data-ttu-id="01721-275">A tentativa de ler a `Value` de uma instância nula faz com que uma `System.InvalidOperationException` seja gerada.</span><span class="sxs-lookup"><span data-stu-id="01721-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="01721-276">O processo de acessar a propriedade `Value` de uma instância anulável é chamado de ***desencapsulamento***.</span><span class="sxs-lookup"><span data-stu-id="01721-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="01721-277">Além do construtor padrão, todo tipo anulável `T?` tem um construtor público que usa um único argumento do tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="01721-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="01721-278">Dado um valor `x` do tipo `T`, uma invocação de construtor do formulário</span><span class="sxs-lookup"><span data-stu-id="01721-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="01721-279">Cria uma instância não nula do `T?` para o qual a propriedade `Value` é `x`.</span><span class="sxs-lookup"><span data-stu-id="01721-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="01721-280">O processo de criação de uma instância não nula de um tipo anulável para um determinado valor é chamado de ***encapsulamento***.</span><span class="sxs-lookup"><span data-stu-id="01721-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="01721-281">Conversões implícitas estão disponíveis no `null` literal para `T?` ([conversões literais nulas](conversions.md#null-literal-conversions)) e de `T` a `T?` ([conversões anuláveis implícitas](conversions.md#implicit-nullable-conversions)).</span><span class="sxs-lookup"><span data-stu-id="01721-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="01721-282">Tipos de referência</span><span class="sxs-lookup"><span data-stu-id="01721-282">Reference types</span></span>

<span data-ttu-id="01721-283">Um tipo de referência é um tipo de classe, um tipo de interface, um tipo de matriz ou um tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="01721-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="01721-284">Um valor de tipo de referência é uma referência a uma ***instância*** do tipo, o último conhecido como um ***objeto***.</span><span class="sxs-lookup"><span data-stu-id="01721-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="01721-285">O valor especial `null` é compatível com todos os tipos de referência e indica a ausência de uma instância.</span><span class="sxs-lookup"><span data-stu-id="01721-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="01721-286">Tipos de classe</span><span class="sxs-lookup"><span data-stu-id="01721-286">Class types</span></span>

<span data-ttu-id="01721-287">Um tipo de classe define uma estrutura de dados que contém membros de dados (constantes e campos), membros de função (métodos, propriedades, eventos, indexadores, operadores, construtores de instância, destruidores e construtores estáticos) e tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="01721-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="01721-288">Os tipos de classe dão suporte à herança, um mecanismo pelo qual classes derivadas podem estender e especializar classes base.</span><span class="sxs-lookup"><span data-stu-id="01721-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="01721-289">Instâncias de tipos de classe são criadas usando *object_creation_expression*s ([expressões de criação de objeto](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="01721-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="01721-290">Os tipos de classe são descritos em [classes](classes.md).</span><span class="sxs-lookup"><span data-stu-id="01721-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="01721-291">Determinados tipos de classe predefinidos têm significado C# especial na linguagem, conforme descrito na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="01721-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="01721-292">__Tipo de classe__</span><span class="sxs-lookup"><span data-stu-id="01721-292">__Class type__</span></span>     | <span data-ttu-id="01721-293">__Descrição__</span><span class="sxs-lookup"><span data-stu-id="01721-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="01721-294">A classe base definitiva de todos os outros tipos.</span><span class="sxs-lookup"><span data-stu-id="01721-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="01721-295">Consulte [o tipo de objeto](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="01721-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="01721-296">O tipo de cadeia de C# caracteres do idioma.</span><span class="sxs-lookup"><span data-stu-id="01721-296">The string type of the C# language.</span></span> <span data-ttu-id="01721-297">Consulte [o tipo de cadeia de caracteres](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="01721-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="01721-298">A classe base de todos os tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="01721-298">The base class of all value types.</span></span> <span data-ttu-id="01721-299">Consulte [o tipo System. ValueType](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="01721-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="01721-300">A classe base de todos os tipos enum.</span><span class="sxs-lookup"><span data-stu-id="01721-300">The base class of all enum types.</span></span> <span data-ttu-id="01721-301">Consulte [enums](enums.md).</span><span class="sxs-lookup"><span data-stu-id="01721-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="01721-302">A classe base de todos os tipos de matriz.</span><span class="sxs-lookup"><span data-stu-id="01721-302">The base class of all array types.</span></span> <span data-ttu-id="01721-303">Consulte [Matrizes](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="01721-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="01721-304">A classe base de todos os tipos delegados.</span><span class="sxs-lookup"><span data-stu-id="01721-304">The base class of all delegate types.</span></span> <span data-ttu-id="01721-305">Consulte [delegados](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="01721-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="01721-306">A classe base de todos os tipos de exceção.</span><span class="sxs-lookup"><span data-stu-id="01721-306">The base class of all exception types.</span></span> <span data-ttu-id="01721-307">Consulte [exceções](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="01721-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="01721-308">O tipo de objeto</span><span class="sxs-lookup"><span data-stu-id="01721-308">The object type</span></span>

<span data-ttu-id="01721-309">O tipo de classe `object` é a classe base definitiva de todos os outros tipos.</span><span class="sxs-lookup"><span data-stu-id="01721-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="01721-310">Cada tipo em C# deriva direta ou indiretamente do tipo de classe `object`.</span><span class="sxs-lookup"><span data-stu-id="01721-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="01721-311">A palavra-chave `object` é simplesmente um alias para a classe predefinida `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="01721-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="01721-312">O tipo dinâmico</span><span class="sxs-lookup"><span data-stu-id="01721-312">The dynamic type</span></span>

<span data-ttu-id="01721-313">O tipo de `dynamic`, como `object`, pode fazer referência a qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="01721-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="01721-314">Quando os operadores são aplicados a expressões do tipo `dynamic`, sua resolução é adiada até que o programa seja executado.</span><span class="sxs-lookup"><span data-stu-id="01721-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="01721-315">Portanto, se o operador não puder ser aplicado legalmente ao objeto referenciado, nenhum erro será fornecido durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="01721-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="01721-316">Em vez disso, uma exceção será lançada quando a resolução do operador falhar em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="01721-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="01721-317">Sua finalidade é permitir a vinculação dinâmica, que é descrita em detalhes na [vinculação dinâmica](expressions.md#dynamic-binding).</span><span class="sxs-lookup"><span data-stu-id="01721-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="01721-318">`dynamic` é considerado idêntico ao `object`, exceto nos seguintes aspectos:</span><span class="sxs-lookup"><span data-stu-id="01721-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="01721-319">As operações em expressões do tipo `dynamic` podem ser vinculadas dinamicamente ([associação dinâmica](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="01721-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="01721-320">A inferência de tipos ([inferência de tipos](expressions.md#type-inference)) prefere `dynamic` sobre `object` se ambos forem candidatos.</span><span class="sxs-lookup"><span data-stu-id="01721-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="01721-321">Devido a essa equivalência, o seguinte contém:</span><span class="sxs-lookup"><span data-stu-id="01721-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="01721-322">Há uma conversão de identidade implícita entre `object` e `dynamic`e entre os tipos construídos que são os mesmos ao substituir `dynamic` por `object`</span><span class="sxs-lookup"><span data-stu-id="01721-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="01721-323">Conversões implícitas e explícitas de e para `object` também se aplicam de e para `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="01721-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="01721-324">As assinaturas de método que são iguais ao substituir `dynamic` com `object` são consideradas a mesma assinatura</span><span class="sxs-lookup"><span data-stu-id="01721-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="01721-325">O tipo `dynamic` é indistinguíveis de `object` em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="01721-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="01721-326">Uma expressão do tipo `dynamic` é referenciada como uma ***expressão dinâmica***.</span><span class="sxs-lookup"><span data-stu-id="01721-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="01721-327">O tipo de cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="01721-327">The string type</span></span>

<span data-ttu-id="01721-328">O tipo de `string` é um tipo de classe lacrado que herda diretamente de `object`.</span><span class="sxs-lookup"><span data-stu-id="01721-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="01721-329">As instâncias da classe `string` representam cadeias de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="01721-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="01721-330">Os valores do tipo de `string` podem ser gravados como literais de cadeia de caracteres ([literais de cadeia de caracteres](lexical-structure.md#string-literals)).</span><span class="sxs-lookup"><span data-stu-id="01721-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="01721-331">A palavra-chave `string` é simplesmente um alias para a classe predefinida `System.String`.</span><span class="sxs-lookup"><span data-stu-id="01721-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="01721-332">Tipos de interface</span><span class="sxs-lookup"><span data-stu-id="01721-332">Interface types</span></span>

<span data-ttu-id="01721-333">Uma interface define um contrato.</span><span class="sxs-lookup"><span data-stu-id="01721-333">An interface defines a contract.</span></span> <span data-ttu-id="01721-334">Uma classe ou struct que implementa uma interface deve aderir a seu contrato.</span><span class="sxs-lookup"><span data-stu-id="01721-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="01721-335">Uma interface pode herdar de várias interfaces base e uma classe ou estrutura pode implementar várias interfaces.</span><span class="sxs-lookup"><span data-stu-id="01721-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="01721-336">Os tipos de interface são descritos em [interfaces](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="01721-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="01721-337">Tipos de matriz</span><span class="sxs-lookup"><span data-stu-id="01721-337">Array types</span></span>

<span data-ttu-id="01721-338">Uma matriz é uma estrutura de dados que contém zero ou mais variáveis que são acessadas por meio de índices computados.</span><span class="sxs-lookup"><span data-stu-id="01721-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="01721-339">As variáveis contidas em uma matriz, também chamadas de elementos da matriz, são do mesmo tipo, e esse tipo é chamado de tipo de elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="01721-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="01721-340">Os tipos de matriz são descritos em [matrizes](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="01721-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="01721-341">Tipos delegados</span><span class="sxs-lookup"><span data-stu-id="01721-341">Delegate types</span></span>

<span data-ttu-id="01721-342">Um delegado é uma estrutura de dados que se refere a um ou mais métodos.</span><span class="sxs-lookup"><span data-stu-id="01721-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="01721-343">Para métodos de instância, ele também se refere às suas instâncias de objeto correspondentes.</span><span class="sxs-lookup"><span data-stu-id="01721-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="01721-344">O equivalente mais próximo de um delegado em C ou C++ é um ponteiro de função, mas enquanto um ponteiro de função só pode referenciar funções estáticas, um delegado pode fazer referência a métodos estáticos e de instância.</span><span class="sxs-lookup"><span data-stu-id="01721-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="01721-345">No último caso, o delegado armazena não apenas uma referência ao ponto de entrada do método, mas também uma referência à instância do objeto na qual invocar o método.</span><span class="sxs-lookup"><span data-stu-id="01721-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="01721-346">Os tipos delegados são descritos em [delegados](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="01721-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="01721-347">Conversões boxing e unboxing</span><span class="sxs-lookup"><span data-stu-id="01721-347">Boxing and unboxing</span></span>

<span data-ttu-id="01721-348">O conceito de boxing e unboxing é fundamental para C#o sistema de tipos.</span><span class="sxs-lookup"><span data-stu-id="01721-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="01721-349">Ele fornece uma ponte entre *value_type*s e *reference_type*s, permitindo que qualquer valor de um *value_type* seja convertido de e para o tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="01721-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="01721-350">Boxing e unboxing permitem uma exibição unificada do sistema de tipos, em que um valor de qualquer tipo pode ser tratado, por fim, como um objeto.</span><span class="sxs-lookup"><span data-stu-id="01721-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="01721-351">Conversões de Boxing</span><span class="sxs-lookup"><span data-stu-id="01721-351">Boxing conversions</span></span>

<span data-ttu-id="01721-352">Uma conversão boxing permite que um *value_type* seja convertido implicitamente em um *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="01721-353">Existem as seguintes conversões de boxing:</span><span class="sxs-lookup"><span data-stu-id="01721-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="01721-354">De qualquer *value_type* para o tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="01721-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="01721-355">De qualquer *value_type* para o tipo `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="01721-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="01721-356">De qualquer *non_nullable_value_type* para qualquer *interface_type* implementado pelo *value_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="01721-357">De qualquer *nullable_type* para qualquer *interface_type* implementado pelo tipo subjacente do *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="01721-358">De qualquer *enum_type* para o tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="01721-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="01721-359">De qualquer *nullable_type* com um *enum_type* subjacente para o tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="01721-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="01721-360">Observe que uma conversão implícita de um parâmetro de tipo será executada como uma conversão boxing se em tempo de execução acabar convertendo de um tipo de valor para um tipo de referência ([conversões implícitas envolvendo parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="01721-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="01721-361">Boxing um valor de um *non_nullable_value_type* consiste em alocar uma instância de objeto e copiar o valor de *non_nullable_value_type* nessa instância.</span><span class="sxs-lookup"><span data-stu-id="01721-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="01721-362">Boxing um valor de um *nullable_type* produzirá uma referência nula se for o valor `null` (`HasValue` é `false`) ou o resultado de desencapsulamento e Boxing do valor subjacente, caso contrário.</span><span class="sxs-lookup"><span data-stu-id="01721-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="01721-363">O processo real de boxing, um valor de um *non_nullable_value_type* , é mais bem explicado ao imaginar a existência de uma ***classe Boxing***genérica, que se comporta como se fosse declarada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="01721-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="01721-364">A Boxing de um valor `v` do tipo `T` agora consiste em executar a expressão `new Box<T>(v)`e retornar a instância resultante como um valor do tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="01721-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="01721-365">Portanto, as instruções</span><span class="sxs-lookup"><span data-stu-id="01721-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="01721-366">corresponde conceitualmente a</span><span class="sxs-lookup"><span data-stu-id="01721-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="01721-367">Uma classe Boxing como `Box<T>` acima não existe realmente e o tipo dinâmico de um valor boxed não é, na verdade, um tipo de classe.</span><span class="sxs-lookup"><span data-stu-id="01721-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="01721-368">Em vez disso, um valor em caixa do tipo `T` tem o tipo dinâmico `T`e uma verificação de tipo dinâmico usando o operador `is` pode simplesmente referenciar o tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="01721-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="01721-369">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="01721-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="01721-370">produzirá a cadeia de caracteres "`Box contains an int`" no console.</span><span class="sxs-lookup"><span data-stu-id="01721-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="01721-371">Uma conversão de Boxing implica fazer uma cópia do valor em caixa.</span><span class="sxs-lookup"><span data-stu-id="01721-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="01721-372">Isso é diferente de uma conversão de um *reference_type* para o tipo `object`, no qual o valor continua referenciando a mesma instância e simplesmente é considerado como o tipo menos derivado `object`.</span><span class="sxs-lookup"><span data-stu-id="01721-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="01721-373">Por exemplo, dada a declaração</span><span class="sxs-lookup"><span data-stu-id="01721-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="01721-374">as instruções a seguir</span><span class="sxs-lookup"><span data-stu-id="01721-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="01721-375">produzirá o valor 10 no console, pois a operação Boxing implícita que ocorre na atribuição de `p` para `box` faz com que o valor de `p` seja copiado.</span><span class="sxs-lookup"><span data-stu-id="01721-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="01721-376">`Point` foi declarada uma `class` em vez disso, o valor 20 seria resultado porque `p` e `box` referenciariam a mesma instância.</span><span class="sxs-lookup"><span data-stu-id="01721-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="01721-377">Conversões de unboxing</span><span class="sxs-lookup"><span data-stu-id="01721-377">Unboxing conversions</span></span>

<span data-ttu-id="01721-378">Uma conversão unboxing permite que um *reference_type* seja explicitamente convertido em um *value_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="01721-379">Existem as seguintes conversões de não conboxing:</span><span class="sxs-lookup"><span data-stu-id="01721-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="01721-380">Do tipo `object` para qualquer *value_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="01721-381">Do tipo `System.ValueType` para qualquer *value_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="01721-382">De qualquer *interface_type* a qualquer *non_nullable_value_type* que implemente o *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="01721-383">De qualquer *interface_type* a qualquer *nullable_type* cujo tipo subjacente implemente o *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="01721-384">Do tipo `System.Enum` para qualquer *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="01721-385">Do tipo `System.Enum` para qualquer *nullable_type* com um *enum_type*subjacente.</span><span class="sxs-lookup"><span data-stu-id="01721-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="01721-386">Observe que uma conversão explícita em um parâmetro de tipo será executada como uma conversão sem Boxing se, em tempo de execução, ele terminar a conversão de um tipo de referência para um tipo de valor ([conversões dinâmicas explícitas](conversions.md#explicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="01721-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="01721-387">Uma operação de unboxing para um *non_nullable_value_type* consiste na primeira verificação de que a instância do objeto é um valor em caixa do *non_nullable_value_type*especificado e, em seguida, copiar o valor para fora da instância.</span><span class="sxs-lookup"><span data-stu-id="01721-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="01721-388">Unboxing para um *nullable_type* produz o valor nulo de *nullable_type* se o operando de origem for `null`ou o resultado encapsulado de uma instância de objeto para o tipo subjacente de *nullable_type* não for o caso.</span><span class="sxs-lookup"><span data-stu-id="01721-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="01721-389">Fazendo referência à classe de conversão de erros imaginário descrita na seção anterior, uma conversão unboxing de um objeto `box` a uma `T` *value_type* consiste em executar a expressão `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="01721-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="01721-390">Portanto, as instruções</span><span class="sxs-lookup"><span data-stu-id="01721-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="01721-391">corresponde conceitualmente a</span><span class="sxs-lookup"><span data-stu-id="01721-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="01721-392">Para que uma conversão de unboxing para um determinado *non_nullable_value_type* seja realizada em tempo de execução, o valor do operando de origem deve ser uma referência a um valor de Boxed desse *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="01721-393">Se o operando de origem for `null`, um `System.NullReferenceException` será gerado.</span><span class="sxs-lookup"><span data-stu-id="01721-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="01721-394">Se o operando de origem for uma referência a um objeto incompatível, um `System.InvalidCastException` será gerado.</span><span class="sxs-lookup"><span data-stu-id="01721-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="01721-395">Para que uma conversão sem Boxing para um determinado *nullable_type* tenha sucesso em tempo de execução, o valor do operando de origem deve ser `null` ou uma referência a um valor em caixa do *non_nullable_value_type* subjacente do *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="01721-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="01721-396">Se o operando de origem for uma referência a um objeto incompatível, um `System.InvalidCastException` será gerado.</span><span class="sxs-lookup"><span data-stu-id="01721-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="01721-397">Tipos construídos</span><span class="sxs-lookup"><span data-stu-id="01721-397">Constructed types</span></span>

<span data-ttu-id="01721-398">Uma declaração de tipo genérico, por si só, denota um ***tipo genérico não associado*** que é usado como um "plano gráfico" para formar muitos tipos diferentes, por meio da aplicação de ***argumentos de tipo***.</span><span class="sxs-lookup"><span data-stu-id="01721-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="01721-399">Os argumentos de tipo são gravados entre colchetes angulares (`<` e `>`) imediatamente após o nome do tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="01721-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="01721-400">Um tipo que inclui pelo menos um argumento de tipo é chamado de ***tipo construído***.</span><span class="sxs-lookup"><span data-stu-id="01721-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="01721-401">Um tipo construído pode ser usado na maioria dos lugares no idioma em que um nome de tipo pode aparecer.</span><span class="sxs-lookup"><span data-stu-id="01721-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="01721-402">Um tipo genérico não associado só pode ser usado em um *typeof_expression* ([o operador typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="01721-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="01721-403">Os tipos construídos também podem ser usados em expressões como nomes simples ([nomes simples](expressions.md#simple-names)) ou ao acessar um membro ([acesso de membro](expressions.md#member-access)).</span><span class="sxs-lookup"><span data-stu-id="01721-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="01721-404">Quando um *namespace_or_type_name* é avaliado, somente tipos genéricos com o número correto de parâmetros de tipo são considerados.</span><span class="sxs-lookup"><span data-stu-id="01721-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="01721-405">Portanto, é possível usar o mesmo identificador para identificar diferentes tipos, desde que os tipos tenham números diferentes de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="01721-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="01721-406">Isso é útil ao misturar classes genéricas e não genéricas no mesmo programa:</span><span class="sxs-lookup"><span data-stu-id="01721-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="01721-407">Um *type_name* pode identificar um tipo construído, mesmo que ele não especifique parâmetros de tipo diretamente.</span><span class="sxs-lookup"><span data-stu-id="01721-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="01721-408">Isso pode ocorrer quando um tipo é aninhado dentro de uma declaração de classe genérica, e o tipo de instância da declaração recipiente é usado implicitamente para pesquisa de nome ([tipos aninhados em classes genéricas](classes.md#nested-types-in-generic-classes)):</span><span class="sxs-lookup"><span data-stu-id="01721-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="01721-409">Em código não seguro, um tipo construído não pode ser usado como um *unmanaged_type* ([tipos de ponteiro](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="01721-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="01721-410">Argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="01721-410">Type arguments</span></span>

<span data-ttu-id="01721-411">Cada argumento em uma lista de argumentos de tipo é simplesmente um *tipo*.</span><span class="sxs-lookup"><span data-stu-id="01721-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="01721-412">Em código não seguro ([código não seguro](unsafe-code.md)), um *type_argument* não pode ser um tipo de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="01721-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="01721-413">Cada argumento de tipo deve atender a qualquer restrição no parâmetro de tipo correspondente ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="01721-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="01721-414">Tipos abertos e fechados</span><span class="sxs-lookup"><span data-stu-id="01721-414">Open and closed types</span></span>

<span data-ttu-id="01721-415">Todos os tipos podem ser classificados como ***tipos abertos*** ou ***fechados***.</span><span class="sxs-lookup"><span data-stu-id="01721-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="01721-416">Um tipo aberto é um tipo que envolve parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="01721-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="01721-417">Mais especificamente:</span><span class="sxs-lookup"><span data-stu-id="01721-417">More specifically:</span></span>

*  <span data-ttu-id="01721-418">Um parâmetro de tipo define um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="01721-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="01721-419">Um tipo de matriz é um tipo aberto se e somente se seu tipo de elemento for um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="01721-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="01721-420">Um tipo construído é um tipo aberto se e somente se um ou mais dos seus argumentos de tipo for um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="01721-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="01721-421">Um tipo aninhado construído é um tipo aberto se e somente se um ou mais dos seus argumentos de tipo ou os argumentos de tipo de seus tipos contiverem um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="01721-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="01721-422">Um tipo fechado é um tipo que não é um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="01721-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="01721-423">Em tempo de execução, todo o código dentro de uma declaração de tipo genérico é executado no contexto de um tipo construído fechado que foi criado pela aplicação de argumentos de tipo à declaração genérica.</span><span class="sxs-lookup"><span data-stu-id="01721-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="01721-424">Cada parâmetro de tipo dentro do tipo genérico está associado a um tipo de tempo de execução específico.</span><span class="sxs-lookup"><span data-stu-id="01721-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="01721-425">O processamento em tempo de execução de todas as instruções e expressões sempre ocorre com tipos fechados e os tipos abertos ocorrem somente durante o processamento de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="01721-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="01721-426">Cada tipo construído fechado tem seu próprio conjunto de variáveis estáticas, que não são compartilhadas com nenhum outro tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="01721-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="01721-427">Como um tipo aberto não existe em tempo de execução, não há variáveis estáticas associadas a um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="01721-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="01721-428">Dois tipos construídos fechados são o mesmo tipo se forem construídos do mesmo tipo genérico não associado e seus argumentos de tipo correspondentes forem do mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="01721-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="01721-429">Tipos vinculados e desvinculados</span><span class="sxs-lookup"><span data-stu-id="01721-429">Bound and unbound types</span></span>

<span data-ttu-id="01721-430">O termo ***tipo não associado*** se refere a um tipo não genérico ou a um tipo genérico não associado.</span><span class="sxs-lookup"><span data-stu-id="01721-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="01721-431">O termo ***tipo associado*** refere-se a um tipo não genérico ou construído.</span><span class="sxs-lookup"><span data-stu-id="01721-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="01721-432">Um tipo não associado refere-se à entidade declarada por uma declaração de tipo.</span><span class="sxs-lookup"><span data-stu-id="01721-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="01721-433">Um tipo genérico não associado não é, em si, um tipo e não pode ser usado como o tipo de uma variável, um argumento ou um valor de retorno, ou como um tipo base.</span><span class="sxs-lookup"><span data-stu-id="01721-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="01721-434">A única construção na qual um tipo genérico não associado pode ser referenciado é a expressão `typeof` ([o operador typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="01721-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="01721-435">Atendendo às restrições</span><span class="sxs-lookup"><span data-stu-id="01721-435">Satisfying constraints</span></span>

<span data-ttu-id="01721-436">Sempre que um tipo construído ou um método genérico é referenciado, os argumentos de tipo fornecidos são verificados em relação às restrições de parâmetro de tipo declaradas no tipo ou método genérico ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="01721-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="01721-437">Para cada cláusula de `where`, o argumento de tipo `A` que corresponde ao parâmetro de tipo nomeado é verificado em relação a cada restrição da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="01721-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="01721-438">Se a restrição for um tipo de classe, um tipo de interface ou um parâmetro de tipo, deixe `C` representar essa restrição com os argumentos de tipo fornecidos substituídos por qualquer parâmetro de tipo que apareça na restrição.</span><span class="sxs-lookup"><span data-stu-id="01721-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="01721-439">Para atender à restrição, ele deve ser o caso em que o tipo `A` é conversível para digitar `C` por um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="01721-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="01721-440">Uma conversão de identidade ([conversão de identidade](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="01721-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="01721-441">Uma conversão de referência implícita ([conversões de referência implícita](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="01721-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="01721-442">Uma conversão boxing ([conversões Boxing](conversions.md#boxing-conversions)), desde que o tipo a seja um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="01721-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="01721-443">Uma referência implícita, Boxing ou conversão de parâmetro de tipo de um parâmetro de tipo `A` para `C`.</span><span class="sxs-lookup"><span data-stu-id="01721-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="01721-444">Se a restrição for a restrição de tipo de referência (`class`), o tipo `A` deverá satisfazer um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="01721-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="01721-445">`A` é um tipo de interface, tipo de classe, tipo delegado ou tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="01721-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="01721-446">Observe que `System.ValueType` e `System.Enum` são tipos de referência que atendem a essa restrição.</span><span class="sxs-lookup"><span data-stu-id="01721-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="01721-447">`A` é um parâmetro de tipo que é conhecido como um tipo de referência ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="01721-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="01721-448">Se a restrição for a restrição de tipo de valor (`struct`), o tipo `A` deverá satisfazer um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="01721-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="01721-449">`A` é um tipo de struct ou tipo de enumeração, mas não um tipo anulável.</span><span class="sxs-lookup"><span data-stu-id="01721-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="01721-450">Observe que `System.ValueType` e `System.Enum` são tipos de referência que não atendem a essa restrição.</span><span class="sxs-lookup"><span data-stu-id="01721-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="01721-451">`A` é um parâmetro de tipo que tem a restrição de tipo de valor ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="01721-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="01721-452">Se a restrição for a restrição de Construtor `new()`, o tipo `A` não deverá ser `abstract` e deverá ter um construtor público sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="01721-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="01721-453">Isso será atendido se uma das seguintes opções for verdadeira:</span><span class="sxs-lookup"><span data-stu-id="01721-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="01721-454">`A` é um tipo de valor, já que todos os tipos de valor têm um construtor público padrão ([construtores padrão](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="01721-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="01721-455">`A` é um parâmetro de tipo que tem a restrição de Construtor ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="01721-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="01721-456">`A` é um parâmetro de tipo que tem a restrição de tipo de valor ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="01721-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="01721-457">`A` é uma classe que não é `abstract` e contém um construtor de `public` declarado explicitamente sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="01721-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="01721-458">`A` não é `abstract` e tem um construtor padrão ([construtores padrão](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="01721-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="01721-459">Ocorrerá um erro de tempo de compilação se uma ou mais das restrições de um parâmetro de tipo não forem atendidas pelos argumentos de tipo fornecidos.</span><span class="sxs-lookup"><span data-stu-id="01721-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="01721-460">Como os parâmetros de tipo não são herdados, as restrições nunca são herdadas.</span><span class="sxs-lookup"><span data-stu-id="01721-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="01721-461">No exemplo a seguir, `D` precisa especificar a restrição em seu parâmetro de tipo `T` para que `T` atenda à restrição imposta pela classe base `B<T>`.</span><span class="sxs-lookup"><span data-stu-id="01721-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="01721-462">Por outro lado, a classe `E` não precisa especificar uma restrição, porque `List<T>` implementa `IEnumerable` para qualquer `T`.</span><span class="sxs-lookup"><span data-stu-id="01721-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="01721-463">Parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="01721-463">Type parameters</span></span>

<span data-ttu-id="01721-464">Um parâmetro de tipo é um identificador que designa um tipo de valor ou tipo de referência ao qual o parâmetro está associado em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="01721-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="01721-465">Como um parâmetro de tipo pode ser instanciado com muitos argumentos de tipo real diferentes, os parâmetros de tipo têm operações e restrições ligeiramente diferentes dos outros tipos.</span><span class="sxs-lookup"><span data-stu-id="01721-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="01721-466">Elas incluem:</span><span class="sxs-lookup"><span data-stu-id="01721-466">These include:</span></span>

*  <span data-ttu-id="01721-467">Um parâmetro de tipo não pode ser usado diretamente para declarar uma classe base ([classe base](classes.md#base-class)) ou uma interface ([listas de parâmetros de tipo Variant](interfaces.md#variant-type-parameter-lists)).</span><span class="sxs-lookup"><span data-stu-id="01721-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="01721-468">As regras para pesquisa de membro em parâmetros de tipo dependem das restrições, se houver, aplicadas ao parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="01721-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="01721-469">Eles são detalhados na [pesquisa de membros](expressions.md#member-lookup).</span><span class="sxs-lookup"><span data-stu-id="01721-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="01721-470">As conversões disponíveis para um parâmetro de tipo dependem das restrições, se houver, aplicadas ao parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="01721-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="01721-471">Eles são detalhados em [conversões implícitas envolvendo parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters) e [conversões dinâmicas explícitas](conversions.md#explicit-dynamic-conversions).</span><span class="sxs-lookup"><span data-stu-id="01721-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="01721-472">O `null` literal não pode ser convertido em um tipo fornecido por um parâmetro de tipo, exceto se o parâmetro de tipo for conhecido como um tipo de referência ([conversões implícitas envolvendo parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="01721-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="01721-473">No entanto, uma expressão de `default` ([expressões de valor padrão](expressions.md#default-value-expressions)) pode ser usada em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="01721-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="01721-474">Além disso, um valor com um tipo fornecido por um parâmetro de tipo pode ser comparado com `null` usando `==` e `!=` ([operadores de igualdade de tipo de referência](expressions.md#reference-type-equality-operators)), a menos que o parâmetro de tipo tenha a restrição de tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="01721-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="01721-475">Uma expressão de `new` ([expressões de criação de objeto](expressions.md#object-creation-expressions)) só poderá ser usada com um parâmetro de tipo se o parâmetro de tipo for restrito por uma *constructor_constraint* ou a restrição de tipo de valor (restrições de[parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="01721-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="01721-476">Um parâmetro de tipo não pode ser usado em nenhum lugar dentro de um atributo.</span><span class="sxs-lookup"><span data-stu-id="01721-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="01721-477">Um parâmetro de tipo não pode ser usado em um acesso de membro ([acesso de membro](expressions.md#member-access)) ou nome de tipo ([namespace e nomes de tipo](basic-concepts.md#namespace-and-type-names)) para identificar um membro estático ou um tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="01721-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="01721-478">Em código não seguro, um parâmetro de tipo não pode ser usado como um *unmanaged_type* ([tipos de ponteiro](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="01721-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="01721-479">Como um tipo, os parâmetros de tipo são puramente uma construção de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="01721-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="01721-480">Em tempo de execução, cada parâmetro de tipo é associado a um tipo de tempo de execução que foi especificado fornecendo um argumento de tipo para a declaração de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="01721-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="01721-481">Assim, o tipo de uma variável declarada com um parâmetro de tipo será, em tempo de execução, ser um tipo construído fechado ([tipos abertos e fechados](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="01721-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="01721-482">A execução em tempo de execução de todas as instruções e expressões que envolvem parâmetros de tipo usa o tipo real que foi fornecido como o argumento de tipo para esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="01721-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="01721-483">Tipos de árvore de expressão</span><span class="sxs-lookup"><span data-stu-id="01721-483">Expression tree types</span></span>

<span data-ttu-id="01721-484">As ***árvores de expressão*** permitem que as expressões lambda sejam representadas como estruturas de dados em vez de código executável.</span><span class="sxs-lookup"><span data-stu-id="01721-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="01721-485">Árvores de expressão são valores de ***tipos de árvore de expressão*** do formulário `System.Linq.Expressions.Expression<D>`, em que `D` é qualquer tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="01721-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="01721-486">Para o restante desta especificação, iremos nos referir a esses tipos usando o `Expression<D>`abreviado.</span><span class="sxs-lookup"><span data-stu-id="01721-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="01721-487">Se existir uma conversão de uma expressão lambda para um tipo delegado `D`, uma conversão também existirá para o tipo de árvore de expressão `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="01721-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="01721-488">Enquanto a conversão de uma expressão lambda em um tipo delegado gera um delegado que referencia o código executável para a expressão lambda, a conversão para um tipo de árvore de expressão cria uma representação de árvore de expressão da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="01721-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="01721-489">As árvores de expressão são representações de dados na memória eficientes de expressões lambda e tornam a estrutura da expressão lambda transparente e explícita.</span><span class="sxs-lookup"><span data-stu-id="01721-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="01721-490">Assim como um tipo delegado `D`, o `Expression<D>` é dito para ter tipos de parâmetro e de retorno, que são os mesmos do `D`.</span><span class="sxs-lookup"><span data-stu-id="01721-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="01721-491">O exemplo a seguir representa uma expressão lambda tanto como código executável quanto como uma árvore de expressão.</span><span class="sxs-lookup"><span data-stu-id="01721-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="01721-492">Como existe uma conversão para `Func<int,int>`, uma conversão também existe para `Expression<Func<int,int>>`:</span><span class="sxs-lookup"><span data-stu-id="01721-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="01721-493">Após essas atribuições, o delegado `del` faz referência a um método que retorna `x + 1`e a árvore de expressão `exp` faz referência a uma estrutura de dados que descreve a `x => x + 1`de expressão.</span><span class="sxs-lookup"><span data-stu-id="01721-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="01721-494">A definição exata do tipo genérico `Expression<D>`, bem como as regras precisas para construir uma árvore de expressão quando uma expressão lambda é convertida em um tipo de árvore de expressão, estão fora do escopo desta especificação.</span><span class="sxs-lookup"><span data-stu-id="01721-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="01721-495">Duas coisas são importantes para tornar explícitas:</span><span class="sxs-lookup"><span data-stu-id="01721-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="01721-496">Nem todas as expressões lambda podem ser convertidas em árvores de expressão.</span><span class="sxs-lookup"><span data-stu-id="01721-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="01721-497">Por exemplo, expressões lambda com corpos de instrução e expressões lambda contendo expressões de atribuição não podem ser representadas.</span><span class="sxs-lookup"><span data-stu-id="01721-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="01721-498">Nesses casos, uma conversão ainda existe, mas falhará em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="01721-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="01721-499">Essas exceções são detalhadas em [conversões de função anônimas](conversions.md#anonymous-function-conversions).</span><span class="sxs-lookup"><span data-stu-id="01721-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="01721-500">`Expression<D>` oferece um método de instância `Compile` que produz um delegado do tipo `D`:</span><span class="sxs-lookup"><span data-stu-id="01721-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="01721-501">Invocar esse delegado faz com que o código representado pela árvore de expressão seja executado.</span><span class="sxs-lookup"><span data-stu-id="01721-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="01721-502">Assim, dadas as definições acima, del e del2 são equivalentes, e as duas instruções a seguir terão o mesmo efeito:</span><span class="sxs-lookup"><span data-stu-id="01721-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="01721-503">Depois de executar esse código, `i1` e `i2` terão o valor `2`.</span><span class="sxs-lookup"><span data-stu-id="01721-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>


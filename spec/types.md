# <a name="types"></a><span data-ttu-id="f148e-101">Tipos</span><span class="sxs-lookup"><span data-stu-id="f148e-101">Types</span></span>

<span data-ttu-id="f148e-102">Os tipos de linguagem c# são divididos em duas categorias principais: ***tipos de valor*** e ***tipos de referência***.</span><span class="sxs-lookup"><span data-stu-id="f148e-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="f148e-103">Tipos de valor e tipos de referência podem ser ***tipos genéricos***, que leva um ou mais ***parâmetros de tipo***.</span><span class="sxs-lookup"><span data-stu-id="f148e-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="f148e-104">Parâmetros de tipo podem designar os dois tipos de valor e tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="f148e-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="f148e-105">A categoria final dos tipos de ponteiros, está disponível apenas em código não seguro.</span><span class="sxs-lookup"><span data-stu-id="f148e-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="f148e-106">Isso é discutido mais detalhadamente em [tipos de ponteiro](unsafe-code.md#pointer-types).</span><span class="sxs-lookup"><span data-stu-id="f148e-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="f148e-107">Tipos de valor são diferentes dos tipos de referência de variáveis dos tipos de valor contêm diretamente seus dados, enquanto o armazenamento de tipos de variáveis de referência ***referências*** aos seus dados, o último sendo conhecido como ***objetos***.</span><span class="sxs-lookup"><span data-stu-id="f148e-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="f148e-108">Com tipos de referência, é possível que duas variáveis referenciem o mesmo objeto e, portanto, é possível operações em uma variável afetem o objeto referenciado por outra variável.</span><span class="sxs-lookup"><span data-stu-id="f148e-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="f148e-109">Com tipos de valor, cada variável tem sua própria cópia dos dados e não é possível que operações em um afetem o outro.</span><span class="sxs-lookup"><span data-stu-id="f148e-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="f148e-110">O sistema de tipos do # é unificado, de modo que um valor de qualquer tipo pode ser tratado como um objeto.</span><span class="sxs-lookup"><span data-stu-id="f148e-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="f148e-111">Cada tipo no C#, direta ou indiretamente, deriva do tipo de classe `object`, e `object` é a classe base definitiva de todos os tipos.</span><span class="sxs-lookup"><span data-stu-id="f148e-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="f148e-112">Os valores de tipos de referência são tratados como objetos simplesmente exibindo os valores como tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="f148e-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="f148e-113">Valores de tipos de valor são tratados como objetos, executando operações de conversão boxing e unboxing ([conversões Boxing e unboxing](types.md#boxing-and-unboxing)).</span><span class="sxs-lookup"><span data-stu-id="f148e-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="f148e-114">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="f148e-114">Value types</span></span>

<span data-ttu-id="f148e-115">Um tipo de valor é um tipo de estrutura ou um tipo de enumeração.</span><span class="sxs-lookup"><span data-stu-id="f148e-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="f148e-116">O c# fornece um conjunto de tipos de struct predefinidos chamados de ***tipos simples***.</span><span class="sxs-lookup"><span data-stu-id="f148e-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="f148e-117">Os tipos simples são identificados por meio de palavras reservadas.</span><span class="sxs-lookup"><span data-stu-id="f148e-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="f148e-118">Ao contrário de uma variável do tipo de referência, uma variável de um tipo de valor pode conter o valor `null` somente se o tipo de valor é um tipo anulável.</span><span class="sxs-lookup"><span data-stu-id="f148e-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="f148e-119">Há um tipo de valor anulável correspondente denotando o mesmo conjunto de valores mais o valor para cada tipo de valor não anulável `null`.</span><span class="sxs-lookup"><span data-stu-id="f148e-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="f148e-120">Atribuição para uma variável de um tipo de valor cria uma cópia do valor que está sendo atribuído.</span><span class="sxs-lookup"><span data-stu-id="f148e-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="f148e-121">Isso difere da atribuição a uma variável do tipo de referência, que copia a referência, mas não o objeto identificado por referência.</span><span class="sxs-lookup"><span data-stu-id="f148e-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="f148e-122">O tipo System. ValueType</span><span class="sxs-lookup"><span data-stu-id="f148e-122">The System.ValueType type</span></span>

<span data-ttu-id="f148e-123">Todos os tipos de valor herdam implicitamente da classe `System.ValueType`, que, por sua vez, herda da classe `object`.</span><span class="sxs-lookup"><span data-stu-id="f148e-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="f148e-124">Não é possível para qualquer tipo de derivar de um tipo de valor e tipos de valor, portanto, são lacrados implicitamente ([lacrado classes](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="f148e-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="f148e-125">Observe que `System.ValueType` não é em si um *value_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="f148e-126">Em vez disso, ele é um *class_type* da qual todas as *value_type*s automaticamente são derivados.</span><span class="sxs-lookup"><span data-stu-id="f148e-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="f148e-127">Construtores padrão</span><span class="sxs-lookup"><span data-stu-id="f148e-127">Default constructors</span></span>

<span data-ttu-id="f148e-128">Todos os tipos de valor declaram implicitamente um construtor de instância pública sem-parâmetros chamado a ***construtor padrão***.</span><span class="sxs-lookup"><span data-stu-id="f148e-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="f148e-129">O construtor padrão retorna uma instância inicializada do zero, conhecida como o ***valor padrão*** para o tipo de valor:</span><span class="sxs-lookup"><span data-stu-id="f148e-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="f148e-130">Para todos os *simple_type*s, o valor padrão é o valor produzido por um padrão de bits de todos os zeros:</span><span class="sxs-lookup"><span data-stu-id="f148e-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="f148e-131">Para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, e `ulong`, o valor padrão é `0`.</span><span class="sxs-lookup"><span data-stu-id="f148e-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="f148e-132">Para `char`, o valor padrão é `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="f148e-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="f148e-133">Para `float`, o valor padrão é `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="f148e-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="f148e-134">Para `double`, o valor padrão é `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="f148e-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="f148e-135">Para `decimal`, o valor padrão é `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="f148e-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="f148e-136">Para `bool`, o valor padrão é `false`.</span><span class="sxs-lookup"><span data-stu-id="f148e-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="f148e-137">Para um *enum_type* `E`, o valor padrão é `0`, convertido no tipo `E`.</span><span class="sxs-lookup"><span data-stu-id="f148e-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="f148e-138">Para um *struct_type*, o valor padrão é o valor produzido pela configuração de todos os campos de tipo de valor para seus valores padrão e todas as referências de campos de tipo para `null`.</span><span class="sxs-lookup"><span data-stu-id="f148e-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="f148e-139">Para um *nullable_type* o valor padrão é uma instância para o qual o `HasValue` propriedade é false e o `Value` propriedade é indefinida.</span><span class="sxs-lookup"><span data-stu-id="f148e-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="f148e-140">O valor padrão é também conhecido como o ***valor nulo*** do tipo que permite valor nulo.</span><span class="sxs-lookup"><span data-stu-id="f148e-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="f148e-141">Como qualquer outro construtor de instância, o construtor padrão de um tipo de valor é invocado usando o `new` operador.</span><span class="sxs-lookup"><span data-stu-id="f148e-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="f148e-142">Por motivos de eficiência, esse requisito não se destina para, na verdade, a implementação de gerar uma chamada de construtor.</span><span class="sxs-lookup"><span data-stu-id="f148e-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="f148e-143">No exemplo a seguir, as variáveis `i` e `j` são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="f148e-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="f148e-144">Como cada tipo de valor tem implicitamente um construtor de instância pública sem-parâmetros, não é possível que um tipo de estrutura conter uma declaração explícita de um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f148e-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="f148e-145">No entanto, um tipo de struct é permitido para declarar construtores de instância com parâmetros ([construtores](structs.md#constructors)).</span><span class="sxs-lookup"><span data-stu-id="f148e-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="f148e-146">Tipos struct</span><span class="sxs-lookup"><span data-stu-id="f148e-146">Struct types</span></span>

<span data-ttu-id="f148e-147">Um tipo de struct é um tipo de valor que pode declarar constantes, campos, métodos, propriedades, indexadores, operadores, construtores de instância, construtores estáticos e tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="f148e-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="f148e-148">A declaração de tipos de estrutura é descrita em [declarações de Struct](structs.md#struct-declarations).</span><span class="sxs-lookup"><span data-stu-id="f148e-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="f148e-149">Tipos simples</span><span class="sxs-lookup"><span data-stu-id="f148e-149">Simple types</span></span>

<span data-ttu-id="f148e-150">O c# fornece um conjunto de tipos de struct predefinidos chamados de ***tipos simples***.</span><span class="sxs-lookup"><span data-stu-id="f148e-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="f148e-151">Os tipos simples são identificados por meio de palavras reservadas, mas essas palavras reservadas são simplesmente aliases para tipos de struct predefinidos no `System` namespace, conforme descrito na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="f148e-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="f148e-152">__Palavra reservada__</span><span class="sxs-lookup"><span data-stu-id="f148e-152">__Reserved word__</span></span> | <span data-ttu-id="f148e-153">__Tipo com alias__</span><span class="sxs-lookup"><span data-stu-id="f148e-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="f148e-154">Porque é um tipo simples aliases de um tipo de struct, todos os tipos simples tem membros.</span><span class="sxs-lookup"><span data-stu-id="f148e-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="f148e-155">Por exemplo, `int` tem os membros declarados na `System.Int32` e os membros herdados de `System.Object`, e as instruções a seguir são permitidas:</span><span class="sxs-lookup"><span data-stu-id="f148e-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="f148e-156">Os tipos simples diferem de outros tipos de struct, pois permitem determinadas operações adicionais:</span><span class="sxs-lookup"><span data-stu-id="f148e-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="f148e-157">A maioria dos tipos simples permite valores a serem criados, escrevendo *literais* ([literais](lexical-structure.md#literals)).</span><span class="sxs-lookup"><span data-stu-id="f148e-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="f148e-158">Por exemplo, `123` é um literal do tipo `int` e `'a'` é um literal do tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="f148e-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="f148e-159">C# não faz nenhuma provisão para literais de tipos de struct em geral, e não-padrão valores de outros tipos de struct, por fim, são sempre criadas por meio de construtores de instância desses tipos de struct.</span><span class="sxs-lookup"><span data-stu-id="f148e-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="f148e-160">Quando os operandos de uma expressão forem todas as constantes de tipo simples, é possível que o compilador avaliar a expressão em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="f148e-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="f148e-161">Essa expressão é conhecida como uma *constant_expression* ([expressões constantes](expressions.md#constant-expressions)).</span><span class="sxs-lookup"><span data-stu-id="f148e-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="f148e-162">Expressões que envolvem operadores definidos por outros tipos de struct não são consideradas para ser expressões constantes.</span><span class="sxs-lookup"><span data-stu-id="f148e-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="f148e-163">Por meio `const` declarações é possível declarar constantes dos tipos simples ([constantes](classes.md#constants)).</span><span class="sxs-lookup"><span data-stu-id="f148e-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="f148e-164">Não é possível ter constantes de outros tipos de struct, mas um efeito semelhante é fornecido pelo `static readonly` campos.</span><span class="sxs-lookup"><span data-stu-id="f148e-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="f148e-165">Conversões que envolvem tipos simples podem participar de avaliação de operadores de conversão definidos por outros tipos de struct, mas um operador de conversão definida pelo usuário nunca pode participar de avaliação de outro operador definido pelo usuário ([avaliação do conversões definidas pelo usuário](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="f148e-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="f148e-166">Tipos integrais</span><span class="sxs-lookup"><span data-stu-id="f148e-166">Integral types</span></span>

<span data-ttu-id="f148e-167">C# oferece suporte a nove tipos integrais: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, e `char`.</span><span class="sxs-lookup"><span data-stu-id="f148e-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="f148e-168">Os tipos integrais têm os tamanhos e os intervalos de valores a seguir:</span><span class="sxs-lookup"><span data-stu-id="f148e-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="f148e-169">O `sbyte` tipo representa inteiros com sinal de 8 bits com valores entre -128 e 127.</span><span class="sxs-lookup"><span data-stu-id="f148e-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="f148e-170">O `byte` tipo representa inteiros de 8 bits sem sinal com valores entre 0 e 255.</span><span class="sxs-lookup"><span data-stu-id="f148e-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="f148e-171">O `short` tipo representa inteiros de 16 bits com valores entre -32768 e 32767.</span><span class="sxs-lookup"><span data-stu-id="f148e-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="f148e-172">O `ushort` tipo representa inteiros de 16 bits sem sinal com valores entre 0 e 65535.</span><span class="sxs-lookup"><span data-stu-id="f148e-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="f148e-173">O `int` tipo representa inteiros de 32 bits com valores entre -2147483648 e 2147483647.</span><span class="sxs-lookup"><span data-stu-id="f148e-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="f148e-174">O `uint` tipo representa inteiros de 32 bits sem sinal com valores entre 0 e 4294967295.</span><span class="sxs-lookup"><span data-stu-id="f148e-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="f148e-175">O `long` tipo representa inteiros de 64 bits com valores entre -9223372036854775808 e 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="f148e-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="f148e-176">O `ulong` tipo representa inteiros sem sinal de 64 bits com valores entre 0 e 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="f148e-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="f148e-177">O `char` tipo representa inteiros de 16 bits sem sinal com valores entre 0 e 65535.</span><span class="sxs-lookup"><span data-stu-id="f148e-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="f148e-178">O conjunto de valores possíveis para o tipo `char` corresponde ao conjunto de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="f148e-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="f148e-179">Embora `char` tem a mesma representação `ushort`, nem todas as operações permitidas em um tipo são permitidas no outro.</span><span class="sxs-lookup"><span data-stu-id="f148e-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="f148e-180">O tipo integral operador unário ou binário sempre operam com precisão de 32 bits com sinal, precisão de 32 bits sem sinal, precisão de 64 bits com sinal ou precisão de 64 bits sem sinal:</span><span class="sxs-lookup"><span data-stu-id="f148e-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="f148e-181">Para o operador unário `+` e `~` operadores, o operando é convertido para o tipo `T`, onde `T` é o primeiro `int`, `uint`, `long`, e `ulong` que pode representar totalmente todos valores possíveis do operando.</span><span class="sxs-lookup"><span data-stu-id="f148e-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="f148e-182">A operação, em seguida, é executada usando a precisão do tipo `T`, e o tipo do resultado é `T`.</span><span class="sxs-lookup"><span data-stu-id="f148e-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="f148e-183">Para o operador unário `-` operador, operando será convertido ao tipo `T`, onde `T` é o primeiro `int` e `long` que possam representar todos os valores possíveis do operando.</span><span class="sxs-lookup"><span data-stu-id="f148e-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="f148e-184">A operação, em seguida, é executada usando a precisão do tipo `T`, e o tipo do resultado é `T`.</span><span class="sxs-lookup"><span data-stu-id="f148e-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="f148e-185">O operador unário `-` operador não pode ser aplicado a operandos do tipo `ulong`.</span><span class="sxs-lookup"><span data-stu-id="f148e-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="f148e-186">Para o binário `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, e `<=` operadores, os operandos serão convertidos ao tipo `T`, onde `T` é a primeira das `int`, `uint`, `long`, e `ulong` que possam representar todos os possíveis valores de ambos os operandos.</span><span class="sxs-lookup"><span data-stu-id="f148e-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="f148e-187">A operação, em seguida, é executada usando a precisão do tipo `T`, e o tipo do resultado é `T` (ou `bool` para os operadores relacionais).</span><span class="sxs-lookup"><span data-stu-id="f148e-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="f148e-188">Não é permitido para um operando ser do tipo `long` e outra para ser do tipo `ulong` com os operadores binários.</span><span class="sxs-lookup"><span data-stu-id="f148e-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="f148e-189">Para o binário `<<` e `>>` operadores, o operando esquerdo é convertido para o tipo `T`, onde `T` é o primeiro `int`, `uint`, `long`, e `ulong` que pode representar totalmente todos valores possíveis do operando.</span><span class="sxs-lookup"><span data-stu-id="f148e-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="f148e-190">A operação, em seguida, é executada usando a precisão do tipo `T`, e o tipo do resultado é `T`.</span><span class="sxs-lookup"><span data-stu-id="f148e-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="f148e-191">O `char` tipo é classificado como um tipo integral, mas ele difere de outros tipos integrais de duas maneiras:</span><span class="sxs-lookup"><span data-stu-id="f148e-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="f148e-192">Não há nenhuma conversão implícita de outros tipos de `char` tipo.</span><span class="sxs-lookup"><span data-stu-id="f148e-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="f148e-193">Em particular, mesmo que o `sbyte`, `byte`, e `ushort` tipos têm intervalos de valores que são totalmente representável usando o `char` conversões implícitas de, digite `sbyte`, `byte`, ou `ushort` para `char` não existem.</span><span class="sxs-lookup"><span data-stu-id="f148e-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="f148e-194">Constantes do `char` tipo deve ser escrito como *character_literal*s ou como *integer_literal*s em combinação com uma conversão para o tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="f148e-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="f148e-195">Por exemplo, `(char)10` é o mesmo que `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="f148e-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="f148e-196">O `checked` e `unchecked` instruções e operadores são usadas para controlar a verificação estouro para conversões e operações aritméticas de tipo integral ([os operadores marcados e desmarcados](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="f148e-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="f148e-197">Em um `checked` produz um erro em tempo de compilação de contexto, um estouro ou faz com que um `System.OverflowException` seja lançada.</span><span class="sxs-lookup"><span data-stu-id="f148e-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="f148e-198">Em um `unchecked` contexto, estouros são ignorados e quaisquer bits de ordem superior que não cabem no tipo de destino serão descartados.</span><span class="sxs-lookup"><span data-stu-id="f148e-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="f148e-199">Tipos de ponto flutuante</span><span class="sxs-lookup"><span data-stu-id="f148e-199">Floating point types</span></span>

<span data-ttu-id="f148e-200">C# oferece suporte a dois tipos de ponto flutuante: `float` e `double`.</span><span class="sxs-lookup"><span data-stu-id="f148e-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="f148e-201">O `float` e `double` tipos são representados usando os 32 bits de precisão simples e 64 bits precisão dupla IEEE 754 formatos, que fornecem os seguintes conjuntos de valores:</span><span class="sxs-lookup"><span data-stu-id="f148e-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="f148e-202">Positivo zero e o negativo de zero.</span><span class="sxs-lookup"><span data-stu-id="f148e-202">Positive zero and negative zero.</span></span> <span data-ttu-id="f148e-203">Na maioria das situações, zero positivo e negativo zero se comportam de forma idêntica como simples de valor zero, mas determinadas operações de distinguir entre os dois ([operador de divisão](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="f148e-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="f148e-204">Infinito positivo e negativo infinito.</span><span class="sxs-lookup"><span data-stu-id="f148e-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="f148e-205">Infinitos são produzidos por operações como divisão por zero de um número diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="f148e-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="f148e-206">Por exemplo, `1.0 / 0.0` resulta em infinito positivo, e `-1.0 / 0.0` produz negativo infinito.</span><span class="sxs-lookup"><span data-stu-id="f148e-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="f148e-207">O ***Not-a-Number*** valor NaN muitas vezes abreviado.</span><span class="sxs-lookup"><span data-stu-id="f148e-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="f148e-208">NaNs são produzidas por operações de ponto flutuantes inválidas, como divisão por zero de zero.</span><span class="sxs-lookup"><span data-stu-id="f148e-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="f148e-209">O conjunto finito de valores diferentes de zero do formulário `s * m * 2^e`, onde `s` é 1 ou -1, e `m` e `e` são determinados pelo tipo de ponto flutuante específico: Para `float`, `0 < m < 2^24` e `-149 <= e <= 104`e para `double`, `0 < m < 2^53` e `1075 <= e <= 970`.</span><span class="sxs-lookup"><span data-stu-id="f148e-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `1075 <= e <= 970`.</span></span> <span data-ttu-id="f148e-210">Números de ponto flutuante desnormalizados são considerados valores válidos de diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="f148e-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="f148e-211">O `float` tipo pode representar valores que variam de aproximadamente `1.5 * 10^-45` para `3.4 * 10^38` com uma precisão de 7 dígitos.</span><span class="sxs-lookup"><span data-stu-id="f148e-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="f148e-212">O `double` tipo pode representar valores que variam de aproximadamente `5.0 * 10^-324` para `1.7 × 10^308` com uma precisão de 15-16 dígitos.</span><span class="sxs-lookup"><span data-stu-id="f148e-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="f148e-213">Se um dos operandos de um operador binário é de um tipo de ponto flutuante, em seguida, o outro operando deve ser de um tipo integral ou um tipo de ponto flutuante e a operação é calculada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="f148e-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="f148e-214">Se um dos operandos for do tipo integral, o operando é convertido para o tipo de ponto flutuante de outro operando.</span><span class="sxs-lookup"><span data-stu-id="f148e-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="f148e-215">Em seguida, se qualquer um dos operandos é do tipo `double`, o outro operando é convertido em `double`, a operação é executada usando pelo menos `double` intervalo e precisão e o tipo do resultado é `double` (ou `bool` para o operadores relacionais).</span><span class="sxs-lookup"><span data-stu-id="f148e-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="f148e-216">Caso contrário, a operação é executada usando pelo menos `float` intervalo e precisão e o tipo do resultado é `float` (ou `bool` para os operadores relacionais).</span><span class="sxs-lookup"><span data-stu-id="f148e-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="f148e-217">Os operadores de ponto flutuantes, incluindo os operadores de atribuição, nunca geram exceções.</span><span class="sxs-lookup"><span data-stu-id="f148e-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="f148e-218">Em vez disso, em situações excepcionais, operações de ponto flutuante produzem zero, infinito ou NaN, conforme descrito abaixo:</span><span class="sxs-lookup"><span data-stu-id="f148e-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="f148e-219">Se o resultado de uma operação de ponto flutuante for muito pequeno para o formato de destino, o resultado da operação se torna zero positivo ou negativo de zero.</span><span class="sxs-lookup"><span data-stu-id="f148e-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="f148e-220">Se o resultado de uma operação de ponto flutuante é muito grande para o formato de destino, o resultado da operação se torna infinito positivo ou negativo infinito.</span><span class="sxs-lookup"><span data-stu-id="f148e-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="f148e-221">Se uma operação de ponto flutuante for inválida, o resultado da operação se torna NaN.</span><span class="sxs-lookup"><span data-stu-id="f148e-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="f148e-222">Se um ou ambos os operandos de uma operação de ponto flutuante é NaN, o resultado da operação se torna NaN.</span><span class="sxs-lookup"><span data-stu-id="f148e-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="f148e-223">Operações de ponto flutuantes podem ser executadas com precisão maior do que o tipo de resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="f148e-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="f148e-224">Por exemplo, algumas arquiteturas de hardware oferecem suporte a um tipo de ponto flutuante "extended" ou "long double" com o maior intervalo e a precisão do que o `double` digite e execute implicitamente todas as operações de ponto flutuantes usando esse tipo de precisão mais alta.</span><span class="sxs-lookup"><span data-stu-id="f148e-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="f148e-225">Somente a custo excessivo no desempenho podem essas arquiteturas de hardware ser feitas para executar operações de ponto flutuantes com menos precisão, e em vez de exigir uma implementação perder o desempenho e precisão, c# permite que um tipo de precisão mais alta seja usado para todas as operações de ponto flutuantes.</span><span class="sxs-lookup"><span data-stu-id="f148e-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="f148e-226">Além de fornecer resultados mais precisos, isso raramente tem efeitos mensuráveis.</span><span class="sxs-lookup"><span data-stu-id="f148e-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="f148e-227">No entanto, em expressões do formulário `x * y / z`, em que a multiplicação produz um resultado que está fora os `double` intervalo, mas a divisão subsequente leva o resultados temporários de volta para o `double` de intervalo, o fato de que a expressão é avaliadas em um intervalo maior formato pode causar um resultado finito para ser produzidos em vez de um infinito.</span><span class="sxs-lookup"><span data-stu-id="f148e-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="f148e-228">O tipo decimal</span><span class="sxs-lookup"><span data-stu-id="f148e-228">The decimal type</span></span>

<span data-ttu-id="f148e-229">O tipo `decimal` é um tipo de dados de 128 bits adequado para cálculos financeiros e monetários.</span><span class="sxs-lookup"><span data-stu-id="f148e-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="f148e-230">O `decimal` tipo pode representar valores variando `1.0 * 10^-28` para aproximadamente `7.9 * 10^28` com 28 a 29 dígitos significativos.</span><span class="sxs-lookup"><span data-stu-id="f148e-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="f148e-231">O conjunto finito de valores do tipo `decimal` estão no formato `(-1)^s * c * 10^-e`, em que o sinal `s` for 0 ou 1, o coeficiente `c` será determinada pelos `0 <= *c* < 2^96`e a escala `e` é, de modo que `0 <= e <= 28`. O `decimal` tipo não oferece suporte de NaN, infinitos ou zeros com sinal.</span><span class="sxs-lookup"><span data-stu-id="f148e-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="f148e-232">Um `decimal` é representado como um inteiro de 96 bits dimensionado por uma potência de dez.</span><span class="sxs-lookup"><span data-stu-id="f148e-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="f148e-233">Para `decimal`s com um valor absoluto menor que `1.0m`, o valor é exato para a 28ª casa decimal, mas nenhuma outra.</span><span class="sxs-lookup"><span data-stu-id="f148e-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="f148e-234">Para `decimal`s com um valor absoluto maior que ou igual a `1.0m`, o valor é exatamente a 28 ou 29 dígitos.</span><span class="sxs-lookup"><span data-stu-id="f148e-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="f148e-235">Contrary para o `float` e `double` números fracionários decimais como 0,1 de tipos de dados, podem ser representados exatamente no `decimal` representação.</span><span class="sxs-lookup"><span data-stu-id="f148e-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="f148e-236">No `float` e `double` representações, esses números são geralmente frações infinitas, tornando essas representações mais propensas a arredondar erros.</span><span class="sxs-lookup"><span data-stu-id="f148e-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="f148e-237">Se um dos operandos de um operador binário é do tipo `decimal`, em seguida, o outro operando deve ser do tipo integral ou de tipo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="f148e-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="f148e-238">Se um operando do tipo integral estiver presente, ele será convertido em `decimal` antes da operação é executada.</span><span class="sxs-lookup"><span data-stu-id="f148e-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="f148e-239">O resultado de uma operação em valores do tipo `decimal` é o que resultaria de calcular um resultado exato (preservando escala, conforme definido para cada operador) e, em seguida, o arredondamento de acordo com a representação.</span><span class="sxs-lookup"><span data-stu-id="f148e-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="f148e-240">Os resultados são arredondados para o mais próximo valor representável, e, quando um resultado for igualmente próximo de dois valores representáveis, como o valor que tem um número par na posição de dígitos menos significativa (Isso é conhecido como "arredondamento bancário").</span><span class="sxs-lookup"><span data-stu-id="f148e-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="f148e-241">Um resultado zero sempre tem um sinal de igual a 0 e uma escala de 0.</span><span class="sxs-lookup"><span data-stu-id="f148e-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="f148e-242">Se uma operação aritmética decimal produz um valor menor ou igual a `5 * 10^-29` no valor absoluto, o resultado da operação será zero.</span><span class="sxs-lookup"><span data-stu-id="f148e-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="f148e-243">Se um `decimal` operação aritmética produz um resultado que é muito grande para o `decimal` formato, um `System.OverflowException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="f148e-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="f148e-244">O `decimal` maior precisão do tipo tem um intervalo menor, mas que os tipos de ponto flutuantes.</span><span class="sxs-lookup"><span data-stu-id="f148e-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="f148e-245">Portanto, conversões de tipos de ponto flutuante para `decimal` pode gerar exceções de estouro e conversões de `decimal` para os tipos de ponto flutuantes pode causar perda de precisão.</span><span class="sxs-lookup"><span data-stu-id="f148e-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="f148e-246">Por esses motivos, não há nenhuma conversão implícita entre os tipos de ponto flutuantes e `decimal`, e sem conversões explícitas, não é possível misturar ponto flutuante e `decimal` operandos na mesma expressão.</span><span class="sxs-lookup"><span data-stu-id="f148e-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="f148e-247">O tipo bool</span><span class="sxs-lookup"><span data-stu-id="f148e-247">The bool type</span></span>

<span data-ttu-id="f148e-248">O `bool` tipo representa quantidades lógicas booleanas.</span><span class="sxs-lookup"><span data-stu-id="f148e-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="f148e-249">Os valores possíveis do tipo `bool` estão `true` e `false`.</span><span class="sxs-lookup"><span data-stu-id="f148e-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="f148e-250">Não há nenhuma conversão padrão entre `bool` e outros tipos.</span><span class="sxs-lookup"><span data-stu-id="f148e-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="f148e-251">Em particular, o `bool` o tipo é distinto e separado de tipos integrais e um `bool` valor não pode ser usado no lugar de um valor integral e vice-versa.</span><span class="sxs-lookup"><span data-stu-id="f148e-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="f148e-252">Em linguagens C e C++, um valor zero de ponto flutuante ou integral ou um ponteiro nulo pode ser convertido para o valor booliano `false`, e um valor de ponto flutuante ou integral diferente de zero ou um ponteiro nulo não pode ser convertido para o valor booliano `true`.</span><span class="sxs-lookup"><span data-stu-id="f148e-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="f148e-253">No c#, essas conversões são realizadas por comparar explicitamente um valor integral ou de ponto flutuante como zero ou comparando explicitamente uma referência de objeto `null`.</span><span class="sxs-lookup"><span data-stu-id="f148e-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="f148e-254">Tipos de enumeração</span><span class="sxs-lookup"><span data-stu-id="f148e-254">Enumeration types</span></span>

<span data-ttu-id="f148e-255">Um tipo de enumeração é um tipo distinto com constantes nomeadas.</span><span class="sxs-lookup"><span data-stu-id="f148e-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="f148e-256">Cada tipo de enumeração tem um tipo subjacente, o que deve ser `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` ou `ulong`.</span><span class="sxs-lookup"><span data-stu-id="f148e-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="f148e-257">O conjunto de valores do tipo de enumeração é o mesmo que o conjunto de valores do tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="f148e-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="f148e-258">Valores do tipo de enumeração não são restritos aos valores das constantes nomeadas.</span><span class="sxs-lookup"><span data-stu-id="f148e-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="f148e-259">Tipos de enumeração são definidos por meio de declarações de enumeração ([declarações de Enum](enums.md#enum-declarations)).</span><span class="sxs-lookup"><span data-stu-id="f148e-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="f148e-260">Tipos que permitem valor nulo</span><span class="sxs-lookup"><span data-stu-id="f148e-260">Nullable types</span></span>

<span data-ttu-id="f148e-261">Um tipo anulável pode representar todos os valores do seu ***tipo subjacente*** além de um valor nulo adicional.</span><span class="sxs-lookup"><span data-stu-id="f148e-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="f148e-262">Um tipo que permite valor nulo é escrito `T?`, onde `T` é o tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="f148e-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="f148e-263">Essa sintaxe é uma abreviação para `System.Nullable<T>`, e os dois formatos podem ser usados alternadamente.</span><span class="sxs-lookup"><span data-stu-id="f148e-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="f148e-264">Um ***tipo de valor não anulável*** por outro lado, é qualquer tipo de valor diferente de `System.Nullable<T>` e sua abreviação `T?` (para qualquer `T`), além de qualquer parâmetro de tipo que é restrito para ser um tipo de valor não anulável (ou seja, qualquer parâmetro de tipo com um `struct` restrição).</span><span class="sxs-lookup"><span data-stu-id="f148e-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="f148e-265">O `System.Nullable<T>` tipo Especifica a restrição de tipo de valor para `T` ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)), que significa que o tipo subjacente de um tipo anulável pode ser qualquer tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f148e-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="f148e-266">O tipo subjacente de um tipo anulável não pode ser um tipo anulável ou um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="f148e-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="f148e-267">Por exemplo, `int??` e `string?` são tipos inválidos.</span><span class="sxs-lookup"><span data-stu-id="f148e-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="f148e-268">Uma instância de um tipo anulável `T?` tem duas propriedades públicas somente leitura:</span><span class="sxs-lookup"><span data-stu-id="f148e-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="f148e-269">Um `HasValue` propriedade do tipo `bool`</span><span class="sxs-lookup"><span data-stu-id="f148e-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="f148e-270">Um `Value` propriedade do tipo `T`</span><span class="sxs-lookup"><span data-stu-id="f148e-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="f148e-271">Uma instância para o qual `HasValue` é true será considerada não-nulo.</span><span class="sxs-lookup"><span data-stu-id="f148e-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="f148e-272">Uma instância não-nula contém um valor conhecido e `Value` retorna esse valor.</span><span class="sxs-lookup"><span data-stu-id="f148e-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="f148e-273">Uma instância para o qual `HasValue` é false deve ser nulo.</span><span class="sxs-lookup"><span data-stu-id="f148e-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="f148e-274">Uma instância nula tem um valor indefinido.</span><span class="sxs-lookup"><span data-stu-id="f148e-274">A null instance has an undefined value.</span></span> <span data-ttu-id="f148e-275">Ao tentar ler o `Value` de uma instância nula faz com que um `System.InvalidOperationException` seja lançada.</span><span class="sxs-lookup"><span data-stu-id="f148e-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="f148e-276">O processo de acessar o `Value` propriedade de uma instância que permite valor nula é conhecida como ***descodificar***.</span><span class="sxs-lookup"><span data-stu-id="f148e-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="f148e-277">Além do construtor padrão, todos os tipos anuláveis `T?` tem um construtor público que aceita um único argumento do tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="f148e-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="f148e-278">Dado um valor `x` do tipo `T`, uma invocação de construtor do formulário</span><span class="sxs-lookup"><span data-stu-id="f148e-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="f148e-279">cria uma instância não nulos da `T?` para o qual o `Value` é de propriedade `x`.</span><span class="sxs-lookup"><span data-stu-id="f148e-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="f148e-280">O processo de criação de uma instância não nulos de um tipo anulável de um determinado valor é conhecido como ***encapsulamento***.</span><span class="sxs-lookup"><span data-stu-id="f148e-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="f148e-281">Conversões implícitas estão disponíveis na `null` literal `T?` ([Null literais conversões](conversions.md#null-literal-conversions)) e do `T` para `T?` ([conversões implícitas anuláveis](conversions.md#implicit-nullable-conversions)).</span><span class="sxs-lookup"><span data-stu-id="f148e-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="f148e-282">Tipos de referência</span><span class="sxs-lookup"><span data-stu-id="f148e-282">Reference types</span></span>

<span data-ttu-id="f148e-283">Um tipo de referência é um tipo de classe, um tipo de interface, um tipo de matriz ou um tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="f148e-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="f148e-284">Um valor de tipo de referência é uma referência a um ***instância*** do tipo, o último conhecido como um ***objeto***.</span><span class="sxs-lookup"><span data-stu-id="f148e-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="f148e-285">O valor especial `null` é compatível com todos os tipos de referência e indica a ausência de uma instância.</span><span class="sxs-lookup"><span data-stu-id="f148e-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="f148e-286">Tipos de classe</span><span class="sxs-lookup"><span data-stu-id="f148e-286">Class types</span></span>

<span data-ttu-id="f148e-287">Um tipo de classe define uma estrutura de dados que contém dados membros (campos e constantes), membros da função (métodos, propriedades, eventos, indexadores, operadores, construtores de instância, destruidores e construtores estáticos) e tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="f148e-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="f148e-288">Tipos de classe dá suporte à herança, um mecanismo no qual as classes derivadas podem estender e especializar as classes base.</span><span class="sxs-lookup"><span data-stu-id="f148e-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="f148e-289">Instâncias de tipos de classe são criadas usando *object_creation_expression*s ([expressões de criação do objeto](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="f148e-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="f148e-290">Tipos de classe são descritos em [Classes](classes.md).</span><span class="sxs-lookup"><span data-stu-id="f148e-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="f148e-291">Determinados tipos de classe predefinida têm significado especial na linguagem c#, conforme descrito na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="f148e-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="f148e-292">__Tipo de classe__</span><span class="sxs-lookup"><span data-stu-id="f148e-292">__Class type__</span></span>     | <span data-ttu-id="f148e-293">__Descrição__</span><span class="sxs-lookup"><span data-stu-id="f148e-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="f148e-294">A classe base definitiva de todos os outros tipos.</span><span class="sxs-lookup"><span data-stu-id="f148e-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="f148e-295">Ver [o tipo de objeto](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="f148e-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="f148e-296">O tipo de cadeia de caracteres da linguagem c#.</span><span class="sxs-lookup"><span data-stu-id="f148e-296">The string type of the C# language.</span></span> <span data-ttu-id="f148e-297">Ver [o tipo de cadeia de caracteres](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="f148e-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="f148e-298">A classe base de todos os tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="f148e-298">The base class of all value types.</span></span> <span data-ttu-id="f148e-299">Ver [ValueType o tipo](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="f148e-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="f148e-300">A classe base de todos os tipos de enum.</span><span class="sxs-lookup"><span data-stu-id="f148e-300">The base class of all enum types.</span></span> <span data-ttu-id="f148e-301">Ver [Enums](enums.md).</span><span class="sxs-lookup"><span data-stu-id="f148e-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="f148e-302">A classe base de todos os tipos de matriz.</span><span class="sxs-lookup"><span data-stu-id="f148e-302">The base class of all array types.</span></span> <span data-ttu-id="f148e-303">Consulte [Matrizes](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="f148e-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="f148e-304">A classe base de todos os tipos de delegado.</span><span class="sxs-lookup"><span data-stu-id="f148e-304">The base class of all delegate types.</span></span> <span data-ttu-id="f148e-305">Ver [delegados](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="f148e-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="f148e-306">A classe base de todos os tipos de exceção.</span><span class="sxs-lookup"><span data-stu-id="f148e-306">The base class of all exception types.</span></span> <span data-ttu-id="f148e-307">Ver [exceções](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="f148e-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="f148e-308">O tipo de objeto</span><span class="sxs-lookup"><span data-stu-id="f148e-308">The object type</span></span>

<span data-ttu-id="f148e-309">O `object` tipo de classe é a classe base definitiva de todos os outros tipos.</span><span class="sxs-lookup"><span data-stu-id="f148e-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="f148e-310">Todos os tipos no c#, direta ou indiretamente derivem da `object` tipo de classe.</span><span class="sxs-lookup"><span data-stu-id="f148e-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="f148e-311">A palavra-chave `object` é simplesmente um alias para a classe predefinido `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="f148e-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="f148e-312">O tipo dinâmico</span><span class="sxs-lookup"><span data-stu-id="f148e-312">The dynamic type</span></span>

<span data-ttu-id="f148e-313">O `dynamic` tipo, como `object`, pode fazer referência a qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="f148e-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="f148e-314">Quando os operadores são aplicados a expressões do tipo `dynamic`, sua resolução é adiada até que o programa é executado.</span><span class="sxs-lookup"><span data-stu-id="f148e-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="f148e-315">Portanto, se o operador legalmente não pode ser aplicado ao objeto referenciado, nenhum erro será mostrado durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="f148e-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="f148e-316">Em vez disso, uma exceção será gerada quando a resolução do operador falha em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="f148e-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="f148e-317">Sua finalidade é permitir que a associação dinâmica, que é descrita detalhadamente no [vinculação dinâmica](expressions.md#dynamic-binding).</span><span class="sxs-lookup"><span data-stu-id="f148e-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="f148e-318">`dynamic` é considerado idêntico ao `object` , exceto nos seguintes aspectos:</span><span class="sxs-lookup"><span data-stu-id="f148e-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="f148e-319">Operações em expressões do tipo `dynamic` pode ser vinculado dinamicamente ([vinculação dinâmica](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="f148e-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="f148e-320">Inferência de tipo ([inferência de tipos](expressions.md#type-inference)) vão preferir `dynamic` sobre `object` se ambos forem candidatos.</span><span class="sxs-lookup"><span data-stu-id="f148e-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="f148e-321">Devido a essa equivalência, a seguir contém:</span><span class="sxs-lookup"><span data-stu-id="f148e-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="f148e-322">Há uma conversão implícita de identidade entre `object` e `dynamic`e entre os tipos construídos são iguais ao substituir `dynamic` com `object`</span><span class="sxs-lookup"><span data-stu-id="f148e-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="f148e-323">Conversões implícitas e explícitas para e de `object` também se aplicam para e de `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="f148e-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="f148e-324">Assinaturas de método são iguais ao substituir `dynamic` com `object` são consideradas a mesma assinatura</span><span class="sxs-lookup"><span data-stu-id="f148e-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="f148e-325">O tipo `dynamic` é indistinguível de `object` em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="f148e-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="f148e-326">Uma expressão do tipo `dynamic` é conhecido como um ***expressão dinâmica***.</span><span class="sxs-lookup"><span data-stu-id="f148e-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="f148e-327">O tipo de cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="f148e-327">The string type</span></span>

<span data-ttu-id="f148e-328">O `string` tipo é um tipo de classe sealed que herda diretamente de `object`.</span><span class="sxs-lookup"><span data-stu-id="f148e-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="f148e-329">Instâncias do `string` classe representar cadeias de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="f148e-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="f148e-330">Os valores da `string` tipo pode ser gravado como literais de cadeia de caracteres ([literais de cadeia de caracteres](lexical-structure.md#string-literals)).</span><span class="sxs-lookup"><span data-stu-id="f148e-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="f148e-331">A palavra-chave `string` é simplesmente um alias para a classe predefinido `System.String`.</span><span class="sxs-lookup"><span data-stu-id="f148e-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="f148e-332">Tipos de interface</span><span class="sxs-lookup"><span data-stu-id="f148e-332">Interface types</span></span>

<span data-ttu-id="f148e-333">Uma interface define um contrato.</span><span class="sxs-lookup"><span data-stu-id="f148e-333">An interface defines a contract.</span></span> <span data-ttu-id="f148e-334">Uma classe ou struct que implementa uma interface deve cumprir o contrato.</span><span class="sxs-lookup"><span data-stu-id="f148e-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="f148e-335">Uma interface pode herdar de várias interfaces base e uma classe ou struct pode implementar várias interfaces.</span><span class="sxs-lookup"><span data-stu-id="f148e-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="f148e-336">Tipos de interface são descritos em [Interfaces](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="f148e-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="f148e-337">Tipos de matriz</span><span class="sxs-lookup"><span data-stu-id="f148e-337">Array types</span></span>

<span data-ttu-id="f148e-338">Uma matriz é uma estrutura de dados que contém zero ou mais variáveis que são acessadas por meio de índices calculados.</span><span class="sxs-lookup"><span data-stu-id="f148e-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="f148e-339">As variáveis contidas em uma matriz, também chamada de elementos da matriz, são todos do mesmo tipo, e esse tipo é chamado o tipo de elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="f148e-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="f148e-340">Tipos de matriz são descritos em [matrizes](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="f148e-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="f148e-341">Tipos delegados</span><span class="sxs-lookup"><span data-stu-id="f148e-341">Delegate types</span></span>

<span data-ttu-id="f148e-342">Um delegado é uma estrutura de dados que se refere a um ou mais métodos.</span><span class="sxs-lookup"><span data-stu-id="f148e-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="f148e-343">Por exemplo métodos, ele também se refere às suas instâncias de objeto correspondente.</span><span class="sxs-lookup"><span data-stu-id="f148e-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="f148e-344">O equivalente mais próximo de um delegado em C ou C++ é um ponteiro de função, mas, enquanto um ponteiro de função só pode fazer referência a funções estáticas, um delegado pode referenciar estáticos e métodos de instância.</span><span class="sxs-lookup"><span data-stu-id="f148e-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="f148e-345">No último caso, o delegado armazena não apenas uma referência ao ponto de entrada do método, mas também uma referência à instância do objeto no qual invocar o método.</span><span class="sxs-lookup"><span data-stu-id="f148e-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="f148e-346">Tipos de delegado são descritos em [delegados](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="f148e-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="f148e-347">Conversões boxing e unboxing</span><span class="sxs-lookup"><span data-stu-id="f148e-347">Boxing and unboxing</span></span>

<span data-ttu-id="f148e-348">O conceito de conversões boxing e unboxing é central para o sistema de tipos do #.</span><span class="sxs-lookup"><span data-stu-id="f148e-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="f148e-349">Ele fornece uma ponte entre *value_type*s e *reference_type*s, permitindo que qualquer valor de um *value_type* a ser convertido para e do tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="f148e-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="f148e-350">Conversões boxing e unboxing permite que uma exibição unificada do sistema de tipo no qual um valor de qualquer tipo, por fim, pode ser tratado como um objeto.</span><span class="sxs-lookup"><span data-stu-id="f148e-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="f148e-351">Conversões boxing</span><span class="sxs-lookup"><span data-stu-id="f148e-351">Boxing conversions</span></span>

<span data-ttu-id="f148e-352">Permite que uma conversão boxing um *value_type* a ser convertido implicitamente em um *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="f148e-353">As seguintes conversões boxing existirem:</span><span class="sxs-lookup"><span data-stu-id="f148e-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="f148e-354">De qualquer *value_type* para o tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="f148e-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="f148e-355">De qualquer *value_type* para o tipo `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="f148e-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="f148e-356">De qualquer *non_nullable_value_type* a qualquer *interface_type* implementado pelos *value_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="f148e-357">De qualquer *nullable_type* a qualquer *interface_type* implementado pelo tipo subjacente dos *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="f148e-358">De qualquer *enum_type* para o tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="f148e-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="f148e-359">De qualquer *nullable_type* com uma subjacente *enum_type* para o tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="f148e-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="f148e-360">Observe que uma conversão implícita de um parâmetro de tipo será executada como uma conversão boxing se em tempo de execução que ele acaba convertendo de um tipo de valor para um tipo de referência ([conversões implícitas que envolvem parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="f148e-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="f148e-361">Conversão boxing de um valor de uma *non_nullable_value_type* consiste de alocar uma instância do objeto e copiando o *non_nullable_value_type* valor para essa instância.</span><span class="sxs-lookup"><span data-stu-id="f148e-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="f148e-362">Conversão boxing de um valor de uma *nullable_type* produz uma referência nula se for o `null` valor (`HasValue` é `false`), ou o resultado de desempacotamento e boxing caso contrário, o valor subjacente.</span><span class="sxs-lookup"><span data-stu-id="f148e-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="f148e-363">O processo de conversão boxing de um valor de uma *non_nullable_value_type* é melhor explicada por imaginando a existência de um genérico ***classe boxing***, que se comporta como se tivesse sido declarada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="f148e-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="f148e-364">Conversão boxing de um valor `v` do tipo `T` agora consiste em executar a expressão `new Box<T>(v)`e retornar a instância resultante como um valor do tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="f148e-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="f148e-365">Portanto, as instruções</span><span class="sxs-lookup"><span data-stu-id="f148e-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="f148e-366">Conceitualmente, correspondem aos</span><span class="sxs-lookup"><span data-stu-id="f148e-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="f148e-367">Uma classe de conversão boxing como `Box<T>` acima, na verdade, não existe e, na verdade, um tipo de classe não é do tipo dinâmico de um valor Demarcado.</span><span class="sxs-lookup"><span data-stu-id="f148e-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="f148e-368">Em vez disso, um valor demarcado do tipo `T` tem o tipo dinâmico `T`e uma verificação de tipo dinâmico usando o `is` operador pode simplesmente fazer referência a tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="f148e-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="f148e-369">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="f148e-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="f148e-370">retornará a cadeia de caracteres "`Box contains an int`" no console.</span><span class="sxs-lookup"><span data-stu-id="f148e-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="f148e-371">Uma conversão boxing implica fazendo uma cópia do valor sendo convertido.</span><span class="sxs-lookup"><span data-stu-id="f148e-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="f148e-372">Isso é diferente de uma conversão de um *reference_type* digitar `object`, em que o valor continua a referência à mesma instância e simplesmente é considerado como o tipo menos derivado `object`.</span><span class="sxs-lookup"><span data-stu-id="f148e-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="f148e-373">Por exemplo, dada a declaração</span><span class="sxs-lookup"><span data-stu-id="f148e-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="f148e-374">as instruções a seguir</span><span class="sxs-lookup"><span data-stu-id="f148e-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="f148e-375">será o valor 10 no console de saída porque a operação de conversão boxing implícita que ocorre na atribuição de `p` à `box` faz com que o valor de `p` a ser copiado.</span><span class="sxs-lookup"><span data-stu-id="f148e-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="f148e-376">Tinha `Point` foi declarado um `class` em vez disso, o valor 20 seria saída porque `p` e `box` faria referência à mesma instância.</span><span class="sxs-lookup"><span data-stu-id="f148e-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="f148e-377">Conversões de conversão unboxing</span><span class="sxs-lookup"><span data-stu-id="f148e-377">Unboxing conversions</span></span>

<span data-ttu-id="f148e-378">Permite que uma conversão unboxing uma *reference_type* a ser convertido explicitamente em um *value_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="f148e-379">Existem as seguintes conversões unboxing:</span><span class="sxs-lookup"><span data-stu-id="f148e-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="f148e-380">Do tipo `object` a qualquer *value_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="f148e-381">Do tipo `System.ValueType` a qualquer *value_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="f148e-382">De qualquer *interface_type* a qualquer *non_nullable_value_type* que implementa o *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="f148e-383">De qualquer *interface_type* a qualquer *nullable_type* cujo tipo subjacente implementa o *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="f148e-384">Do tipo `System.Enum` a qualquer *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="f148e-385">Do tipo `System.Enum` a qualquer *nullable_type* com uma subjacente *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="f148e-386">Observe que uma conversão explícita para um parâmetro de tipo será executada como uma conversão unboxing se em tempo de execução que ele acaba convertendo de um tipo de referência para um tipo de valor ([conversões explícitas de dinâmicas](conversions.md#explicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="f148e-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="f148e-387">Uma operação de conversão unboxing para um *non_nullable_value_type* consiste em verificar primeiro que a instância do objeto é um valor demarcado da determinado *non_nullable_value_type*e, em seguida, copiar o valor da instância.</span><span class="sxs-lookup"><span data-stu-id="f148e-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="f148e-388">Unboxing para um *nullable_type* produz o valor null da *nullable_type* se o operando de origem for `null`, ou o resultado encapsulado de conversão unboxing a instância do objeto para o tipo subjacente dos *nullable_type* caso contrário.</span><span class="sxs-lookup"><span data-stu-id="f148e-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="f148e-389">Consultando a classe de conversão boxing imaginário descrita na seção anterior, uma conversão unboxing de um objeto `box` para um *value_type* `T` consiste em executar a expressão `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="f148e-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="f148e-390">Portanto, as instruções</span><span class="sxs-lookup"><span data-stu-id="f148e-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="f148e-391">Conceitualmente, correspondem aos</span><span class="sxs-lookup"><span data-stu-id="f148e-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="f148e-392">Para uma conversão unboxing para um determinado *non_nullable_value_type* para ter êxito em tempo de execução, o valor do operando de origem deve ser uma referência a um valor demarcado isso *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="f148e-393">Se o operando de origem `null`, um `System.NullReferenceException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="f148e-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="f148e-394">Se o operando de origem for uma referência a um objeto incompatível, um `System.InvalidCastException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="f148e-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="f148e-395">Para uma conversão unboxing para um determinado *nullable_type* para ter êxito em tempo de execução, o valor do operando de origem deve ser `null` ou uma referência a um valor demarcado de subjacente *non_nullable_value_type* do *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="f148e-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="f148e-396">Se o operando de origem for uma referência a um objeto incompatível, um `System.InvalidCastException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="f148e-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="f148e-397">Tipos construídos</span><span class="sxs-lookup"><span data-stu-id="f148e-397">Constructed types</span></span>

<span data-ttu-id="f148e-398">Uma declaração de tipo genérico, por si só, denota um ***desassociada do tipo genérico*** que é usado como uma "esquema" para formar a muitos tipos diferentes, por meio da aplicação ***argumentos do tipo***.</span><span class="sxs-lookup"><span data-stu-id="f148e-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="f148e-399">Os argumentos de tipo são gravados dentro de colchetes angulares (`<` e `>`) imediatamente após o nome do tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f148e-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="f148e-400">Um tipo que inclui pelo menos um argumento de tipo é chamado de um ***tipo construído***.</span><span class="sxs-lookup"><span data-stu-id="f148e-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="f148e-401">Um tipo construído pode ser usado na maioria dos lugares no idioma em que um nome de tipo pode aparecer.</span><span class="sxs-lookup"><span data-stu-id="f148e-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="f148e-402">Um tipo genérico não associado pode ser usado somente dentro de um *typeof_expression* ([o operador typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="f148e-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="f148e-403">Tipos construídos também podem ser usados em expressões como nomes simples ([nomes simples](expressions.md#simple-names)) ou ao acessar um membro ([acesso de membro](expressions.md#member-access)).</span><span class="sxs-lookup"><span data-stu-id="f148e-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="f148e-404">Quando um *namespace_or_type_name* é avaliados, somente tipos genéricos com o número correto de parâmetros são considerados de tipo.</span><span class="sxs-lookup"><span data-stu-id="f148e-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="f148e-405">Portanto, é possível usar o mesmo identificador para identificar tipos diferentes, desde que os tipos têm diferentes números de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="f148e-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="f148e-406">Isso é útil ao misturar as classes genéricas e não genéricas no mesmo programa:</span><span class="sxs-lookup"><span data-stu-id="f148e-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="f148e-407">Um *type_name* pode identificar um tipo construído, mesmo que ele não especifica os parâmetros de tipo diretamente.</span><span class="sxs-lookup"><span data-stu-id="f148e-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="f148e-408">Isso pode ocorrer em que um tipo é aninhado dentro de uma declaração de classe genérica e o tipo de instância da declaração do recipiente implicitamente é usado para pesquisa de nome ([aninhados de tipos em classes genéricas](classes.md#nested-types-in-generic-classes)):</span><span class="sxs-lookup"><span data-stu-id="f148e-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="f148e-409">Um tipo construído em código não seguro, não pode ser usado como um *unmanaged_type* ([tipos de ponteiro](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="f148e-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="f148e-410">Argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="f148e-410">Type arguments</span></span>

<span data-ttu-id="f148e-411">Cada argumento em uma lista de argumentos de tipo é simplesmente uma *tipo*.</span><span class="sxs-lookup"><span data-stu-id="f148e-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="f148e-412">Em código não seguro ([código não seguro](unsafe-code.md)), um *type_argument* não pode ser um tipo de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="f148e-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="f148e-413">Cada argumento de tipo deve atender quaisquer restrições no correspondente de parâmetro de tipo ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="f148e-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="f148e-414">Tipos abertos e fechados</span><span class="sxs-lookup"><span data-stu-id="f148e-414">Open and closed types</span></span>

<span data-ttu-id="f148e-415">Todos os tipos podem ser classificados como ***tipos abertos*** ou ***fechado tipos***.</span><span class="sxs-lookup"><span data-stu-id="f148e-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="f148e-416">Um tipo aberto é um tipo que envolve a parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="f148e-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="f148e-417">Mais especificamente:</span><span class="sxs-lookup"><span data-stu-id="f148e-417">More specifically:</span></span>

*  <span data-ttu-id="f148e-418">Um parâmetro de tipo define um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="f148e-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="f148e-419">Um tipo de matriz é um tipo aberto se e somente se o tipo de elemento é um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="f148e-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="f148e-420">Um tipo construído é um tipo aberto se e somente se um ou mais dos argumentos de tipo é um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="f148e-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="f148e-421">Um tipo aninhado construído é um tipo aberto se e somente se um ou mais dos seus argumentos de tipo ou os argumentos de tipo do seu tipo recipiente (s) são um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="f148e-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="f148e-422">Um tipo fechado é um tipo que não é um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="f148e-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="f148e-423">Em tempo de execução, todo o código dentro de uma declaração de tipo genérico é executado no contexto de um tipo construído fechado que foi criado por meio da aplicação de argumentos de tipo para a declaração genérica.</span><span class="sxs-lookup"><span data-stu-id="f148e-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="f148e-424">Cada parâmetro de tipo dentro de tipo genérico é associado a um determinado tipo de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="f148e-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="f148e-425">O processamento de tempo de execução de todas as instruções e expressões sempre ocorre com tipos fechados, e tipos abertos ocorrerem somente durante o tempo de compilação processamento.</span><span class="sxs-lookup"><span data-stu-id="f148e-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="f148e-426">Cada tipo construído fechado tem seu próprio conjunto de variáveis estáticas, que não são compartilhadas com nenhum outro tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="f148e-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="f148e-427">Uma vez que um tipo aberto não existir no tempo de execução, não há nenhuma variável estática associado com um tipo aberto.</span><span class="sxs-lookup"><span data-stu-id="f148e-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="f148e-428">Dois tipos construídos fechados são do mesmo tipo se eles são construídos a partir do mesmo tipo genérico não associado, e seus argumentos de tipo correspondente são do mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="f148e-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="f148e-429">Associadas e tipos</span><span class="sxs-lookup"><span data-stu-id="f148e-429">Bound and unbound types</span></span>

<span data-ttu-id="f148e-430">O termo ***desassociada tipo*** se refere a um tipo não genérico ou um tipo genérico não associado.</span><span class="sxs-lookup"><span data-stu-id="f148e-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="f148e-431">O termo ***vinculado tipo*** se refere a um tipo não genérico ou um tipo construído.</span><span class="sxs-lookup"><span data-stu-id="f148e-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="f148e-432">Um tipo não associado refere-se à entidade declarada com uma declaração de tipo.</span><span class="sxs-lookup"><span data-stu-id="f148e-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="f148e-433">Um tipo genérico não associado não é propriamente um tipo e não pode ser usado como o tipo de uma variável, o argumento ou o valor de retorno ou como um tipo base.</span><span class="sxs-lookup"><span data-stu-id="f148e-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="f148e-434">A construção de apenas um tipo genérico não associado no qual pode ser referenciado é o `typeof` expressão ([o operador typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="f148e-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="f148e-435">Restrições satisfatória</span><span class="sxs-lookup"><span data-stu-id="f148e-435">Satisfying constraints</span></span>

<span data-ttu-id="f148e-436">Sempre que um tipo construído ou método genérico é referenciado, os argumentos de tipo fornecido são comparados com as restrições de parâmetro de tipo declaradas no tipo genérico ou método ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="f148e-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="f148e-437">Para cada `where` cláusula, o argumento de tipo `A` que corresponde ao nomeado parâmetro de tipo é verificado em relação a cada restrição da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="f148e-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="f148e-438">Se a restrição é um tipo de classe, um tipo de interface ou um parâmetro de tipo, permita que o `C` representam que a restrição com os argumentos de tipo fornecido substituído para qualquer parâmetro de tipo que aparecem na restrição.</span><span class="sxs-lookup"><span data-stu-id="f148e-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="f148e-439">Para satisfazer a restrição, ele deve ser o caso que digita `A` pode ser convertido no tipo `C` por um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="f148e-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="f148e-440">Uma conversão de identidade ([conversão de identidade](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="f148e-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="f148e-441">Uma conversão implícita de referência ([conversões de referência implícita](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="f148e-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="f148e-442">Uma conversão boxing ([conversões Boxing](conversions.md#boxing-conversions)), desde que um é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f148e-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="f148e-443">Uma conversão implícita de parâmetro de referência, conversão boxing ou tipo de um parâmetro de tipo `A` para `C`.</span><span class="sxs-lookup"><span data-stu-id="f148e-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="f148e-444">Se a restrição é a restrição de tipo de referência (`class`), o tipo `A` deve atender a um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="f148e-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="f148e-445">`A` é um tipo de interface, o tipo de classe, o tipo de delegado ou o tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="f148e-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="f148e-446">Observe que `System.ValueType` e `System.Enum` são tipos de referência que atendem a essa restrição.</span><span class="sxs-lookup"><span data-stu-id="f148e-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="f148e-447">`A` é um parâmetro de tipo que é conhecido por ser um tipo de referência ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="f148e-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="f148e-448">Se a restrição é a restrição de tipo de valor (`struct`), o tipo `A` deve atender a um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="f148e-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="f148e-449">`A` é um tipo de estrutura ou tipo enum, mas não é um tipo anulável.</span><span class="sxs-lookup"><span data-stu-id="f148e-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="f148e-450">Observe que `System.ValueType` e `System.Enum` são tipos de referência que não atendem a essa restrição.</span><span class="sxs-lookup"><span data-stu-id="f148e-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="f148e-451">`A` é um parâmetro de tipo com a restrição de tipo de valor ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="f148e-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="f148e-452">Se a restrição é a restrição de construtor `new()`, o tipo `A` não deve ser `abstract` e deve ter um construtor público sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f148e-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="f148e-453">Isso é atendido se uma das seguintes opções for verdadeira:</span><span class="sxs-lookup"><span data-stu-id="f148e-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="f148e-454">`A` é um tipo de valor, uma vez que todos os tipos de valor têm um construtor público padrão ([1&gt;construtores padrão](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="f148e-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="f148e-455">`A` é um parâmetro de tipo com restrição de construtor ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="f148e-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="f148e-456">`A` é um parâmetro de tipo com a restrição de tipo de valor ([restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="f148e-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="f148e-457">`A` é uma classe que não seja `abstract` e contém um explicitamente declarado `public` construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f148e-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="f148e-458">`A` não é `abstract` e tem um construtor padrão ([1&gt;construtores padrão](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="f148e-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="f148e-459">Ocorrerá um erro de tempo de compilação se uma ou mais das restrições do parâmetro de tipo não são atendidas pelos argumentos de tipo em questão.</span><span class="sxs-lookup"><span data-stu-id="f148e-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="f148e-460">Uma vez que os parâmetros de tipo não são herdados, restrições nunca sejam herdados de qualquer um.</span><span class="sxs-lookup"><span data-stu-id="f148e-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="f148e-461">No exemplo a seguir, `D` precisa especificar a restrição de parâmetro de tipo `T` , de modo que `T` satisfaz a restrição imposta pela classe base `B<T>`.</span><span class="sxs-lookup"><span data-stu-id="f148e-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="f148e-462">Por outro lado, a classe `E` não é necessário especificar uma restrição, pois `List<T>` implementa `IEnumerable` para qualquer `T`.</span><span class="sxs-lookup"><span data-stu-id="f148e-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="f148e-463">Parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="f148e-463">Type parameters</span></span>

<span data-ttu-id="f148e-464">Um parâmetro de tipo é um identificador que designa um tipo de valor ou tipo de referência que o parâmetro está associado em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="f148e-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="f148e-465">Uma vez que um parâmetro de tipo pode ser instanciado com muitos argumentos de tipo real diferente, parâmetros de tipo têm operações ligeiramente diferentes e restrições do que outros tipos.</span><span class="sxs-lookup"><span data-stu-id="f148e-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="f148e-466">Elas incluem:</span><span class="sxs-lookup"><span data-stu-id="f148e-466">These include:</span></span>

*  <span data-ttu-id="f148e-467">Um parâmetro de tipo não pode ser usado diretamente para declarar uma classe base ([classe Base](classes.md#base-class)) ou interface ([listas de parâmetros de tipo de variante](interfaces.md#variant-type-parameter-lists)).</span><span class="sxs-lookup"><span data-stu-id="f148e-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="f148e-468">As regras para a pesquisa de membro no tipo de parâmetros dependem de restrições, se houver, é aplicado ao parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="f148e-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="f148e-469">Elas são detalhadas nas [pesquisa de membro](expressions.md#member-lookup).</span><span class="sxs-lookup"><span data-stu-id="f148e-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="f148e-470">As conversões disponíveis para um parâmetro de tipo depende das restrições, se houver, aplicado ao parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="f148e-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="f148e-471">Elas são detalhadas nas [conversões implícitas que envolvem parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters) e [conversões explícitas de dinâmicas](conversions.md#explicit-dynamic-conversions).</span><span class="sxs-lookup"><span data-stu-id="f148e-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="f148e-472">O literal `null` não pode ser convertido em um tipo de dado por um parâmetro de tipo, exceto se o parâmetro de tipo é conhecido por ser um tipo de referência ([conversões implícitas que envolvem parâmetros de tipo](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="f148e-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="f148e-473">No entanto, uma `default` expressão ([expressões de valor padrão](expressions.md#default-value-expressions)) pode ser usado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="f148e-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="f148e-474">Além disso, um valor com um tipo de dado por um parâmetro de tipo pode ser comparado com `null` usando `==` e `!=` ([operadores de igualdade de tipo de referência](expressions.md#reference-type-equality-operators)), a menos que o parâmetro de tipo tem a restrição de tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="f148e-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="f148e-475">Um `new` expressão ([expressões de criação do objeto](expressions.md#object-creation-expressions)) só pode ser usado com um parâmetro de tipo, se o parâmetro de tipo é restrita por uma *constructor_constraint* ou o valor de tipo de restrição ([ Restrições de parâmetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="f148e-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="f148e-476">Um parâmetro de tipo não pode ser usado em qualquer lugar dentro de um atributo.</span><span class="sxs-lookup"><span data-stu-id="f148e-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="f148e-477">Um parâmetro de tipo não pode ser usado em um acesso de membro ([acesso de membro](expressions.md#member-access)) ou nome de tipo ([nomes de Namespace e tipo](basic-concepts.md#namespace-and-type-names)) para identificar um membro estático ou um tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="f148e-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="f148e-478">O código não seguro, um parâmetro de tipo não pode ser usado como um *unmanaged_type* ([tipos de ponteiro](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="f148e-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="f148e-479">Como um tipo, parâmetros de tipo são puramente um constructo de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="f148e-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="f148e-480">Em tempo de execução, cada parâmetro de tipo é associado a um tipo de tempo de execução que foi especificado, fornecendo um argumento de tipo para a declaração de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f148e-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="f148e-481">Assim, o tipo de uma variável declarada com um testamento de parâmetro de tipo, em tempo de execução, ser um tipo construído fechado ([aberto e fechado tipos](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="f148e-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="f148e-482">O tempo de execução de todas as instruções e expressões que envolvem parâmetros de tipo usa o tipo real que foi fornecido como o argumento de tipo para esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="f148e-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="f148e-483">Tipos de árvore de expressão</span><span class="sxs-lookup"><span data-stu-id="f148e-483">Expression tree types</span></span>

<span data-ttu-id="f148e-484">***Árvores de expressão*** permitir que as expressões lambda sejam representadas como estruturas de dados em vez de código executável.</span><span class="sxs-lookup"><span data-stu-id="f148e-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="f148e-485">Árvores de expressão são valores de ***tipos de árvore de expressão*** do formulário `System.Linq.Expressions.Expression<D>`, onde `D` é qualquer tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="f148e-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="f148e-486">Para o restante dessa especificação nos referiremos a esses tipos usando a forma abreviada `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="f148e-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="f148e-487">Se existe uma conversão de uma expressão lambda para um tipo de delegado `D`, também existe uma conversão para o tipo de árvore de expressão `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="f148e-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="f148e-488">Enquanto a conversão de uma expressão lambda para um tipo delegado gera um delegado que referencia o código executável para a expressão lambda, a conversão para um tipo de árvore de expressão cria uma representação de árvore de expressão da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="f148e-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="f148e-489">Árvores de expressão são representações eficiente de dados na memória de expressões lambda e tornam a estrutura da expressão lambda explícita e transparente.</span><span class="sxs-lookup"><span data-stu-id="f148e-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="f148e-490">Assim como um tipo de delegado `D`, `Expression<D>` tem o parâmetro e tipos de retorno, que são as mesmas que aquelas de `D`.</span><span class="sxs-lookup"><span data-stu-id="f148e-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="f148e-491">O exemplo a seguir representa uma expressão lambda como código executável e como uma árvore de expressão.</span><span class="sxs-lookup"><span data-stu-id="f148e-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="f148e-492">Porque existe uma conversão para `Func<int,int>`, também existe uma conversão para `Expression<Func<int,int>>`:</span><span class="sxs-lookup"><span data-stu-id="f148e-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="f148e-493">Seguindo essas atribuições, o delegado `del` faz referência a um método que retorna `x + 1`e a árvore de expressão `exp` faz referência a uma estrutura de dados que descreve a expressão `x => x + 1`.</span><span class="sxs-lookup"><span data-stu-id="f148e-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="f148e-494">A definição exata do tipo genérico `Expression<D>` , bem como as regras precisas para construir uma árvore de expressão quando uma expressão lambda é convertida em um tipo de árvore de expressão, estão fora do escopo desta especificação.</span><span class="sxs-lookup"><span data-stu-id="f148e-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="f148e-495">Duas coisas são importantes para tornar explícito:</span><span class="sxs-lookup"><span data-stu-id="f148e-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="f148e-496">Nem todas as expressões de lambda podem ser convertidas em árvores de expressão.</span><span class="sxs-lookup"><span data-stu-id="f148e-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="f148e-497">Por exemplo, as expressões lambda com corpos de instrução e expressões lambda que contêm expressões de atribuição não podem ser representado.</span><span class="sxs-lookup"><span data-stu-id="f148e-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="f148e-498">Nesses casos, uma conversão ainda existe, mas falhará no tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="f148e-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="f148e-499">Essas exceções são detalhadas em [conversões de função anônima](conversions.md#anonymous-function-conversions).</span><span class="sxs-lookup"><span data-stu-id="f148e-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="f148e-500">`Expression<D>` oferece um método de instância `Compile` que produz um delegado do tipo `D`:</span><span class="sxs-lookup"><span data-stu-id="f148e-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="f148e-501">Invocar esse delegado faz com que o código representado pela árvore de expressão a ser executado.</span><span class="sxs-lookup"><span data-stu-id="f148e-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="f148e-502">Assim, considerando as definições acima, del e del2 são equivalentes e as duas instruções a seguir terá o mesmo efeito:</span><span class="sxs-lookup"><span data-stu-id="f148e-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="f148e-503">Depois de executar esse código `i1` e `i2` terão o valor `2`.</span><span class="sxs-lookup"><span data-stu-id="f148e-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>

